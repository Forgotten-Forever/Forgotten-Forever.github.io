{"meta":{"title":"BLOG","subtitle":"LiuLiu's BLOG","description":"python 学习","author":"Liu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-07-27T13:54:21.000Z","updated":"2020-07-27T13:54:33.452Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-27T13:53:15.000Z","updated":"2020-07-27T13:53:46.125Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-27T13:53:26.000Z","updated":"2020-07-27T13:54:06.426Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis_basis","slug":"redis-basis","date":"2021-03-01T02:05:44.000Z","updated":"2021-03-01T02:06:25.237Z","comments":true,"path":"2021/03/01/redis-basis/","link":"","permalink":"http://yoursite.com/2021/03/01/redis-basis/","excerpt":"","text":"Redis 数据结构一、Redis基础知识 redis 启动客户端与服务器命令 123redis-server [服务器配置文件] : 服务器命令 [启动特定端口的服务器,默认端口为 6379]redis-cli [-p 端口号]: 客户端命令 [启动一个特定端口的客户端,默认端口为 6379] 一个redis.windows.conf配置就是一个redis服务器。需要启动多个服务器时，只需要修改一下这个配置文件redis.windows.conf的名称，更改端口号，再用redis-server就可以启动。 复制配置文件 redis.windows.conf 并改名 在新配置中更改端口号 使用启动命令启动服务端 启动默认服务器 启动修改后端口服务器 使用启动命令启动客户端 启动默认客户端 启动修改端口后客户端 redis 和 memcached 独特之处 redis 可以持久化保存数据到硬盘；memcached 只可以做缓存 redis 相比于 memcached,支持数据类型更多 redis 优点 读写速度快: redis 数据存放在内存内,数据结构类似于 HashMap, HashMap 的优势就是查找和操作时间复杂度都是O(1) 支持丰富的数据类型: string, hash, list, set, sorted 支持简单的事务: watch 丰富的特性: 可以用于缓存，消息队列，按 key 设置过期时间,到期后自动删除 支持数据持久化: 支持AOF和RDB 两种持久化方式,从而进行数据的恢复操作,可以有效防止数据丢失 支持主从复制实现数据备份: 主机会自动将数据同步到从机 Redis 目录下的重要文件意义 redis-benchmark :性能测试工具 redis-check-aof: 日志文件检测工具 (可以检测并修复由于各种突发原因造成的日志损坏, eg:断电) redis-check-dump: 快照文件检测工具 (可以检测并修复由于各种突发原因造成的快照损坏, eg:断电) redis-cli: redis 客户端 redis-server: redis 服务器 redis.windows.conf: redis 配置文件 在启动 redis 时 一个配置文件相当于一个服务器数据库 redis基础命令 keys * : 返回所有键 (key) keys na*: 返回所有以 na 开头的键 exists name: 判断 name 键 是否存在 del name: 删除 name 键 expire key_name 10: 设置 key_name 键的过期时间为 10s 后 (自动删除) 通过这种有效期可以做到自动删除，其实有效期到了，也不是立马删除的，删除的时机是有配置文件决定的 ttl key_name: 查看 key_name 键的过期时间,-1 表示已过期 或永不过期 move name 1: 将键名为 name 的键转移到 1 的数据库 select 1: 进入到 1 的数据库中,默认为在 0 数据库 persist name: 移除 name 键的过期时间 flushdb: 删除所有的数据,清除当前所在库的所有数据 flushall: 清空所有数据 二、redis 数据类型1. String 字符串 十二种方法 set 方法: 设置 key 对应的值为 string 类型的 value,如果 key 已经存在,则覆盖 key 对应的 value 值.(在 redis 中 key 只能有一个) 12127.0.0.1:6379[1]&gt; set name liuliuOK get 方法: 根据 key 获取 value 值 12127.0.0.1:6379[1]&gt; get name&quot;liuliu&quot; setnx 方法: 设置一个不存在的字符串,返回 0 表示设置失败，已存在；返回 1 标识设置新值成功(nx: not exist) 1234567891011127.0.0.1:6379[1]&gt; setnx name angel(integer) 0127.0.0.1:6379[1]&gt; setnx age 23(integer) 1127.0.0.1:6379[1]&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379[1]&gt; get name&quot;liuliu&quot; 127.0.0.1:6379[1]&gt; get age&quot;23&quot; setex: 设置字符串,同时设置有效期。(ex – expire 有效期) 123456789101112131415127.0.0.1:6379[1]&gt; setex color 20 redOK立即查看 keys127.0.0.1:6379[1]&gt; keys *1) &quot;color&quot;2) &quot;name&quot;3) &quot;age&quot;127.0.0.1:6379[1]&gt; get color&quot;red&quot;20s 后查看 keys127.0.0.1:6379[1]&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379[1]&gt; get color(nil) setrange: 替换字符串: etrange key offset value 123456127.0.0.1:6379[1]&gt; get name&quot;liuliu&quot;127.0.0.1:6379[1]&gt; setrange name 3 fei(integer) 6127.0.0.1:6379[1]&gt; get name&quot;liufei&quot; mset: 一次设置多个 key-value, 返回 ok 表示设置成功,返回 0 表示全部失败。如果存在则替换.(m – multi) mset key value [key value ...] 1234567891011127.0.0.1:6379[1]&gt; mset name1 lisi name2 zhangsanOK127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name&quot;3) &quot;name2&quot;4) &quot;age&quot;127.0.0.1:6379[1]&gt; get name1&quot;lisi&quot;127.0.0.1:6379[1]&gt; get name2&quot;zhangsan&quot; msetnx: 一次设置多个不存在的 key-value,返回 1 表示全部设置成功,返回 0 表示全部失败msetnx key value [key value ...] 123456789101112131415161718设置已存在的 keys 返回 0127.0.0.1:6379[1]&gt; msetnx name1 wangwu name3 xiaoer(integer) 0127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name&quot;3) &quot;name2&quot;4) &quot;age&quot;设置不存在的 keys127.0.0.1:6379[1]&gt; msetnx name3 wangwu name4 xiaoer(integer) 1127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name3&quot;3) &quot;age&quot;4) &quot;name2&quot;5) &quot;name4&quot;6) &quot;name&quot; getset: 获取原值，并设置新值getset key value 123456127.0.0.1:6379[1]&gt; get age&quot;23&quot;127.0.0.1:6379[1]&gt; getset age 110&quot;23&quot;127.0.0.1:6379[1]&gt; get age&quot;110&quot; getrange: 获取 key 对应 value 指定范围内的的字符串getrange key start end 1234127.0.0.1:6379[1]&gt; get name1&quot;lisi&quot;127.0.0.1:6379[1]&gt; getrange name1 1 3&quot;isi&quot; mget: 一次获取多个 key 对应的 value 值，不存在则返回 nil mget key [key ...] 12345678910111213141516127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name3&quot;3) &quot;age&quot;4) &quot;name2&quot;5) &quot;name4&quot;6) &quot;name&quot;7) &quot;gae&quot;127.0.0.1:6379[1]&gt; mget name name1 name2 name3 name4 name5 name61) &quot;liufei&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;wangwu&quot;5) &quot;xiaoer&quot;6) (nil)7) (nil) incr: 对 key 对应的 value 做加一操作,并返回新值 incr key 123456127.0.0.1:6379[1]&gt; get age&quot;110&quot;127.0.0.1:6379[1]&gt; incr age(integer) 111127.0.0.1:6379[1]&gt; get age&quot;111&quot; incrby: 与 incr 类似,加指定值，key不存在的时候会创建 key, 并认为 该 key 原 value=0 incrby key increment 123456789101112131415161718127.0.0.1:6379[1]&gt; get age&quot;111&quot;127.0.0.1:6379[1]&gt; incrby age 50(integer) 161127.0.0.1:6379[1]&gt; get age&quot;161&quot;127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name3&quot;3) &quot;age&quot;4) &quot;name2&quot;5) &quot;name4&quot;6) &quot;name&quot;7) &quot;gae&quot;127.0.0.1:6379[1]&gt; incrby length 180(integer) 180127.0.0.1:6379[1]&gt; get length&quot;180&quot; decr:对 key 对应的 value 做 减一操作 decr key 123456127.0.0.1:6379[1]&gt; get age&quot;161&quot;127.0.0.1:6379[1]&gt; decr age(integer) 160127.0.0.1:6379[1]&gt; get age&quot;160&quot; decrby: 对 key 对应的 value 减去指定的值 decrby key decrement 123456127.0.0.1:6379[1]&gt; get age&quot;160&quot;127.0.0.1:6379[1]&gt; decrby age 100(integer) 60127.0.0.1:6379[1]&gt; get age&quot;60&quot; append: 对 key 对应的 value 字符串追加,返回新字符串的长度 append key value 123456127.0.0.1:6379[1]&gt; get name3&quot;wangwu&quot;127.0.0.1:6379[1]&gt; append name3 test(integer) 10127.0.0.1:6379[1]&gt; get name3&quot;wangwutest&quot; strlen: 获取 key 对应 value 的长度strlen key 1234127.0.0.1:6379[1]&gt; strlen name1(integer) 4127.0.0.1:6379[1]&gt; get name1&quot;lisi&quot; 2. Hash 类型 Hash 类型介绍 Redis hash 是一个 string 类型的 filed 和value 的映射表。相较于对象的每个字段存成单个 string 类型。将一个对象存储在 hash 类型中会占用更少的内存,并且可以更方便存储整个对象 十一种类型 hset:设置 hash filed 为指定值,如果 key 不存在则先创建。key 存在则替换 hset key field value 12345678910111213141516171819202122127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name3&quot;3) &quot;name4&quot;4) &quot;name2&quot;5) &quot;age&quot;6) &quot;name&quot;7) &quot;gae&quot;8) &quot;length&quot;设置一个 user: 001 的用户 name 为 liuliu （可以将 user:001看作一个表）127.0.0.1:6379[1]&gt; hset user:001 name liuliu(integer) 1127.0.0.1:6379[1]&gt; keys *1) &quot;name1&quot;2) &quot;name3&quot;3) &quot;name4&quot;4) &quot;name2&quot;5) &quot;age&quot;6) &quot;name&quot;7) &quot;user:001&quot;8) &quot;gae&quot;9) &quot;length&quot; hget: 获取指定 field 字段的值hget key field 1234127.0.0.1:6379[1]&gt; hget user name(nil)127.0.0.1:6379[1]&gt; hget user:001 name&quot;liuliu&quot; hsetnx: 设置hash filed为指定值，如果key不存在，则先创建。如果key存在则返回0表示设置失败。hsetnx key field value 12345678127.0.0.1:6379[1]&gt; hsetnx user:001 name lisi(integer) 0127.0.0.1:6379[1]&gt; hsetnx user:001 age 19(integer) 1127.0.0.1:6379[1]&gt; hget user:001 age&quot;19&quot;127.0.0.1:6379[1]&gt; hget user:001 name&quot;liuliu&quot; hmset: 同时设置 hash 的多个 file hmset key field value [field value ...] 12127.0.0.1:6379[1]&gt; hmset user:002 name wangwu age 19OK hmget: 获取全部指定的 hash filed, 必需指定获取的 key 的名称 hmget key field [field ...] 123127.0.0.1:6379[1]&gt; hmget user:002 name age1) &quot;wangwu&quot;2) &quot;19&quot; hincrby: 对 hash filed 加上指定的值 hincrby key field increment 123456127.0.0.1:6379[1]&gt; hget user:001 age&quot;19&quot;127.0.0.1:6379[1]&gt; hincrby user:001 age 10(integer) 29127.0.0.1:6379[1]&gt; hget user:001 age&quot;29&quot; hexists: 测试制定的 filed 是否存在，返回1表示存在，返回0表示不存在 hexists key field 123456127.0.0.1:6379[1]&gt; hexists user:001 name(integer) 1127.0.0.1:6379[1]&gt; hexists user:001 age(integer) 1127.0.0.1:6379[1]&gt; hexists user:001 weight(integer) 0 hlen: 返回指定 hash 的 filed 的数量 hlen key 12127.0.0.1:6379[1]&gt; hlen user:001(integer) 2 hdel: 删除指定 hash 的 field 字段，返回1表示删除成功，0表示删除失败 hdel key field [field ...] 123456127.0.0.1:6379&gt; hget user:001 age&quot;29&quot;127.0.0.1:6379&gt; hdel user:001 age(integer) 1127.0.0.1:6379&gt; hget user:001 age(nil) hkeys: 返回 hash 的所有 filed hkeys key 123127.0.0.1:6379&gt; hkeys user:0021) &quot;name&quot;2) &quot;age&quot; hvals: 返回 hash 的所有 value hvals key 123127.0.0.1:6379&gt; hvals user:0021) &quot;wangwu&quot;2) &quot;19&quot; 3. List 类型 List 类型介绍 List 是一个链表结构,主要功能是 push、pop,获取一个范围的所有值等等，操作中 key 理解为链表的名字。 Redis 的 list 类型其实就是每个子元素都是 string类型的双向链表.我们可以通过push、pop操作链表的头部或者链表尾部添加元素，这样list既可以作为栈，又可以作为队列。 十二种方法 lpush: 在 key 对应 lisy 的头部添加字符串元素，返回 list 中元素的个数 lpush key value [value ...] 12345678127.0.0.1:6379&gt; lpush list1 &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; lpush list1 &quot; &quot; &quot;word&quot;(integer) 3127.0.0.1:6379&gt; lrange list1 0 -1 (0 -1 第一个到最后一个)1) &quot;word&quot;2) &quot; &quot;3) &quot;hello&quot; lrange: 获取 list 中的元素 lrange key start[0:第一个] stop[-1:最后一个] 1234127.0.0.1:6379&gt; lrange list1 0 -1 (0 -1 第一个到最后一个)1) &quot;word&quot;2) &quot; &quot;3) &quot;hello&quot; rpush: 在 key 对应的 list 尾部添加元素 rpush key value [value ...] 12345678127.0.0.1:6379&gt; rpush list1 &quot;abc&quot; &quot;test&quot;(integer) 5127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;hello&quot;4) &quot;abc&quot;5) &quot;test&quot; linsert: 在 key 对应 list 的特定位置前或后添加字符串 linsert key BEFORE|AFTER pivot value 123456789127.0.0.1:6379&gt; linsert list1 before abc &quot;test0&quot;(integer) 6127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;hello&quot;4) &quot;test0&quot;5) &quot;abc&quot;6) &quot;test&quot; lset: 更改 list 中指定下标的元素，返回 ok 则设置成功 lset key index value 12345678910111213141516127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;hello&quot;4) &quot;test0&quot;5) &quot;abc&quot;6) &quot;test&quot;127.0.0.1:6379&gt; lset list1 2 &quot;liuliu&quot;OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;liuliu&quot;4) &quot;test0&quot;5) &quot;abc&quot;6) &quot;test&quot; irem: 从 key 对应list 中删除 n 个和 value 相同的元素 (n&lt;0 从未不删除, n=0 全部删除，n&gt;0从头不删除) lrem key count value 123456789101112131415127.0.0.1:6379&gt; lpush list2 &quot;one&quot; &quot;two&quot; &quot;three&quot;(integer) 3127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lrem list2 1 one(integer) 1127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; lrem list2 0 three(integer) 1127.0.0.1:6379&gt; lrange list2 0 -11) &quot;two&quot; ltrim: 保留 list 中指定范围的数据，其他的批量删除 ltrim key start stop 123456789127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;one&quot;3) &quot;two&quot;127.0.0.1:6379&gt; ltrim list2 1 2OK127.0.0.1:6379&gt; lrange list2 0 -11) &quot;one&quot;2) &quot;two&quot; lpop: 从 list 的头部删除元素，并返回该元素 lpop key 1234567127.0.0.1:6379&gt; lrange list2 0 -11) &quot;one&quot;2) &quot;two&quot;127.0.0.1:6379&gt; lpop list2&quot;one&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;two&quot; rpop: 从 list 尾部删除元素，并返回该元素 rpop key 123456789127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;one&quot;3) &quot;two&quot;127.0.0.1:6379&gt; rpop list2&quot;two&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;one&quot; rpoplpush: 从第一个 list 的尾部删除元素，并添加到第二个 list 的头部 rpoplpush source destination 12345678910111213141516171819202122127.0.0.1:6379&gt; lrange list2 0 -11) &quot;three&quot;2) &quot;one&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;liuliu&quot;4) &quot;test0&quot;5) &quot;abc&quot;6) &quot;test&quot;127.0.0.1:6379&gt; rpoplpush list1 list2&quot;test&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;word&quot;2) &quot; &quot;3) &quot;liuliu&quot;4) &quot;test0&quot;5) &quot;abc&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;test&quot;2) &quot;three&quot;3) &quot;one&quot; lindex: 返回名称为 key 的 list 中index 位置的元素 &lt;===&gt; list[index] lindex key index 123456127.0.0.1:6379&gt; lrange list2 0 -11) &quot;test&quot;2) &quot;three&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lindex list2 2&quot;one&quot; llen: 返回指定 key 对应的 list 的长度 &lt;===&gt; len(list) llen key 123456127.0.0.1:6379&gt; llen list2(integer) 3127.0.0.1:6379&gt; lrange list2 0 -11) &quot;test&quot;2) &quot;three&quot;3) &quot;one&quot; 4. Sets 类型 Sets 类型介绍 Set 是一个 string 的，不允许重复。Set 是通过 hash table 实现的.添加、删除、查找的复杂度都是 O(1).对集合我们可以取并集、交集、差集 十四种方法 sadd:向 key 对应的 set 集合中添加元素,返回 1 表示添加成功,返回 0 表示失败 sadd key member [member ...] 12345127.0.0.1:6379[1]&gt; sadd myset one two(integer) 2127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot; Smembers: 查看 set 集合中的元素 smembers key 123127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot; srem: 删除 key 对应 set 集合中的指定元素，返回 1 表示删除成功，返回 0 表示删除失败 srem key member [member ...] 1234567891011127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;3) &quot;three&quot;127.0.0.1:6379[1]&gt; srem myset one(integer) 1127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; srem myset five(integer) 0 spop: 随机删除 set 中的指定个元素并返回该元素 spop key [count] 123456789127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;3) &quot;three&quot;127.0.0.1:6379[1]&gt; spop myset 21) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; smembers myset1) &quot;one&quot; sdiff: 返回给定 set 集合的差集 (以在前的 set 集合为标准) sdiff key [key ...] 12345678910127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379[1]&gt; smembers myset11) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; sdiff myset myset11) &quot;one&quot;127.0.0.1:6379[1]&gt; sdiff myset1 myset1) &quot;three&quot; sdiffstore: 返回所有给定 set 集合的差集，并将差集添加到另外一个集合中 sdiffstore destination key [key ...] 1234127.0.0.1:6379[1]&gt; sdiffstore myset3 myset1 myset(integer) 1127.0.0.1:6379[1]&gt; smembers myset31) &quot;three&quot; sinter: 返回所有给定集合的交集 sinter key [key ...] 12345678127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379[1]&gt; smembers myset11) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; sinter myset myset11) &quot;two&quot; sinterstore: 返回所有给定集合 key 的交集，并将结果存为另一个 key sinterstore destination key [key ...] 1234127.0.0.1:6379[1]&gt; sinterstore myset2 myset myset1(integer) 1127.0.0.1:6379[1]&gt; smembers myset21) &quot;two&quot; sunion: 返回所有给定集合的并集 sunion key [key ...] 12345678910127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379[1]&gt; smembers myset11) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; sunion myset myset11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; sunionstore: 返回所有给定集合的并集，并将结果存入另一个集合 sunionstore destination key [key ...] 123456127.0.0.1:6379[1]&gt; sunionstore myset4 myset myset1(integer) 3127.0.0.1:6379[1]&gt; smembers myset41) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; smove: 从第一个集合中移除元素并将该元素添加到另一个集合中 smove source destination member 1234567891011121314127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379[1]&gt; smembers myset11) &quot;two&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; smove myset myset1 one(integer) 1127.0.0.1:6379[1]&gt; smembers myset1) &quot;two&quot;127.0.0.1:6379[1]&gt; smembers myset11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; Scard: 返回 set 集合中元素的个数 llen(list) strlen(str) hlen(hash) scard key 123456127.0.0.1:6379[1]&gt; smembers myset11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379[1]&gt; scard myset1(integer) 3 sismember: 测试 member 元素是否是名称为 key 的 set 集合; 是的话返回 1 否则为 0 sismember key member 12345678127.0.0.1:6379[1]&gt; smembers myset11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379[1]&gt; sismember myset1 one(integer) 1127.0.0.1:6379[1]&gt; sismember myset1 five(integer) 0 srandmember: 随机返回 set 集合中的几个元素 ，但不删除该元素 srandmember key [count] 123456127.0.0.1:6379[1]&gt; srandmember myset1 21) &quot;one&quot;2) &quot;three&quot;127.0.0.1:6379[1]&gt; srandmember myset1 21) &quot;two&quot;2) &quot;one&quot; 5. Sorted set (zset) 类型 zset 类型介绍 Sorted set 是 set 的升级版,在 set 的基础上增加了顺序属性,在添加元素时可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解为有两列的 mysql 表，一列存 value，一列存顺序。操作 key 理解为 zset 的名字 十一种方法 ( rank: 下标索引：从0开始的; score: 分数,序号) zadd: 向有序集合 set 中添加元素并指定顺序，如果该元素已存在就更新元素顺序 zadd key [NX|XX] [CH] [INCR] score member [score member ...] 12345127.0.0.1:6379[1]&gt; zadd myzset 1 one 2 two(integer) 2127.0.0.1:6379[1]&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two zrange: 从 zset 集合中取元素 并 输出元素序号 (WITHSCORES 输出元素序号) zrange key start stop [WITHSCORES] 12345678910127.0.0.1:6379[1]&gt; zadd myzset 1 one 2 two(integer) 2127.0.0.1:6379[1]&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot; zrem: 删除 zset 集合中指定的元素 zrem key member [member ...] 12345678910127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;127.0.0.1:6379[1]&gt; zrem myzset two(integer) 1127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot; zrank: 正序方式，获取指定元素的索引下标 zrank key member 1234567127.0.0.1:6379[1]&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;127.0.0.1:6379[1]&gt; zrank myzset two(integer) 1127.0.0.1:6379[1]&gt; zrank myzset one(integer) 0 zrevrank: 逆序方式获取指定元素的索引下标, rev–reverse zrevrank key member 1234567127.0.0.1:6379[1]&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;127.0.0.1:6379[1]&gt; zrevrank myzset one(integer) 1127.0.0.1:6379[1]&gt; zrevrank myzset two(integer) 0 zincrby: 添加元素及其序号到 zset 中，或改变 zset 中元素的序号 若 zset 中已存在 元素 member，该元素的 score(序号) 增加 incrment(指定值) 否则向该集合中添加该元素,其score(序号) 的值为 increment zincrby key increment member 12345678910111213141516171819202122232425127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;127.0.0.1:6379[1]&gt; zincrby myzset 2 two&quot;2&quot;127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;127.0.0.1:6379[1]&gt; zincrby myzset 2 one&quot;3&quot;127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;two&quot;2) &quot;2&quot;3) &quot;one&quot;4) &quot;3&quot;可以有相同序号127.0.0.1:6379[1]&gt; zincrby myzset 1 two&quot;3&quot;127.0.0.1:6379[1]&gt; zrange myzset 0 -1 withscores1) &quot;one&quot;2) &quot;3&quot;3) &quot;two&quot;4) &quot;3&quot; zrangebyscore: 从 zset 集合指定范围中根据 score 顺序获取元素，可以限制获取次数 zrangebyscore key min max [WITHSCORES] [LIMIT offset count] 123456789101112131415161718127.0.0.1:6379[1]&gt; zadd myzset1 0 name 1 age 2 gender 3 like(integer) 4127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores1) &quot;name&quot;2) &quot;0&quot;3) &quot;age&quot;4) &quot;1&quot;5) &quot;gender&quot;6) &quot;2&quot;7) &quot;like&quot;8) &quot;3&quot;127.0.0.1:6379[1]&gt; zrangebyscore myzset1 1 3 withscores1) &quot;age&quot;2) &quot;1&quot;3) &quot;gender&quot;4) &quot;2&quot;5) &quot;like&quot;6) &quot;3&quot; zrevrange: 从 zset 集合中倒序 (score倒序) 获取元素 zrevrange key start stop [WITHSCORES] 12345678910111213141516171819202122232425127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores1) &quot;name&quot;2) &quot;0&quot;3) &quot;age&quot;4) &quot;1&quot;5) &quot;gender&quot;6) &quot;2&quot;7) &quot;like&quot;8) &quot;3&quot;127.0.0.1:6379[1]&gt; zrevrange myzset1 0 -1 withscores1) &quot;like&quot;2) &quot;3&quot;3) &quot;gender&quot;4) &quot;2&quot;5) &quot;age&quot;6) &quot;1&quot;7) &quot;name&quot;8) &quot;0&quot;127.0.0.1:6379[1]&gt; zrevrange myzset1 1 3 withscores1) &quot;gender&quot;2) &quot;2&quot;3) &quot;age&quot;4) &quot;1&quot;5) &quot;name&quot;6) &quot;0&quot; zcount: 返回集合中 score 在给定区间的数量 zcount key min max 123456789101112131415127.0.0.1:6379[1]&gt; zadd myzset1 3 follow(integer) 1127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores 1) &quot;name&quot; 2) &quot;0&quot; 3) &quot;age&quot; 4) &quot;1&quot; 5) &quot;gender&quot; 6) &quot;2&quot; 7) &quot;follow&quot; 8) &quot;3&quot; 9) &quot;like&quot;10) &quot;3&quot;127.0.0.1:6379[1]&gt; zcount myzset1 2 3(integer) 3 zcard: 返回 zset 集合中所有元素个数 zcard key 12345678910111213127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores 1) &quot;name&quot; 2) &quot;0&quot; 3) &quot;age&quot; 4) &quot;1&quot; 5) &quot;gender&quot; 6) &quot;2&quot; 7) &quot;follow&quot; 8) &quot;3&quot; 9) &quot;like&quot;10) &quot;3&quot;127.0.0.1:6379[1]&gt; zcard myzset1(integer) 5 zremrangebyrank: 删除集合中排名 (下标) 在给定区间的元素 zremrangebyrank key start stop 1234567891011127.0.0.1:6379[1]&gt; zremrangebyrank myzset1 3 3(integer) 1127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores1) &quot;name&quot;2) &quot;0&quot;3) &quot;age&quot;4) &quot;1&quot;5) &quot;gender&quot;6) &quot;2&quot;7) &quot;like&quot;8) &quot;3&quot; zremrangebyscore: 删除集合中顺序 (score 值排序)在给定区间的元素 zremrangebyscore key min max 1234567891011121314127.0.0.1:6379[1]&gt; zrange myzset1 0 -1 withscores1) &quot;name&quot;2) &quot;0&quot;3) &quot;age&quot;4) &quot;1&quot;5) &quot;gender&quot;6) &quot;2&quot;7) &quot;like&quot;8) &quot;3&quot;127.0.0.1:6379[1]&gt; zremrangebyscore myzset1 2 3(integer) 2127.0.0.1:6379[1]&gt; zrange myzset1 0 -11) &quot;name&quot;2) &quot;age&quot;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Windows中pyspider安装以及错误处理","slug":"Windows中pyspider安装以及错误处理","date":"2020-12-24T07:26:08.000Z","updated":"2020-12-24T07:29:21.925Z","comments":true,"path":"2020/12/24/windows-zhong-pyspider-an-zhuang-yi-ji-cuo-wu-chu-li/","link":"","permalink":"http://yoursite.com/2020/12/24/windows-zhong-pyspider-an-zhuang-yi-ji-cuo-wu-chu-li/","excerpt":"","text":"Windows中Pyspider安装以及错误处理安装 pyspider 过程中出现错误 ERROR: Command errored out with exit status 10: python setup.py egg_info Check the logs for full command output. 报错信息 观察发现 pycurl 模块下载出错 导致无法继续下载 单独安装 pycurl 下载地址 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pycurl 一定要单独下载后本地安装对应版本 pip 下载本地文件 搜索 pycurl 下载 合适的版本 一定要与 python 版本符合 版本不符报错 查看 python 版本 pycurl : 名称 pycurl‑7.43.0.4‑cp37‑cp37m‑win_amd64.whl, cp 为 对应python版本 async 错误 错误图片 错误原因 python3 中，已经将async 设置为关键字，而pyspider 版本更新缓慢并没有在此处修改，所以导致pyspider 不能正常启动。 修改 pyspider 源码将 async 改为其它非关键字 (只修改 async 关键字的，其他含有这些字符的不需要修改) 需要修改的源码所在位置 修改源码 Wsgidav 错误 错误图片 错误原因 WsgiDav 新版本 已将更改源码 &#39;domaincontroller&#39;: NeedAuthController(app), 为 &#39;http_authenticator&#39;: {&#39;HTTPAuthenticator&#39;: NeedAuthController(app),}, 修改源码 修改 werkzeug.wsgi 错误 错误图片 错误原因 werkzeug 1.0.0 版本及以上，没有DispatcherMiddleware方法 Pyspider 需要 werkzeug库版本在 0.15–1.0(不允许为1.0) 重新下载 werkzeug 版本 pip install --upgrade werkzeug==0.16.1 io_Loop 错误 报错 : TypeError: initialize() got an unexpected keyword argument ‘io_loop’ 错误原因 : python环境中，默认tornado版本是最新的5.0，在4.0之后就废弃了io_loop参数 重新更新 tornado 版本 : pip install --upgrade tornado==4.5.1 *成功启动 * pyspider all 启动成功","categories":[],"tags":[{"name":"pyspider","slug":"pyspider","permalink":"http://yoursite.com/tags/pyspider/"}]},{"title":"Python 的垃圾回收机制","slug":"Python-的垃圾回收机制","date":"2020-12-18T09:34:23.000Z","updated":"2020-12-18T09:34:54.441Z","comments":true,"path":"2020/12/18/python-de-la-ji-hui-shou-ji-zhi/","link":"","permalink":"http://yoursite.com/2020/12/18/python-de-la-ji-hui-shou-ji-zhi/","excerpt":"","text":"Python 的内存回收机制 垃圾回收机制，就是我们常说的GC(Garbage collection)。高级编程语言，如java，c#等，都采用了垃圾回收机制，减轻程序员对于内存的处理压力。但这并不代表内存泄漏等问题可以被完全杜绝 就python而言，主要采用的是常见的引用计数机制，同时结合标记-清除和分代收集两种机制。 引用计数 python中一切皆对象，每一个Python对象都有一个引用计数器，用于记录有多少其他对象指向(引用)这个对象。那什么时候引用计数增加，什么时候引用计数减少呢？ 引用计数增加 对象被创建：x = “test” 另外的别名被创建：y = x 对象被作为参数传递给函数（新的本地引用）: foobar(x) 对象成为容器对象的一个元素：myList = [x, ‘xyz’] 引用计数减少 一个本地引用离开了其作用范围。如fooc()函数结束时，func函数中的局部变量（全局变量不会） 对象的别名被显式销毁：del y 对象的一个别名被赋值给其他对象：x = 123 对象被从一个窗口对象中移除：myList.remove(x) 窗口对象本身被销毁：del myList 当引用计数变为0时，会回收对象释放内存空间。引用计数法有很明显的优点： 实现简单 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 非常显著的的缺点： 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。 为解决上面2个问题，python又引入了两种GC机制 标记-清除 此GC机制，主要是为了解决循环引用问题。 标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段： 第一阶段是标记阶段，GC会把所有的『活动对象』打上标记， 第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？ 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器 标记清除算法作为python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。 分代回收 分代回收是一种以空间换时间的操作方式， Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象。","categories":[],"tags":[{"name":"Python 面试","slug":"Python-面试","permalink":"http://yoursite.com/tags/Python-%E9%9D%A2%E8%AF%95/"}]},{"title":"HeroKu 搭建学习使用的 V2ray","slug":"HeroKu-搭建学习使用的-V2ray","date":"2020-10-17T06:34:04.000Z","updated":"2020-10-17T06:39:31.564Z","comments":true,"path":"2020/10/17/heroku-da-jian-xue-xi-shi-yong-de-v2ray/","link":"","permalink":"http://yoursite.com/2020/10/17/heroku-da-jian-xue-xi-shi-yong-de-v2ray/","excerpt":"","text":"HeroKu 搭建学习使用 V2ray WebsocketHeroKu 介绍 以及 涉及链接 Heroku是一个支持多种编程语言的云平台即服务。在2010年被Salesforce.com收购。 HeroKu 另外提供了免费版本用于小开发者操作.今天我们便是使用免费版本进行 V2ray 搭建. HeroKu 网速较慢,但是足够用于学习搜索,不适合做为翻墙看视频之类的,希望合理使用,方便学习 HeroKu 地址 https://dashboard.heroku.com/login V2Ray Heroku GitHub 链接 V2RayN 客户端下载链接 HeroKu 注册及登录注册 HeroKu 是国外网站国内 不太稳定,最好提前准备好 翻墙、google邮箱、雅虎邮箱… 注册流程 登录 输入账号名密码 一步搭建 登陆测试成功后,从 V2Ray Heroku GitHub 链接 内跳转到创建 APP 页面 在 创建 App 页面进行配置 App 信息 创建完成后 点击 Deploy App 等待下方创建完成后点击 Manage App 在管理页面找到 settings 设置页面,向下找到 Domains 记下自己的 App 链接 V2rayN 设置 下载 V2RayN 客户端,安装完成后进行设置 设置流程, 打开 V2rayN 添加服务器 配置服务器, 地址为在 settings 下 记录的 Domains URL, 端口为 443, 用户 ID 为最开始记录的 UUID, 传输协议为 vs, 底层传输安全为 tls 设为活动服务器并通过 ping 测速 改变链接为直连模式 使用时通常我们并不需要全局代理,仅仅是在使用网页时对代理有需求,那么我们可以通过浏览器插件与 V2ray 设置实现 在浏览器的 应用商店 内可以下载 SwitchyOmega ,对其进行配置 (火狐可以直接下载配置 ， 谷歌浏览器需要打开全局代理下载后配置)","categories":[],"tags":[{"name":"HeroKu Server","slug":"HeroKu-Server","permalink":"http://yoursite.com/tags/HeroKu-Server/"}]},{"title":"Git_pull_error","slug":"Git-pull-error","date":"2020-10-10T10:52:52.000Z","updated":"2020-10-10T10:54:01.201Z","comments":true,"path":"2020/10/10/git-pull-error/","link":"","permalink":"http://yoursite.com/2020/10/10/git-pull-error/","excerpt":"","text":"Git pull 文件时出现错误错误报告 : “error: RPC failed; curl 18 transfer closed with outstanding read data remaining”1234error: RPC failed; curl 18 transfer closed with outstanding read data remainingfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 错误原因1.网络下载速度太慢 错误应对 : 修改下载速度 12git config --global http.lowSpeedLimit 0git config --global http.lowSpeedTime 999999 2. 缓存太小下载文件过大导致缓存溢出 查看缓冲区大小,单位为 b 1git config --list 错误应对 : 全局修改 postBuffer 的默认大小,增加缓冲 1git config --global http.postBuffer 524288000","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git-commands-02","slug":"Git-commands-02","date":"2020-09-05T12:29:31.000Z","updated":"2020-09-05T12:30:02.056Z","comments":true,"path":"2020/09/05/git-commands-02/","link":"","permalink":"http://yoursite.com/2020/09/05/git-commands-02/","excerpt":"","text":"Git 常用命令及使用情况 2Git 常用命令 tag 常用于发布版本 默认在 HEAD 上创建一个标签 1$ git tag tag_name 制定一个 commit id 创建一个标签 1$ git tag tag_name commit_id 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字 1$ git tag -a tag_name -m &quot;说明文字&quot; 查看所有标签 (标签都是按照字母排序的) 1$ git tag 查看单个标签具体信息 1$ git show &lt;tag_name&gt; 推送一个本地标签 1$ git push origin &lt;tag_name&gt; 推送全部未推送过的本地标签 1$ git push origin --tags 删除本地标签 (由于创建的标签只能存储在本地，不会自动推送至远程，所以错误的标签可以在本地安全的删除) 1$ git tag -d tag_name 删除一个远程标签 (先删除本地标签，再删除远程标签) 1$ git push origin :refs&#x2F;tags&#x2F;&lt;tag_name&gt; 删除文件 rm 删除暂存区和工作区的文件 1$ git rm filename 只删除暂存区文件，不删除工作区文件 (又称为 取消追踪文件，git 不再提交此文件，远程仓库也删除此文件) 1$ git rm --cached filename 版本切换 &amp; 重设 &amp; 撤销 详解 checkout : 可以撤销工作区的文件, 可以作用于 commit 或者文件 恢复暂存区文件到工作区 1$ git checkout &lt;filename&gt; 恢复暂存区的所有文件到工作区 1$ git checkout . 回滚到最近的的一次提交，如果修改某些文件后，没有提交到暂存区，此时回滚是回到上一次提交，如果已经提交到仓库，这个回滚无效，只能回滚到提交的版本 12$ git checkout HEAD$ git checkout HEAD --filename 回滚到最近一次提交的上一个版本 1$ git checkout HEAD^ 回滚到最近一次提交的上两个版本 1$ git checkout HEAD^^ 切换分支 1$ git checkout branchname 切换到某个指定的 commit 版本 1$ git checkout &lt;commit_id&gt; 切换到指定的 tag 1$ git checkout &lt;tag&gt; reset : 可以撤销工作区/暂存区的文件, 可以作用于 commit 或者文件 当你用 reset 回滚到了某个版本后，那么在下一次 git 提交时，之前该版本后面的版本会被作为垃圾删掉. 当我们回退到一个旧版本后，此时再用 git log 查看提交记录，会发现之前的新版本记录没有了。如果第二天，你又想恢复到新版本怎么办？找不到新版本的 commit_id 怎么办？ 用 git reflog 查看历史命令，这样就可以看到之前新版本的 commit_id ，然后 git reset –hard commit_id 就可以回到之前的新版本代码 git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]将当前的分支重设(reset)到指定的 或者 HEAD (默认，如果不显示指定 ，默认是 HEAD ，即最新的一次提交)，并且根据 [mode] 有可能更新索引和工作目录。mode 的取值可以是 hard、soft、mixed、merged、keep . 从暂存区撤销特定文件,但不改变工作区,会取消这个文件的暂存,而不覆盖任何更改 1$ git reset &lt;filename&gt; 重置暂存区的最近一次提交，但工作区文件不变 123$ git reset &lt;&#x3D;&#x3D;&gt;$ git reset HEAD (默认) 重置工作区与暂存区，回退到最近一次提交的版本内容 1$ git reset --hard 重置暂存区与工作区,回退到最近一次提交的上一个版本 1$ git reset --hard HEAD^ mixed : 将当前分支的指针指向为指定的 commit (该提交之后的提交都会被移除), 同时重置暂存区,但工作区不变 123$ git reset &lt;commit&gt;&lt;&#x3D;&#x3D;&gt;$ git reset --mixed &lt;commit&gt; soft : 将当前分支的指针指向为指定的 commit (该提交之后的提交都会被移除), 但保持暂存区和工作区不变 1$ git reset --soft &lt;commit&gt; hard : 将当前分支的指针指向为指定的 commit (该提交之后的提交都会被移除), 同时重置暂存区、工作区 1$ git reset --hard &lt;commit&gt; revert : 只能作用于 commit,撤销某个已经提交的快照（和 reset 重置到某个指定版本不一样）」。它是在提交记录最后面加上一个撤销了更改的新提交，而不是从项目历史中移除这个提交，这避免了 Git 丢失项目历史 生成一个撤销最近的一次提交的新提交 1$ git revert HEAD 生成一个撤销最近一次提交的上一次提交的新提交 1$ git revert HEAD^ 生成一个撤销最近一次提交的上两次提交的新提交 1$ git revert HEAD^^ 生成一个撤销最近一次提交的上 n 次提交的新提交 1$ git revert HEAD~num 生成一个撤销指定提交版本的新提交 1$ git revert &lt;commit_id&gt; 生成一个撤销指定提交版本的新提交，执行时不打开默认编辑器，直接使用 Git 自动生成的提交信息 1$ git revert &lt;commit_id&gt; --no-edit cherry-pick : 将指定的提交 commit 应用于当前分支 (可用于恢复不小心撤销 (revert/reset) 的提交)123$ git cherry-pick &lt;commit_id&gt;$ git cherry-pick &lt;commit_id&gt; &lt;commit_id&gt;$ git cherry-pick &lt;commit_id&gt;^..&lt;commit_id&gt;","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git-command","slug":"Git-command","date":"2020-08-29T02:57:07.000Z","updated":"2020-08-29T02:57:25.097Z","comments":true,"path":"2020/08/29/git-command/","link":"","permalink":"http://yoursite.com/2020/08/29/git-command/","excerpt":"","text":"Git 常用命令以及使用情况1. 配置 Git 配置全局用户 12$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;git账号&quot; 配置别名 (非必要) 12345$ git config --global co checkout$ git config --global ss status$ git config --global cm commit$ git config --global br branch$ git config --global rg reflog 删除全局配置 12$ git config --global --unset (别名配置)$ git config --global --unset user.xxx 2. 查看 Git 信息 查看系统配置 1$ git config --list 查看用户配置 1$ cat ~&#x2F;.gitconfig 查看当前项目的 git 配置 1$ cat .git&#x2F;config 查看暂存区文件 1$ git ls-files 查看本地 git 命令历史(显示的是一个 HEAD 指向发生改变的时间列表，在切换分支、git commit 提交、git reset 撤销 commit时 HEAD 指向改变，可以使用 git reset --head 02b5293 恢复在 git checkout -- &lt;filename&gt; 撤销、git stash 存储文件时 HEAD 不会改变，这些修改也没有被提交，不可恢复git reflog 会被定期清理) 1$ git reflog 查看所有 git 命令 1$ git --help -a 查看当前 HERD 指向 1$ cat .git&#x2F;HEAD git 查看多页文件时, D 向下翻一行, F 向下翻页, B 向上翻页, Q 退出 git 查看提交历史 git 中一条分支就是一个指针，新建一条分支就是基于当前指针新建一个指针 切换分支 : 将HEAD指向某条分支 (指针) 切换至某个 commit : 将 HEAD 指向某个 commit git log --graph 图形化符号含义 * : 一次 commit | : 分支前进 / : 分叉 \\ : 分之合入 |/ : 新分支12345678910111213$ git log --online --&gt; 将 commit 记录 逐行显示 --grep&#x3D;&quot;关键字&quot; --&gt; 查找 commit 提交注释 中与关键字有关的记录 --graph --&gt; 记录图形化显示 --all --&gt; 将所有记录详细显示出来 --author &quot;username&quot; --&gt; 查找此作者的提交记录 --reverse --&gt; 将 commit 提交记录倒序显示 -num --&gt; 显示最近 num 次提交 git log -10 -p --&gt; 显示每次提交引入的差异 (按 补丁 的格式输出) --before &#x3D; 1 day&#x2F;1 week&#x2F;1 &quot;2020-08-29&quot; --&gt; 查找规定时间之前的记录 (一天， 一周) --after &#x3D; &quot;2020-8-23&quot; --&gt; 查找规定时间之后的操作 --stat --&gt; 显示每次更新的文件修改信息统计,会列出具体文件列表 --abbrev-commit --&gt; 仅显示 SHA-1 的前几个字符，而非所有 40 个字符 --pretty&#x3D;format:&quot;xxx&quot; --&gt; 可以定制要显示的记录格式 3. Git 常用命令 查看工作区和暂存区的状态 1$ git status add 将工作区的文件提交到暂存区 添加指定文件到暂存区 (追踪新增的指定文件) 1$ git add [file1] [file2] ... 添加指定文件到暂存区，包括子目录 1$ git add [dir] 添加当前目录的所有文件到暂存区（追踪所有新增的文件） 123$ git add . &lt;&#x3D;&#x3D;&gt;$ git add -a 删除工作区/暂存区的文件 1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached [file] 改名工作区/暂存区的文件 1git mv [old_filename] [new_filename] commit 将暂存区文件提交到本地仓库 将暂存区的文件提交到本地仓库并添加提交说明 1$ git commit -m &quot;本次提交说明&quot; 跳过验证继续提交 12$ git commit --no-verify$ git commit -n add 和 commit 合并，便捷写法 (未追踪的文件无法提交) 1$ git commit -am &quot;本次提交说明&quot; 编辑器会弹出上一次提交的信息，可以在这里修改提交信息 (既可以修改上次提交的文件内容，也可以修改上次提交的说明)如果暂存区有内容，这个新的 commit 会把任何修改内容和上一个 commit 的内容结合起来。如果暂存区没有内容，那么这个操作就只会把上次的 commit 消息重写一遍。[永远不要修复一个已经推送到公共仓库中的提交，会拒绝推送到仓库] 1$ git commit --amend 修复提交，同时修改提交信息 1$ git commit --amend -m &quot;本次提交说明&quot; 加入 –no-edit 标记会修复提交但不修改提交信息，编辑器不会弹出上一次提交的信息 1git commit --amend --no-edit 将本地分支与远程分支关联 1$ git push -u origin BranchName 将本地仓库文件推送到远程分支,如果远程仓库没有这个分支，会新建一个同名远程分支，省略分支名代表两者同名 (分支推送顺序 [&lt;来源地&gt; : &lt;目的地&gt;]) 12$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;$ git push origin BranchName 省略本地分支名，表示删除指定的远程分支 &lt;==&gt; 推送一个空的本地分支到远程分支 123$ git push origin :master &lt;&#x3D;&#x3D;&gt;$ git push origin --delete master 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机 1$ git push --all origin 建立当前分支和远程分支的追踪关系 (如果当前分支与远程分支之间存在追踪关系, 推送时则可以省略分支和 -u) 1234# 不存在追踪$ git push -u origin master # 存在 追踪$ git push 如果远程主机的版本比本地版本更新，推送时 Git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 –-force 选项 (尽量避免使用) 1$ git push --force origin | git push -f origin 拉取远程分支的代码到本地镜像仓库 1$ git pull 拉取并合并项目其他人的一个分支 &lt;==&gt; fetch + merge 1234$ git pull origin BranchName &lt;&#x3D;&#x3D;&gt;$ git fetch origin BranchName$ git merge origin&#x2F;BranchName 合并分支 默认 fast-forward ，HEAD 指针直接指向被合并的分支在当前分支的提交历史中添加进被合并分支的提交历史 1$ git merge BranchName 禁止快进式合并[生成一个新的提交]，会让当前分支的提交历史不会那么乱 1$ git merge --no-ff squash：[不会生成新的提交]，会将被合并分支多次提交的内容直接存到工作区和暂存区，由开发者手动去提交，这样当前分支最终只会多出一条提交记录，不会掺杂被合并分支的提交历史 1$ git merge --squash 查看本地分支 123$ git branch &lt;&#x3D;&#x3D;&gt; $ git branch -l 查看本地分支对应的远程分支 1$ git branch -vv 查看远程分支 1$ git branch -r 查看所有分支 (包括本地分支与远程分支) 1$ git branch -a 查看所有分支包括最新的提交信息 1$ git branch -av 新建分支，在别的分支下新建一个分支，新分支会复制当前分支的内容，(注意：如果当前分支有修改，但是没有提交到仓库，此时修改的内容是不会被复制到新分支的) 1$ git branch BranchName 切换分支 (切换分支时，本地工作区，仓库都会相应切换到对应分支的内容) 1$ git checkout BranchName 创建并切换到新建分支 1$ git checkout -b BranchName 基于 master 分支新建一个分支，并切换到该分支 1$ git checkout -b BranchName master 删除本地分支，会阻止删除包含未合并并更改的分支 1$ git branch -d BranchName 强制删除一个本地分支，即使有未合并并更改的分支 1$ git branch -D BranchName 修改当前分支名 1$ git branch -m BranchName 临时将工作区文件修改保存至堆栈，用于后续恢复当前工作区内容 (以便于新建一个分支进行操作而不被当前分支影响)如果文件没有提交到暂存区[（使用 git add . 追踪新的文件）]，使用该命令会提示 No local changes to save ，无法将修改保存到堆栈中 将所有未提交的修改（提交到暂存区）保存至堆栈中 1$ git stash 给本次存储加个备注，以防时间久了忘了 1$ git status save &quot;临时存储&quot; 查看存储记录 1$ git stash list 在 Windows 上和 PowerShell 中，需要加双引号 在 Windows 上和 PowerShell 中，需要加双引号 1$ git stash apply &quot;stash@&#123;index&#125;&quot; 恢复的同时把 stash 记录也删了 1$ git stash pop &quot;stash@&#123;index&#125;&quot; 删除 stash 记录 1$ git stash drop &quot;stash@&#123;index&#125;&quot; 删除所有存储的进度 1$ git stash clear 你接到一个修复紧急 bug 的任务时候，一般都是先创建一个新的 bug 分支来修复它，然后合并，最后删除。但是，如果当前你正在开发功能中，短时间还无法完成，无法直接提交到仓库，这时候可以先把当前工作区的内容 git stash 一下，然后去修复 bug，修复后，再 git stash pop，恢复之前的工作内容。 diff 查看工作区和暂存区单个文件的对比 1$ git diff filename 查看工作区和暂存区所有文件的对比 1$ git diff 查看工作区和暂存区所有文件的对比，并显示出所有有差异的文件列表 1234$ git diff --stat# 1.你修改了某个文件，但是没有提交到暂存区，这时候会有对比的内容# 一旦提交到暂存区，就不会有对比的内容(因为暂存区已经更新)# 2.如果你新建了一个文件，但是没有提交到暂存区，这时候 diff 是没有结果的 查看远程分支和本地分支的对比 1$ git diff origin&#x2F;branchname..branchname 查看两个本地分支所有的对比 1$ git diff branchname..branchname remote 查看所有远程主机 1$ git remote 查看关联的远程仓库的详细信息 1$ git remote -v 删除远程仓库的 “关联” 1$ git remote rm ProjectName 设置远程仓库的 “关联” 1$ git remote set-url origin &lt;newurl&gt;","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git-reset使用掉坑","slug":"Git-reset使用掉坑","date":"2020-08-27T02:11:21.000Z","updated":"2020-08-27T02:14:46.192Z","comments":true,"path":"2020/08/27/git-reset-shi-yong-diao-keng/","link":"","permalink":"http://yoursite.com/2020/08/27/git-reset-shi-yong-diao-keng/","excerpt":"","text":"Git 的一次掉坑经历 (深坑) 2020.08.24 作死开始早九点，最近发现 git 跟 pycharm 混用让自己 git 的学习过程出了点问题，尝试多次无果后，决定去网上求助大神。 愚蠢作死出于对网友们的信任，找到一片看起来靠谱的博客后果断一遍无脑操作，复制粘贴，在 回车 的时候 看到 git reset --hard ，顿觉大事不妙 (由于之前使用 git 最近一次是在去年学习时使用，疫情期间，全程看书，丝毫没有将代码 git add 与 git commit 的觉悟) “皇上”驾崩了没了没了，全都没了。回过神的自己看着近一年 兢兢业业 “耕种” 的结果，全都丢了，真删了个干净，空空如也。 慌了当时自己告诉自己镇静，网上慢慢找恢复办法，虽然告诉自己别慌，自己也觉得自己没慌，但事后就后悔，非常后悔，当时绝对是慌了，尽管对网上的办法保持警惕，但还是胡乱操作了许多，更乱了尝试了回退，但是最近一次 git commit 太过于遥远，仅恢复了 30% 文件，心还在滴血 (几千个代码文件、几十个笔记文件啊) 一篇有用的 Blog : https://www.cnblogs.com/hope-markup/p/6683522.html绝望的时候，找到了这篇博客 (救我于水火) , git fsck --lost-found 这个命令 执行后在 .git/lost-found/other 中找到了大堆的 文件 (这里面包含了所有的没有被commit的文件), 根据博客作者所说 find .git/objects -type f | xargs ls -lt | sed 60q 这个命令，你就可以找到最近被你add到本地仓库的 60个文件 (可以自定义查看多少个) 开始恢复 (悲惨的)由于我丢失的文件太多，看着 other 文件夹下生成那浩浩荡荡 六七千个 文件 (文件名是 hash 值，由于 git reset 时将索引树一起重置了，没办法根据索引定义文件名)，完全不知道哪个是哪个尽管当时内心十分清楚的告诉自己写个脚本，写个脚本就可以快速恢复，但是对于自己不清楚的文件内容，自己毫无头绪 (一定要把里面悬空文件多复制几份，然后对复制后的文件进行修改，保证损失环境的 无变化) 一点点寻找文件二进制可以识别出大部分无意义的文件，于是我拿出了做搁置很久的 010 Editor 查看几个后发现太过缓慢；灵光一现然后打开 VS Code 下载插件 查看 16进制。这样一个个文件看过去，估计自己看完眼睛也已经废掉了 ，于是开始总结经验 发现经验经过看了几百个文件后，了解到 other 文件夹下文件类型大概分为 Png (89504E47)、Jpg (FFD8FF)、txt (txt文件十六进制没有固定格式)、Gif (47494638)、zip (504B0304) …好吧略有点多，试了试写以十六进制脚本查看用来区分，(自己太菜，写出来对于各种txt文件,md文件, 无法有效区分) 改变思路通过直接 二进制读取 文件将文件名 与 二进制读取每个文件前几个 二进制数据 发现各种文件后缀的二进制文件，鉴于里面笔记较多，决定半手动处理 (庆幸自己学习的时候有良好的代码习惯，代码文件读取出来前几个字节文件基本相同，节省大量区分时间) 12345678910111213141516171819import osimport shutil def check_file(file_path): file_names = os.listdir(file_path) for file_name in file_names: with open(os.path.join(file_path, file_name), \"rb\") as f: date = f.readline(10) f.close() # if str(date) == str(b' b'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF''): # os.remove(os.path.join(file_path, file_name)) # os.rename(os.path.join(file_path, file_name), os.path.join(file_path, file_name) + \".jpg\") # shutil.move(os.path.join(file_path, file_name) + \".jpg\", \"E://save/png\") print(file_name, date)check_file(\"e:\\\\新建文件夹\\\\other\") 分类，修复通过以上代码将 Png、Jpg、Gif 文件统统删除，直接少了一半无用文件，舒爽通过对 exe 文件重命名, 并且 移动到准备好的分类的各种文件下，方便统一整理对其他不同种类文件添加后缀，移动到文件夹对于剩余所有文件放入一个文件夹删除无用的 图片文件、压缩文件、exe 文件等 最后剩余的有用的根据自己定义的写代码的规范，将不同学习阶段的代码区分，按顺序统一命名，将笔记提取出来，按内容重新整理 搞完收工真的心塞，以后对于网上的代码一定要先搞懂作用再使用; 培养好自己良好的写代码规范;合理使用 git最后希望大家都不要掉到这个坑里，一定要记得修改任何东西之前做好保存，留好备份","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Getting-start-with-Git","slug":"Getting-start-with-Git","date":"2020-08-22T06:11:03.000Z","updated":"2020-08-22T06:20:40.491Z","comments":true,"path":"2020/08/22/getting-start-with-git/","link":"","permalink":"http://yoursite.com/2020/08/22/getting-start-with-git/","excerpt":"","text":"Git 入门在 Git 中设置用户名 (Windows 系统)Git 使用用户名把提交与身份相关联，Git 用户名 不等于 GitHub 用户名 git config 参数 默认对当前目录下仓库进行操作, 配置保存在 “此目录路径/目录名/.git/config“ –global : 全局参数, 使用这个参数配置此计算机所有Git仓库的内容，也可以在仓库单独指定用户名和密码, 配置保存在 “C:\\Users\\用户名.gitconfig“ –system : 必需在命令前使用 sudo, 针对此系统下所有用户 –list : 显示当前 Git 配置 -e [–global] : 编辑当前仓库下 (–global 全局) Git 的配置文件，当前目录下没有配置文件，返回 fatal: not in a git directory 错误 配置优先级 当前仓库配置 &gt; 本地全局仓库配置 &gt; 所有用户仓库配置 为计算机上的每个仓库设置 Git 用户名 打开 Git Bash 设置 Git 用户名 和 Email (Git Email 与 GitHub Email 一致时才被认为是同一用户，否则为另一用户创建了仓库进行操作) 12$ git config --global user.name &quot;Git 用户名&quot;$ git config --global user.email &quot;Git Email&quot; 确认/查看自己的 Git 用户名 12$ git config --global user.name demon_liu 为一个仓库设置 Git 用户名 打开 Git Bash 将当前工作目录更改为您想要在其中配置与 Git 提交关联的名称的本地仓库. 设置 Git 用户名 和 Email 12$ git config user.name &quot;Git 用户名&quot;$ git config user.email &quot;Git Email&quot; 确认/查看此仓库自己的 Git 用户名 12$ git config user.name demon_liu 连接 GitHub关联 ssh-key 通过 SSH 加密传输 打开 Git Bash , 以下命令创建 SSH Key， 1$ ssh-keygen -t rsa -C &quot;Git Email&quot; C://User/用户名/.ssh 下生成两个文件 id_rsa : 私钥，保密 id_rsa.pub : 公钥 在 GitHub –&gt; Setting –&gt; SSH and GPG Keys 页面 选择 “New SSH key” 填上你的 标题 在 Key 文本框粘贴 公钥 (id_rsa.pub) 的内容 测试 ssh key 是否成功。 12$ ssh -T git@github.com Hi 用户名! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 创建 Git 代码库1. 在当前目录新建一个 Git 代码库, 并初始化1$ git init 2. 新建一个目录作为 Git 代码库 ，并初始化1$ git init [目录名] 将本地分支的更新，推送到远程主机 [git push] 参数 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 远程命令 分支名称 新分支名称 本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。//原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：https://www.yiibai.com/git/git_push.html 1$ git push origin master 删除指定的远程分支 (省略本地分支名) 123$ git push origin :master&lt;&#x3D;&#x3D;&gt;$ git push orgin --delete master 克隆仓库 git clone 操作命令 1$ git clone [仓库 SSH &#x2F; HTTPs] 克隆过程 在 此路径下 创建 被克隆文件夹名的文件夹 初始化此文件夹为 Git 仓库 创建名为 origin 的远程仓库，指向用于克隆的 URL 将所有的仓库文件和提交下载到那里 检出默认分支（通常称为 master） 获取远程仓库更改,从另一个存储库下载对象和引用 git fetch 相当于是从远程获取最新版本到本地，不会自动合并 从远程的origin的master主分支下载最新的版本到origin/master分支上 1$ git fetch origin master 进行合并 1$ git merge origin&#x2F;master 更新本地工作 两步更新 获取远程仓库更新 1$ gitfetch &lt;远端名称&gt; 将在线更新与您的本地工作进行合并 1$ git merge &lt;远端名称&gt;&#x2F;&lt;分支名称&gt; 一步: 获取在线更新并将其与您的本地工作进行合并 1$ git pull &lt;远端名称&gt; &lt;分支名称&gt; git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]] 取回远程主机某个分支的更新，再与本地的指定分支合并 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 取回origin主机的next分支，与本地的master分支合并 1$ git pull origin next:master 分支1. git branch 列出所有远程分支 1$ git branch -r 列出所有本地分支 1$ git branch 列出所有本地分支和远程分支 1$ git branch -a 新建一个分支 [-b 新建的同时切换到新建分支] 1$ git branch [-b] &lt;分支名称&gt; 删除分支 1$ git branch -d &lt;分支名称&gt; 删除远程分支 12$ git push origin --delete &lt;分支名称&gt;$ git branch -dr &lt;remote&#x2F;branch&gt; 2. 切换分支 git checkout 切换到上一个分支 1$ git checkout - 切换到指定分支，并更新工作区 1$ git checkout &lt;分支名称&gt; Git 的 基本操作 (增、删、改、提、查)1. 增 git add &lt;path&gt; 将文件内容添加到索引(将修改添加到暂存区) 添加文件/文件目录到指定暂存区 1$ git add [file]&#x2F;[dir] 添加当前目录下所有文件到暂存区 1$ git add . 2. 删 git rm &lt;path&gt; 从工作区和索引中删除文件,git rm 来删除文件，同时还会将这个删除操作记录下来；而使用 rm 来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除//原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：https://www.yiibai.com/git/git_rm.html 删除文件 1$ git rm [filename] 删除文件夹 1$ git rm -r [dirname] 3. 改 git mv 移动或重命名文件，目录或符号链接 重命名文件 1$ git mv [sourcefile] [newfile] 移动文件到新目录 1$ git mv [sourcefile] [newdir] 4. 提交代码 git commint 将更改记录(提交)到存储库. 将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中. 将文件暂存到仓库 1$ git commit -m [message] 提交暂存文件到仓库 1$ git commit [filename] [] -m [message] 提交工作区所有改变到仓库 1$ git commit -a 提交时显示改变 1$ git commit -f 5. 查 查看所有有改变的文件 1$ git status 显示所有分支的历史版本 1$ git log 显示commit历史，以及每次commit发生变更的文件 1$ git log --stat 显示暂存区和工作区的差异 1$ git diff","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"pyechart_local_service","slug":"pyechart-local-service","date":"2020-08-22T01:19:50.000Z","updated":"2020-08-22T01:20:29.099Z","comments":true,"path":"2020/08/22/pyechart-local-service/","link":"","permalink":"http://yoursite.com/2020/08/22/pyechart-local-service/","excerpt":"","text":"pyecharts_assets全部来自于官方文档，主要用于方便自己查找 解决 pyecharts 在生成 Html 时由于网络问题无法在网页显示 生成图片pyecharts-assets 提供了 pyecharts 的静态资源文件。可通过 localhost-server 或者 notebook-server 启动本地服务。 Localhost-Server 首先将项目下载到本地 12345# 通过 git clone$ git clone https:&#x2F;&#x2F;github.com&#x2F;pyecharts&#x2F;pyecharts-assets.git # 或者直接下载压缩包$ wget https:&#x2F;&#x2F;github.com&#x2F;pyecharts&#x2F;pyecharts-assets&#x2F;archive&#x2F;master.zip 启动服务器 12$ cd pyecharts-assets$ python -m http.server 设置 host 12345678# 只需要在顶部声明 CurrentConfig.ONLINE_HOST 即可from pyecharts.globals import CurrentConfig CurrentConfig.ONLINE_HOST &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;assets&#x2F;&quot; # 接下来所有图形的静态资源文件都会来自刚启动的服务器from pyecharts.charts import Barbar &#x3D; Bar() Notebook-Server 安装拓展插件 1234$ cd pyecharts-assets# 安装并激活插件$ jupyter nbextension install assets$ jupyter nbextension enable assets&#x2F;main 设置 host 123456789# 只需要在顶部声明 CurrentConfig.ONLINE_HOST 即可from pyecharts.globals import CurrentConfig, OnlineHostType# OnlineHostType.NOTEBOOK_HOST 默认值为 http:&#x2F;&#x2F;localhost:8888&#x2F;nbextensions&#x2F;assets&#x2F;CurrentConfig.ONLINE_HOST &#x3D; OnlineHostType.NOTEBOOK_HOST# 接下来所有图形的静态资源文件都会来自刚启动的服务器from pyecharts.charts import Barbar &#x3D; Bar() 未解决问题 : 需要注意的是对于词云图 任然存在显示白屏问题*","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"Chrome-Network","slug":"Chrome-Network","date":"2020-08-17T14:04:46.000Z","updated":"2020-08-17T14:05:05.005Z","comments":true,"path":"2020/08/17/chrome-network/","link":"","permalink":"http://yoursite.com/2020/08/17/chrome-network/","excerpt":"","text":"Google DevTools 开发者工具打开网络面板 1. 打开 DevTools 控制台面板2. 单击网络选项卡。将打开“网络”面板。3. “网络”面板为空。这是因为DevTools仅在网络活动打开时记录日志，并且自您打开DevTools以来未发生任何网络活动。4. 刷新页面记录网络活动1. 重新加载页面, “Network” 面板将所有网络活动记录在“ 网络日志”中 网络日志 (Web Log) 的每一行代表一个资源。默认情况下，资源按时间顺序列出。最重要的资源通常是主要的HTML文档。最底层的资源是最后请求的资源。(只要打开DevTools，它将在网络日志中记录网络活动。) name: 提示通过将鼠标悬停在“名称”列中的单元格上，可以查看资源的完整URL。 Status : 状态 HTTP 响应代码 Type : 资源类型 Initiator : 单击“Initiator”列中的链接，将您带到引起资源请求的源代码 (网址)。 Size : 请求大小 Time : 请求花了多长时间 Waterfall :请求不同阶段的图形表示。将鼠标悬停可以查看细目 Domain: 右键单击“网络日志”表的标题，然后选择“Domain”。现在显示每个资源的域。 (Throttling) 模拟较慢的网络连接 (用于构建站点的计算机的网络连接可能比用户的移动设备的网络连接快。通过限制页面，您可以更好地了解页面在移动设备上加载需要多长时间。) 单击“节流”下拉菜单，默认情况下将其设置为“Online” 选择 “Slow 3G” 长按重新加载 (Reload)，然后选择“清空缓存和硬重新加载 (Empty Cache And Hard Reload)”. (在重复访问时，浏览器通常会从其缓存中提供一些文件，从而加快了页面加载速度。空缓存和硬重载会强制浏览器访问所有资源的网络。当您想了解首次访问者如何体验页面加载时，这很有用。) 仅当打开DevTools时，“清空缓存和硬重装”工作流程才可用。 检查资源的详细信息 (单击资源以了解有关它的更多信息) 点击getstarted.html。显示“Headers”选项卡。使用此选项卡检查HTTP标头。 单击预览 (Preview) 选项卡。显示了HTML的基本呈现。 (当API以HTML返回错误代码并且比HTML源代码更容易阅读呈现的HTML或检查图像时，此选项卡非常有用) 单击响应 (Response) 选项卡。显示了HTML源代码。 缩小文件后，单击“响应”选项卡底部的“格式 (Format)”按钮会重新格式化文件的内容，以提高可读性。 单击时间 (Timing) 选项卡。显示了此资源的网络活动的细分。 单击关闭 (x) 以再次查看网络日志。 (Search)搜索网络标题和响应 (当您需要在HTTP标头和所有资源的响应中搜索某个字符串或正则表达式时，请使用“搜索 (Search) ”窗格。) 点击搜索。搜索窗格将在网络日志的左侧/上侧打开。 单击结果以查看它。如果在标题 (headers) 中找到查询，则“标题”选项卡将打开。如果在内容 (content) 中找到查询，则“响应”选项卡将打开。 筛选 (Filter) 资源 (沙漏按钮, DevTools提供了许多工作流，用于过滤与手头任务无关的资源。按字符串，正则表达式或属性过滤) 在“过滤器”文本框中键入png。仅显示包含文本png的文件。在这种情况下，唯一与过滤器匹配的文件是PNG图像。 键入/.*.[cj]s+$/。DevTools会过滤出任何文件名不以j或c结尾且后跟1个或多个s字符的资源。 输入-main.css。DevTools过滤掉main.css。如果任何其他文件与该模式匹配，它们也将被过滤掉。 在“过滤器”文本框中键入domain：raw.githubusercontent.com。DevTools过滤出任何URL与此域不匹配的资源。 按资源类型过滤 单击CSS。其他所有文件类型均被过滤掉。 要同时查看脚本，请按住Control或Command（Mac），然后单击JS。 单击全部删除过滤器，然后再次查看所有资源 (Clear) 清空加载信息，刷新后重新加载 (Stop recording network log) 暂时停止更新网络日志 (Disable cache) : 禁用缓存 (Preserve log) : 保留日志 (Network Setting) Show overview : 显示总览，以时间轴来显示加载过程 Capture screenshots : 截图 截图 (屏幕快照使您可以看到页面在加载过程中的外观。) 点击 Capture Screenshots (屏幕快照) 通过“清空缓存和硬重装”工作流程再次重装页面。如果您需要有关如何执行此操作的提示，请参阅模拟较慢的连接。屏幕截图窗格提供了缩略图的缩略图，该缩略图显示了页面在加载过程中各个点的外观。 单击第一个缩略图。DevTools会向您显示当时正在发生的网络活动。 再次单击“ Capture Screenshots”以关闭“屏幕截图”窗格。 重新加载页面 Use large request rows : 使用大图来显示 request 的 Web Log Group by frame : 按帧分组 阻止请求 (页面的某些资源不可用时，页面的外观和行为如何？它会完全失败，还是仍然有些功能？使用阻止请求以判断) 按Control + Shift + P或Command + Shift + P（Mac）打开“命令 (Command Menu)”菜单。 键入阻止 (&gt;block)，选择显示请求阻止 (Show Request blocking)，然后按Enter 点击 Add Pattern 选择类 main.css 点击 Add 重新加载页面。正如预期的那样，页面的样式有些混乱，因为其主要样式表已被阻止。请注意网络日志中的main.css行。红色文本表示资源已被阻止。 取消选中启用请求阻止复选框","categories":[],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"Chrome-Elements","slug":"Chrome-Elements","date":"2020-08-15T03:14:40.000Z","updated":"2020-08-15T03:15:19.159Z","comments":true,"path":"2020/08/15/chrome-elements/","link":"","permalink":"http://yoursite.com/2020/08/15/chrome-elements/","excerpt":"","text":"Google DevTools 开发者工具打开 Chrome 开发者工具1. 在 Chrome 菜单中选择 更多工具-&gt;开发者工具2. 在页面元素上右键点击，选择检查 (Windows 下快捷键 F12)3. 使用快捷键 Ctrl + Shift + I(Windows) 或 Cmd + Opt + I (Mac)1. 元素面板 (Elements) 使用元素面板自由操作 DOM 和 CSS 来迭代布局和设计页面 检查和调整页面 摘要 (TL;DR) 在 Elements 面板中检查和实时编辑 DOM 树中的任何元素 双击选定元素即可对 DOM 节点实时编辑更改 在 Styles 窗格中查看和更改应用到任何选定元素的 CSS 规则 在 Styles 窗格中实时编辑样式属性名称和值。所有样式均可修改，除了灰色部分（与 User Agent 样式表一样）。 要编辑名称或值，请点击它，进行更改，然后按 Tab 或 Enter 保存更改。 在 Computed 窗格中查看和修改选定元素的框模型 Computed 窗格检查和编辑当前元素的框模型参数。 框模型中的所有值均可修改，只需点击它们即可。 同轴矩形包含当前元素 padding、border 和 margin 属性的 top、bottom、left、right 值。 对于位置为非静态的元素，还会显示 position 矩形，包含 top、right、bottom 和 left 属性的值。 对于 position: fixed 和 position: absolute 元素，中心域包含选定元素实际的 offsetWidth × offsetHeight 像素尺寸。所有值都可以通过双击修改，就像 Styles 窗格中的属性值一样。 不过，无法保证这些更改能够生效，因为这要取决于具体的元素定位详情。 在 Sources 面板中查看在本地对页面所做的修改 粉色背景的线表示移除，绿色背景的线表示添加。 查看对页面所做的实时编辑的历史记录 在 Styles 窗格中，点击您修改的文件。DevTools 会将您带到 Sources 面板。 右键点击文件 选择 Local modifications 检查所做的修改 展开顶级文件名查看做出修改的时间 做出修改的时间。 展开第二级项目查看修改相应的不同（前和后）。 撤销更改 未设置永久制作 : 每次重新加载页面时，所有实时编辑都会丢失 设置永久制作，撤销更改 : 使用 Ctrl+Z (Windows) 或 Cmd+Z (Mac) 通过 Elements 面板快速撤消对 DOM 或样式所做的细微更改。 撤消对文件所做的所有本地修改，请打开 Sources 面板，然后选择文件名旁的 revert。 使用 Styles 可以修改与元素关联的 CSS 摘要 (TL;DR) 利用 Styles 窗格，可以在本地以尽可能多的方法更改 CSS，包括修改现有样式、添加新样式，以及为样式添加规则。 如果希望样式可以保持（不会在重新加载后消失），则需要将其保存到开发工作区中 检查应用到元素的样式: 选择一个元素以检查其样式。 Styles 窗格可以显示应用到选定元素的 CSS 规则，优先级从高到低： 顶端为 element.style。这些样式要么直接使用样式属性（例如 ）直接应用到元素，要么在 DevTools 中应用。 下方是与元素匹配的任何 CSS 规则。例如，在下面的屏幕截图中，选定元素从 tools.css 中定义的规则接收 line-height:24px。 再下方是继承的样式，其中包括与选定元素的祖先实体匹配的任何可继承样式规则。 例如，在下面的屏幕截图中，选定元素从 user agent stylesheet 继承 display:list-item。 样式: 标签与其下方带编号的项目对应 与元素匹配的选择器的关联样式。 User Agent 样式表清晰标记，并且在网页上经常被 CSS 替换。 已被级联规则替换的规则将显示为带删除线的文本。 继承的样式将在“Inherited from ”标头下显示为一组。点击标头中的 DOM 节点可以导航到其在 DOM 树视图中的位置。 灰色的条目不是已定义的规则，而是在运行时计算的规则。 检查受选择器影响的元素: 在 Styles 窗格中将鼠标悬停在 CSS 选择器上可以查看受该选择器影响的所有元素——(此功能仅突出显示视口中的元素；视口以外的其他元素也可能受选择器影响。) 添加、启用和停用 CSS 类 点击 .cls 按钮可以查看与当前选定元素关联的所有 CSS 类。 从这里，您可以执行以下操作： 启用或停用当前与元素关联的类 向元素添加新类。 编辑现有属性名称或值 点击 CSS 属性名称或值可以对其进行编辑 在名称或值突出显示时，按 Tab 可以向前移动到下一个属性、名称或选择器。 按 Shift+Tab 可以向后移动。 编辑数字式 CSS 属性值时，可以使用下面的键盘快捷键增大和减小值： 使用向上键和向下键能够以 1 为增量增大和减小值（如果当前值介于 -1 和 1 之间，则增量为 0.1）。 使用 Alt+向上键和 Alt+向下键能够以 0.1 为增量增大和减小值。 使用 Shift+向上键能够以 10 为增量增大值；使用 Shift+向下键能够以 10 为增量减小值。 使用 Shift+Page Up（Windows、Linux）或 Shift+Function+向上键 (Mac) 能够以 100 为增量增大值。使用 Shift+Page Down（Windows、Linux）或 Shift+Function+向下键 (Mac) 能够以 100 为增量减小值。 添加新属性声明 点击可编辑 CSS 规则中的空白处可以创建一个新声明。 键入，或者将 CSS 粘贴到 Styles 窗格中。属性及其值将解析并输入到正确的字段中。——( 要启用或停用样式声明，请选中或取消选中旁边的复选框。) 添加样式规则 点击 (New Style Rule 按钮 图标为 右上角 + ) 按钮可以添加一个新的 CSS 规则。点击并按住按钮可以选择要向哪一个样式表添加规则。 添加或移除动态样式（伪类） 可以在元素上手动设置动态伪类选择器（例如 :active、:focus、:hover 和 :visited） 设置动态状态的两种方式 在 Elements 面板内右键点击某个元素，然后从菜单中选择目标伪类 (:active、:focus、:hover 和 :visited) ，将其启用或停用。 在 Elements 面板中选择元素，然后在 Styles 窗格中点击 :hov 按钮，使用复选框启用或停用当前选定元素的选择器。 向样式规则添加背景色或颜色 向样式规则添加 color 和 background-color 声明的快捷方式 样式规则的右下角有一个由三个点组成的图标。您需要将鼠标悬停到样式规则上才能看到这个图标。 将鼠标悬停到此图标上可以调出用于添加 字体color 声明 或 background-color 声明 的按钮。点击这些按钮之一可以将声明添加到样式规则中。 使用 Color Picker 修改颜色 在 Styles 窗格中查找一个定义颜色的 CSS 声明（例如 color: blue）。 声明值的左侧有一个带颜色的小正方形。 正方形的颜色与声明值匹配。 点击小正方形可以打开 Color Picker。 与 Color Picker 交互： 取色器 点击取色器按钮将其启用，在实时页面上将鼠标悬停到某种颜色上，然后点击，将当前选定的声明值设置为您悬停的颜色。 当前颜色。当前值的可视表示。 当前值。当前颜色的十六进制、RGBA 或 HSL 表示。 调色板。 提供多种调色板 Page Colors。一组从页面的 CSS 自动生成的颜色。 Material Design。一组符合 Material Design 规范的颜色。 Custom。您选择的任意一组颜色。DevTools 可以保存您的自定义调色板（甚至在不同的页面间），直至您将其删除。 修改自定义调色板 按加号按钮可以将当前颜色添加到调色板中。 点击并按住颜色可以将其拖动到不同的位置，或者将其拖动到垃圾桶图标进行删除。 右键点击颜色并选择 Remove color 可以将其删除。 选择 Remove all to the right 可以删除当前选定颜色右侧的所有颜色。 右键点击调色板区域中的任何位置，然后选择 Clear template 可以删除模板的所有颜色。 着色和阴影选择器。 色调选择器。 不透明度选择器。 颜色值选择器。点击可以在 RGBA、HSL 和十六进制之间切换。 调色板选择器。点击可以选择不同的模板。 查看和编辑 CSS 自定义属性（CSS 变量） 自定义属性通常在 :root 选择器中定义。 要查看在 :root 中定义的自定义属性，请检查 元素。 编辑 Sass、Less 或 Stylus 借助 CSS 源映射，DevTools 可以将生成的文件自动映射到源代码文件，这样，您可以在 Sources 面板中实时编辑这些文件并查看结果，而不用离开 DevTools 或刷新页面。 预处理器工作流 检查样式由生成的 CSS 文件提供的元素时，Elements 面板会显示原始的源文件而不是生成的 CSS 文件的链接。 跳转到源文件 点击链接，在 Sources 面板中打开（可编辑）源文件。 Ctrl + 点击（或 Cmd + 点击）任何 CSS 属性名称或值，打开源文件并跳转到相应行。 启用/停用 CSS 源映射和自动重新加载 默认情况下，CSS 源映射处于启用状态 启用 CSS 源映射和 CSS 重新重新加载 打开 DevTools 的 Settings 面板并点击 General。 开启 Enable CSS source maps 和 Auto-reload generated CSS。 通过 DOM 更新实时修改页面的内容和结构。 摘要 (TL;DR) DOM 定义您的页面结构。每一个 DOM 节点都是一个页面元素，例如，标题节点或段落节点。 通过渲染的 DOM 实时编辑页面的内容和结构。 无法在 Elements 面板中通过 DOM 更改修改源文件。重新加载页面会清空任何 DOM 树修改。 使用 DOM 断点留意 DOM 更改。 检查元素 右键点击页面上的任何元素并选择 检查 (Inspect)。 按 Ctrl + Shift + C (Windows) 或 Cmd + Shift + C (Mac)，在 Inspect Element 模式下打开 DevTools，然后将鼠标悬停到某个元素上。 DevTools 会在 Elements 面板中自动突出显示您悬停的元素。点击元素可以退出检查模式，同时保持元素在 Elements 面板中处于突出显示状态。 点击 Inspect Element 按钮 转到 Inspect Element 模式，然后点击元素。 DOM 导航 折叠的节点的旁边会有一个向右箭头 展开的节点的旁边会有一个向下箭头 使用鼠标 点击一次可以突出显示节点。 要展开节点，请双击节点上的任何地方，或者点击节点旁边的箭头。 要折叠节点，请点击节点旁边的箭头。 使用键盘 按向上箭头键可以选择当前节点上方的节点。 按向下箭头可以选择当前节点下方的节点。 按向右箭头键可以展开折叠的节点。再按一次可以移动到（已展开）节点的第一个子级。 您可以使用此方法快速导航到深度嵌套的节点。 面包屑导航记录导航 Elements 面板的底部是面包屑导航记录。 当前选定的节点将以蓝色突出显示。左侧是当前节点的父级。 再左侧是父级的父级。以此类推，一直到 DOM 树。 在结构中向上导航会移动突出显示焦点： DevTools 会在记录中显示尽可能多的项目。如果状态栏无法显示全部记录，将在记录截断的地方显示一个省略号 (…)。点击省略号可以显示隐藏的元素： 显示 more actions 菜单 右键点击节点 选择节点，然后点击节点前方的 “…” 按钮 (more action 按钮))。按钮仅在当前选定的元素上显示。 编辑 DOM 节点和属性 直接在节点名称或属性上双击。 突出显示节点，按 Enter，然后按 Tab， 直到选中名称或属性。 鼠标右键打开 more actions 菜单 并选择 Add Attribute 或 Edit Attribute。 Edit Attribute 取决于上下文；您点击的部分决定要编辑的内容。 以 HTML 形式编辑 DOM 节点及其子级 打开 HTML 形式编辑器 鼠标右键打开 more actions 菜单并选择 Edit Attribute。 按 F2 (Windows / Linux) 或 Fn+F2 (Mac)。 保存更改 按 Ctrl+Enter (Windows / Linux) 或 Cmd+Enter (Mac) 保存更改。 按 Esc 可以退出编辑器而不保存。 移动 DOM 节点 点击、按住并拖动节点可将其移动。 删除 DOM 节点 鼠标右键打开 more actions 菜单并选择 Delete Node。 选择节点并按 Delete 键。 如果意外删除了节点，按 Ctrl + Z（Mac 上为 Cmd + Z）可以撤消您的上一步操作。 滚动到视图 悬停或选择 DOM 节点时，渲染的节点将在视口中突出显示 节点滚动到屏幕以外，在节点位于当前视口上方时您将在视口顶部看到提示，而在节点位于当前视口下方时，您将在底部看到提示 设置 DOM 断点以调试复杂的 JavaScript 应用 将 DOM 断点设置为在元素属性修改时触发 子树修改触发 添加、移除或移动子元素时将触发子树修改断点 12345&#x2F;&#x2F;在 main-content 元素上设置子树修改，以下代码将触发断点：var element &#x3D; document.getElementById(&#39;main-content&#39;);&#x2F;&#x2F;modify the element&#39;s subtree.var mySpan &#x3D; document.createElement(&#39;span&#39;);element.appendChild( mySpan ); 属性修改触发 动态更改元素的属性 (class, id, name) 时将发生属性修改 123var element &#x3D; document.getElementById(&#39;main-content&#39;);&#x2F;&#x2F; class attribute of element has been modified.element.className &#x3D; &#39;active&#39;; 节点移除 从 DOM 中移除有问题的节点时将触发节点移除修改： document.getElementById(&apos;main-content&apos;).remove(); 与 DOM 断点交互 Elements 和 Sources 面板均包含一个用于管理 DOM 断点的窗格,每个断点都会列出元素标识符和断点类型。 (DOM Breakpoints) 断点交互 悬停在元素标识符上可以显示元素在页面上的相应位置（类似于在 Elements 面板中悬停在节点上）。 点击元素可以将其在 Elements 面板中选中。 切换复选框可以启用或停用断点。 触发 DOM 断点时，断点将在 DOM Breakpoints 窗格中突出显示。 Call Stack 窗格将显示调试程序暂停的原因： 查看元素事件侦听器 (Event Listeners 查看与 DOM 节点关联的 JavaScript 事件侦听器。) Event Listeners 窗格中的顶级项目将显示具有已注册侦听器的事件类型。 点击事件类型（例如 click）旁的箭头可以查看已注册事件处理程序的列表。 每个处理程序都由一个类似于 CSS 选择器的元素标识符标识，例如 document 或 button#call-to-action。如果已为相同元素注册多个处理程序，将重复列示元素。 点击元素标识符旁的展开箭头可以查看事件处理程序的属性。Event Listeners 窗格将列出每个侦听器的以下属性： handler : 包含一个回调函数。右键点击函数并选择 Show Function Definition 可以查看函数的定义位置（如果源代码可用）。 useCapture : 指示 addEventListener 上的 useCapture 标志是否设置的布尔值。 查看祖先实体事件侦听器 如果启用 Ancestors 复选框，除了当前选定节点的事件侦听器外，还会显示其祖先实体的事件侦听器。 如果停用复选框，将仅显示当前选定节点的事件侦听器。 查看框架侦听器 启用 Framework listeners 复选框时，DevTools 会自动解析事件代码的框架或内容库封装部分，然后告诉您实际将事件绑定到代码中的位置。 如果停用 Framework listeners 复选框，事件侦听器代码很可能会在框架或内容库代码的其他地方解析。","categories":[],"tags":[{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"}]},{"title":"pyecharts-Funnel","slug":"pyecharts-Funnel","date":"2020-08-13T11:59:06.000Z","updated":"2020-08-13T11:59:29.334Z","comments":true,"path":"2020/08/13/pyecharts-funnel/","link":"","permalink":"http://yoursite.com/2020/08/13/pyecharts-funnel/","excerpt":"","text":"pyecharts_Bar全部来自于官方文档，主要用于方便自己查找 Funnel：漏斗图123456789101112131415x_data &#x3D; []y_data &#x3D; []data &#x3D; [[x_data[i], y_data[i]] for i in range(len(x_data))( Funnel(init_opts &#x3D; opts.InitOpts(width&#x3D;&quot;“, height&#x3D;&quot;&quot;)) .add( series_name &#x3D; &quot;&quot;, data_pair&#x3D;data, ... ) .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;漏斗图主标题&quot;, subtitle&#x3D;&quot;副标题&quot;)) .render(&quot;xxx.html&quot;)) add() 12345678910111213141516171819202122232425262728def add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据项，格式为 [(key1, value1), (key2, value2)] data_pair: Sequence, # 是否选中图例 is_selected: bool &#x3D; True, # 系列 label 颜色 color: Optional[str] &#x3D; None, # 数据排序， 可以取 &#39;ascending&#39;，&#39;descending&#39;，&#39;none&#39;（表示按 data 顺序） sort_: str &#x3D; &quot;descending&quot;, # 数据图形间距 gap: Numeric &#x3D; 0, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(), # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None, )","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"Python_PEP8编程风格规范","slug":"Python-PEP8","date":"2020-08-12T01:36:05.000Z","updated":"2020-08-12T01:36:44.366Z","comments":true,"path":"2020/08/12/python-pep8/","link":"","permalink":"http://yoursite.com/2020/08/12/python-pep8/","excerpt":"","text":"PEP8 编程风格规范代码布局 (Code Lay-Out)1. 缩进 (Indentation) 每个缩进级别 4个 空格 连续行所包装元素 1234567891011121314# 同开始分界符(左括号)对齐 foo &#x3D; long_function_name(var_one, var_two, var_three, var_four) # 续行多缩进一级以同其他代码区别 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 悬挂缩进需要多缩进一级 foo &#x3D; long_function_name( var_one, var_two, var_three, var_four) Python隐式续行 垂直对齐于圆括号、方括号和花括号 悬挂缩进 第一行不应该包括参数，并且在续行中 (续行来说，4空格的规则可以不遵守) 需要再缩进一级以便清楚表示 多行结束右圆/方/花括号可以单独一行书写，和上一行的缩进对齐;也可以和多行开始的第一行的第一个字符对齐123456789101112my_list &#x3D; [ 1, 2, 3, 4, 5, 6, ]result &#x3D; some_function_that_takes_arguments( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, )my_list &#x3D; [ 1, 2, 3, 4, 5, 6,] 推荐使用空格来进行缩进。Python 3不允许tab和空格混合使用。 2. 每行最大长度(Maximum Line Length) 所有行都限制在 79 个字符以内 连续大段的文字（比如文档字符串(docstring)或注释），其结构上的限制更少，这些行应该被限制在72个字符长度内。 换行方式是利用Python圆括号、方括号和花括号中的隐式续行。长行可以通过在括号内换行来分成多行。应该最好加上反斜杠来区别续行。 3. 二元运算符之前还是之后换行? Kunth 风格: 尽管在段落中的公式总是在二元运算符之后换行，但显示公式时总是在二元运算符之前换行 如果项目约定，也可以在二元运算符之后换行 4. 空行 (支持control + L 换行符作为空格) 使用 2个 空行来分隔最外层的 函数(function) 和 类(class) 定义 使用 1个 空行来分隔 类中的方法(method) 定义 额外的空行(尽量少) 来分隔一组相关的函数 在函数内使用空行(尽量少) 使代码逻辑更加清晰 5. 源文件编码(Source File Encoding) python 2 使用 ASCII python 3 使用 UTF-8 Python标准库中的所有标识符都必须只采用ASCII编码的标识符，在可行的条件下也应当使用英文词 6. 模块引用(Imports) imports 分行写，不应都写在一行 1234# 分开写import os# 被允许的from subprocess import Popen, PIPE imports 写在代码文件的开头，位于模块(module)注释和文档字符串(docstring)之后，模块全局变量(globals)和常量(constants)声明之””. imports 顺序 (不同的 imports 之间用空格隔开) 标准库 imports 相关第三方 imports 本地应用/库的特定 imports 推荐使用绝对(absolute) imports (易读且会报错) from mypkg import sibling 显式的相对imports也是一种可以接受的替代方式.特别是当处理复杂的包布局(package layouts)时，采用绝对imports会显得啰嗦. from .sibling import example 标准库代码应当一直使用绝对imports，避免复杂的包布局.隐式的相对imports应该永不使用，并且Python 3中已经被去掉了. 如果从包含类的模块import的类与本地命名产生冲突，可以直接 import 模块 避免使用通配符进行 imports， 会产生许多不必要的麻烦 7. 模块级的双下划线命名(Module level dunder names) 模块及级下划线命名的变量，函数，应该在 文档的多行注释字符串之后 8. 字符串的引用(String Quotes) 当字符串中包含单引号时，采用双引号来表示字符串，可以避免使用反斜杠，代码也更易读 在一个项目中最好字符串都用单引号或者双引号 9. 表达式和语句中的空格(Whitespace In Expressions And Statements) 方括号、圆括号和花括号之后避免使用空格 逗号，分号或冒号之前避免使用空格 切片操作时避免使用空格 冒号和二元运算符是一样的，应该在其左右两边保留相同数量的空格； 扩展切片操作中，所有冒号的左右两边空格数都应该相等； 切片操作中的参数被省略时，应该也忽略空格. 调用函数时传递参数list的括号之前避免使用空格 索引和切片操作的左括号之前避免使用空格 赋值(或其他)运算符周围使用多个空格来和其他语句对齐 避免任何行末的空格. 二元运算符的两边都使用一个空格：赋值运算符(=)，增量赋值运算符(+=, -= etc.)，比较运算符(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算符(and, or, not). 优先级不同的运算符，则在优先级较低的操作符周围增加空白.(不要用超过1个空格，永远保持二元运算符两侧的空白数量一样.) 使用=符号来表示关键字参数或参数默认值时，不要在其周围使用空格. 函数注解中的:也遵循一般的:加空格的规则，在-&gt;两侧各使用一个空格. 在组合使用函数注解和参数默认值时，需要在=两侧各使用一个空格(只有当这个参数既有函数注解，又有默认值的时候). 复合语句(即将多行语句写在一行)一般是不鼓励使用的. 短小的if/for/while中的语句写在一行,多分支的不要使用 10. 何时在末尾加逗号(When to use trailing commas) 定义单元素元组(tuple)时是必需的1FILES &#x3D; (&#39;setup.cfg&#39;,) 在将来有可能扩展的列表末尾添加冗余的逗号，每一个元素写在单独的一行，并在行尾添加逗号，右括号单独占一行.1234FILES &#x3D; [ &#39;setup.cfg&#39;, &#39;tox.ini&#39;, ] 11. 注释(Comments) 当代码有改动时，一定要优先更改注释使其保持最新. 注释应该是完整的多个句子.如果注释是一个短语或一个句子，其首字母应该大写，除非开头是一个以小写字母开头的标识符(永远不要更改标识符的大小写). 注释很短，结束的句号可以被忽略.块注释通常由一段或几段完整的句子组成，每个句子都应该以句号结束. 在句尾的句号后再加上2个空格. 尽量用英文写注释 块注释(Block Comments) 一般写在对应代码之前，并且和对应代码有同样的缩进级别.块注释的每一行都应该以#和一个空格开头(除非该文本是在注释内缩进对齐的). 行内注释(Inline Comments) 尽量少用行内注释. 1x &#x3D; x + 1 # x自加 行内注释是和代码语句写在一行内的注释.行内注释应该至少和代码语句之间有两个空格的间隔，并且以#和一个空格开始. 文档字符串注释(Documentation Strings) 所有的公共模块，函数，类和方法都应该有文档字符串.对于非公共方法，文档字符串不是必要的，但你应该留有注释说明该方法的功能，该注释应当出现在def的下一行. 多行文档字符串以单行”””结尾，不能有其他字符 对于仅有一行的文档字符串，结尾处的”””应该也写在这一行. 12. 命名约定(Naming Conventions) 首要原则(Overriding Principle) 对于用户可见的公共部分API，其命名应当表达出功能用途而不是其具体的实现细节. 命名风格(Descriptive: Naming Styles) CapitalizedWords (也叫做CapWords或者CamelCase – 因为单词首字母大写看起来很像驼峰).也被称作StudlyCaps.注意：当CapWords里包含缩写时，将缩写部分的字母都大写.HTTPServerError比HttpServerError要好. mixedCase (注意：和CapitalizedWords不同在于其首字母小写！) Capitalized_Words_With_Underscores (这种风格超丑！) UPPER_CASE_WITH_UNDERSCORES(带下划线大写) UPPERCASE(大写) lower_case_with_underscores(带下划线小写) lowercase(小写) B (单个大写字母) b (单个小写字母) 特殊形式 _single_leading_underscore: 以单个下划线开头是”内部使用”的弱标志。 single_trailing_underscore_: 以单个下划线结尾用来避免和Python关键词产生冲突 1class_&#x3D;&quot;xxx&quot; double_leading_underscore: 以双下划线开头的风格命名类属性表示触发命名修饰（在FooBar类中，boo命名会被修饰成_FooBar__boo) double_leading_and_trailing_underscore: 以双下划线开头和结尾的命名风格表示“魔术”对象或属性，存在于用户控制的命名空间(user-controlled namespaces)里 命名约定(Prescriptive: Naming Conventions) 需要避免的命名(Names To Avoid) 字符’l’(L的小写的字母) ’O’(o大写的字母) ’I’(i的大写的字母) ASCII兼容性(ASCII Compatibility) 包和模块命名(Package And Module Names) 模块命名应短小，且为全小写.若下划线能提高可读性，也可以在模块名中使用 包命名也应该短小，且为全小写，但不应使用下划线. 使用C或C++写的扩展模块有相应的Python模块提供更高级的接口时, C/C++模块名以下划线开头(例如，_sociket) 类命名(Class Names) 驼峰(CapWords)的命名约定 类型变量命名(Type variable names) 类型变量名称通常应使用简短的驼峰命名 异常命名(Exception Names) 类命名约定也适用与异常.不同的是，如果异常实际上是抛出错误的话，异常名前应该加上”Error”的前缀. 函数命名(Function Names) 函数命名应该都是小写，必要时使用下划线来提高可读性. 全局变量命名(Global Variable Names) 引用方式设计为from M import *的模块，应该使用all机制来避免import全局变量，或者采用下划线前缀的旧约定来命名全局变量，从而表明这些变量是“模块非公开的”. 函数和方法参数(Function And Method Arguments) 实例方法的第一参数永远都是self. 类方法的第一个参数永远都是cls. 在函数参数名和保留关键字冲突时，相对于使用缩写或拼写简化，使用以下划线结尾的命名一般更好.比如，class_比clss更好. 方法命名和实例变量(Method Names And Instance Variables) 使用函数命名的规则：小写单词，必要时使用下划线分开以提高可读性. 仅对于非公开方法和变量命名在开头使用一个下划线 避免和子类的命名冲突，使用两个下划线开头来触发Python的命名修饰机制. 常量(Constants) 常量通常是在模块级别定义的，使用全部大写并用下划线将单词分开.如：MAX_OVERFLOW和TOTAL . 13. 公开和内部接口(Public And Internal Interfaces) 任何向后兼容性保证仅对公开接口适用 文档化的接口被认为是公开的，除非文档中明确申明了它们是临时的或者内部接口，不保证向后兼容性.所有文档中未提到的接口应该被认为是内部的. 为了更好审视公开接口和内部接口，模块应该在all属性中明确申明公开API是哪些.将all__设为空list表示该模块中没有公开API. 14. 编程建议(Programming Recommendations) 代码应该以不影响其他Python实现(PyPy，Jython，IronPython，Cython，Psyco等)的方式编写. 库中性能敏感的部分，用’’.join形式来代替.这会确保在所有不同的实现中字符串拼接是线性时间的. 不要依赖于 CPython 在字符串拼接时的优化实现 与单例作比较，像None应该用is或is not，从不使用==操作符 用is not操作符而不是not … is.虽然这两个表达式是功能相同的，前一个是更可读的，是首选. 始终使用def语句来代替直接绑定了一个lambda表达式的赋值语句. 捕获异常时，尽可能使用明确的异常，而不是用一个空的except:语句.(限制使用空except语句) 绑定异常给一个名字时，最好使用 Python 2.6 里添加的明确的名字绑定语法： 对于所有try / except子句，将try子句限制为必需的绝对最小代码量.同样，这样可以避免屏蔽错误. 坚持使用return语句.函数内的return语句都应该返回一个表达式，或者None.如果一个return语句返回一个表达式，另一个没有返回值的应该用return None清晰的说明，并且在一个函数的结尾应该明确使用一个return语句(如果有返回值的话). 用字符串方法代替字符串模块. 用’’.startswith()和’’.endswith()代替字符串切片来检查前缀和后缀.startswith()和endswith()是更简洁的，不容易出错的. 对象类型的比较应该始终使用isinstance()而不是直接比较. 对于序列(字符串、列表、元组)来说，空的序列为False： 对于序列(字符串、列表、元组)来说，空的序列为False： 不要让字符串对尾随的空格有依赖.这样的尾随空格是视觉上无法区分的，一些编辑器(或者，reindent.py)会将其裁剪掉. 不要用==比较True和False.","categories":[],"tags":[{"name":"PEP8 编程风格规范","slug":"PEP8-编程风格规范","permalink":"http://yoursite.com/tags/PEP8-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/"}]},{"title":"pyecharts-Liquid","slug":"pyecharts-Liquid","date":"2020-08-10T13:18:46.000Z","updated":"2020-08-10T13:19:16.036Z","comments":true,"path":"2020/08/10/pyecharts-liquid/","link":"","permalink":"http://yoursite.com/2020/08/10/pyecharts-liquid/","excerpt":"","text":"pyecharts_Liquid全部来自于官方文档，主要用于方便自己查找 Liquid：水球图 123456c &#x3D; ( Liquid(&quot;鼠标移动显示&quot;, [0.5, 0.7]) .add() .set_global_opts(title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;&quot;)) .render(&quot;xxxx&quot;)) .add()1234567891011121314151617181920212223242526272829303132333435363738394041class Liquid( # 初始化配置项，参考 &#96;global_options.InitOpts&#96; init_opts: opts.InitOpts &#x3D; opts.InitOpts())func pyecharts.charts.Liquid.adddef add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据，格式为 [value1, value2, ....] data: Sequence, # 水球外形，有&#39; circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39; 可选。 # 默认 &#39;circle&#39;。也可以为自定义的 SVG 路径。 shape: str &#x3D; &quot;circle&quot;, # 波浪颜色。 color: Optional[Sequence[str]] &#x3D; None, # 背景颜色 background_color: types.Union[str, dict, None] &#x3D; None, # 是否显示波浪动画。 is_animation: bool &#x3D; True, # 是否显示边框。 is_outline_show: bool &#x3D; True, # 外沿边框宽度 outline_border_distance: types.Numeric &#x3D; 8, # 外沿样式 outline_itemstyle_opts: types.ItemStyle &#x3D; None, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(font_size&#x3D;50, position&#x3D;&quot;inside&quot;), # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"Flask-note2","slug":"Flask-note2","date":"2020-08-08T01:32:27.000Z","updated":"2020-08-08T01:38:40.052Z","comments":true,"path":"2020/08/08/flask-note2/","link":"","permalink":"http://yoursite.com/2020/08/08/flask-note2/","excerpt":"","text":"根据Youtube上视频学习 利用邮箱重置密码 在登录界面 (login.html) 创建 “忘记密码，找回选项” 12345678&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;hr&gt; &#123;# 创建 找回密码界面 \"send_password_reset_request.html\" #&#125; Password forget? &lt;a href=\"&#123;&#123; url_for('send_password_reset_request') &#125;&#125;\"&gt; Click here to reset your password.&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;2. 创建 找回密码界面 “send_password_reset_request.html” 界面配置与 注册界面类似 1234567891011121314&#123;% extends 'base.html' %&#125;&#123;% block app_content %&#125; # 重置密码标题 &lt;h1&gt;Send Reset Password Email&lt;/h1&gt; &lt;br&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125;3. 在 forms.py 内创建 重置密码表单， ![](https://cdn.jsdelivr.net/gh/Forgotten-Forever/BlogImages/images/Email_not_exists.png) 123456789101112class PasswordResetRequestForm(FlaskForm): # 输入 Email 表格 email = StringField('Email', validators=[DataRequired(), Email()]) # 发送邮件按钮 submit = SubmitField('Send') def validate_email(self, email): # 获取 Email email = User.query.filter_by(email=email.data).first() # 判断 邮箱是否存在 如果不存在 报错 if not email: raise ValidationError('Email not exists.') 在 route.py 页面设置 发用邮件验证界面 1234567@app.route(&#39;&#x2F;send_password_reset_request&#39;, methods&#x3D;[&quot;GET&quot;, &quot;POST&quot;])def send_password_reset_request(): # 判断是否是已经处于登录状态,如果是回到主界面 if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; PasswordResetRequestForm() return render_template(&#39;send_password_reset_request.html&#39;, form&#x3D;form) 通过加密发送邮件给用户，安全实现密码更改 (PyJWT 加密，flask-mail 发送邮件验证)12pip install PyJWTpip install flask-mail 在 model.py 下创建加密规则与解密验证规则 123456789101112import jwtdef generate_reset_password_token(self): # 将 token 与用户名 作为验证信息加密 传输 return jwt.encode(&#123;'id': self.id&#125;, current_app.config['SECRET_KEY'], algorithm=\"HS256\") def check_reset_password_token(self, token): # 验证是加密的 验证信息 是否正确，是否遭到篡改 try: data = jwt.decode(token, current_app.config['SECRET_KEY'], algorithm=[\"HS256\"]) return User.query.filter_by(id=data['id']).first() except: return 在 __init__.py 内部导入 flask-mail 123from flask_mail import Mail# mail 需要很多配置 可以百度 flask mail configmail &#x3D; Mail(app) 配置 mail 设置 config (在 config.py内配置) 123456789# Flask Gmail Config# 服务器 也可以用 qq 邮箱 smtp.qq.com (国内最好使用qq邮箱)MAIL_SERVER &#x3D; &#39;smtp.gmail.com&#39;# 端口 (不要使用默认端口 465 ，使用其他端口 25 或者其他的，否则会报错 smtplib.SMTPServerDisconnected: Connection unexpectedly closed)MAIL_PORT &#x3D; 25MAIL_USER_SSL &#x3D; True# 将 MAIL_USERNAME&#x2F;qq 写入环境变量,放入自己的 GMAIL&#x2F;qq 账号与 令牌 (GMAIL_PASSWORD，需要填入令牌)MAIL_USERNAME &#x3D; os.environ.get(&#39;GMAIL_USERNAME&#39;) or &#39;GMAIL_USERNAME&#39;MAIL_PASSWORD &#x3D; os.environ.get(&#39;GMAIL_PASSWORD&#39;) or &#39;GMAIL_PASSWORD&#39; 新建 email.py 页面 定义发送邮件 12345678910111213from flask import current_app, render_templatefrom flask_mail import Messagefrom app import mail def send_reset_password_mail(user, token): msg = Message(\"[Flask App] Reset Your Password!\", # 发送者邮箱，在 config.py 内定义的 邮箱 sender=current_app.config[\"MAIL_USERNAME\"], # 接受者邮箱 recipients=[user.email], html=render_template('reset_password_mail.html',user=user, token=token)) mail.send(message=msg) 在 route.py 内配置重设密码页面以及补全发送邮箱验证界面 1234567891011121314151617181920212223242526def send_password_reset_request(): if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; PasswordResetRequestForm() # 获取提交上来的注册数据，进行处理 if form.validate_on_submit(): email &#x3D; form.email.data user &#x3D; User.query.filter_by(email&#x3D;email).first() # token 作为参数加密放入链接发送给用户 token &#x3D; user.generate_reset_password_token() # 创建 email.py 发送给用户 加密 token send_reset_password_mail(user, token) # 建立 flash 提醒用户发送重设密码邮件成功 flash(&#39;Password reset requests mail is send, please check your mail.&#39;, category&#x3D;&#39;info&#39;) return render_template(&#39;send_password_reset_request.html&#39;, form&#x3D;form) @app.route(&#39;&#x2F;reset_password&#39;, methods&#x3D;[&quot;GET&quot;, &quot;POST&quot;])# 重设密码界面 def reset_password(): # 判断用户登录状态 if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; ResetPasswordForm() # 根据表单渲染 reset_password.html 页面 return render_template(&#39;reset_password.html&#39;, form&#x3D;form) 创建发送给用户的 重设密码邮件 界面 “reset_password_mail.html” 123456789101112&lt;p&gt;Dear &#123;&#123; user.username &#125;&#125;&lt;/p&gt;&lt;p&gt; To reset your password &lt;a href=\"&#123;&#123; url_for('reset_password', token=token, _external=True) &#125;&#125;\"&gt; click here! &lt;/a&gt;&lt;/p&gt;&lt;p&gt;Alternatively, you can paste the following link in your browser's address bar:&lt;/p&gt;&lt;p&gt;&#123;&#123; url_for('reset_password', token=token, _external=True) &#125;&#125;&lt;/p&gt;&lt;p&gt;If you have not requested a password reset simply ignore this message.&lt;/p&gt;&lt;p&gt;Sincerely,&lt;/p&gt;&lt;p&gt;Flask App&lt;/p&gt; 创建重置密码页面 (reset_password.html) 与注册页面类似 12345678910111213&#123;% extends 'base.html' %&#125;l&gt;&#123;% block app_content %&#125; &lt;h1&gt;Reset Your Password&lt;/h1&gt; &lt;br&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 完善 更改用户密码功能 。(route.py) 1234567891011121314151617181920# 将 &#39;&#x2F;reset_password&#39; 改为 &#39;&#x2F;reset_password&#x2F;&lt;token&gt;&#39; 获取传递过去的 token@app.route(&#39;&#x2F;reset_password&#x2F;&lt;token&gt;&#39;, methods&#x3D;[&quot;GET&quot;, &quot;POST&quot;])def reset_password(token): if current_user.is_authenticated: return redirect(url_for(&#39;index&#39;)) form &#x3D; ResetPasswordForm() # 获取表单数据 if form.validate_on_submit(): # 解密 token 获得用户名 user &#x3D; User.check_reset_password_token(token&#x3D;token) # 如果用户存在 if user: # 获取用户新更改的密码，传入数据库进行更新操作 user.password &#x3D; bcrypt.generate_password_hash(form.password.data) db.session.commit() flash(&#39;Your Password reset is done, You can login now use new Password.&#39;, category&#x3D;&#39;info&#39;) else: flash(&quot;The user is not exist&quot;, category&#x3D;&#39;info&#39;) return redirect(url_for(&#39;login&#39;)) return render_template(&#39;reset_password.html&#39;, form&#x3D;form) 为了方便，将 models.py 中的 验证密码改为 返回函数的静态方法，不需要实例化直接传参使用 12345678 @staticmethod def check_reset_password_token(token): # 验证是加密的 验证信息 是否正确，是否遭到篡改 try: data &#x3D; jwt.decode(token, current_app.config[&#39;SECRET_KEY&#39;], algorithm&#x3D;[&quot;HS256&quot;]) return User.query.filter_by(id&#x3D;data[&#39;id&#39;]).first()except: return 优化: 运用线程对发送邮件进行加速，使发送在后端进行，前端快速返回 (修改 email.py) 1234567891011121314151617181920from threading import Threadfrom flask import current_app, render_templatefrom flask_mail import Messagefrom app import mail, app def send_async_mail(app, msg): with app.app_context(): mail.send(msg) def send_reset_password_mail(user, token): msg = Message(\"[Flask App] Reset Your Password!\", sender=current_app.config[\"MAIL_USERNAME\"], recipients=[user.email], html=render_template('reset_password_mail.html',user=user, token=token)) # print(user.email, current_app.config[\"MAIL_USERNAME\"]) # mail.send(message=msg) # 调用线程在后端进行发送，前端快速进行页面更改 Thread(target=send_async_mail, args=(app, msg, )).start() 对 index 主页进行修改，实现一对多表格 (一个用户发送多个 Post Tweet) 修改 index.html，引入 form 表格 1234567891011&#123;% extends \"base.html\" %&#125;&#123;% block app_content %&#125; &lt;h1&gt;Hello, &#123;&#123; current_user.username &#125;&#125;&lt;/h1&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 在 form.py 内增加 表单数据 12345from wtforms import StringField, PasswordField, SubmitField, BooleanField, TextAreaFieldclass PortTweetForm(FlaskForm): # 文本框 text &#x3D; TextAreaField(&#39;Say Something ....&#39;, validators&#x3D;[DataRequired(), Length(min&#x3D;1, max&#x3D;40)]) submit &#x3D; SubmitField(&#39;Post Text&#39;) 删除旧的 app.db ，在 model.py 内 新建 Post 类用于存储发布的文本，并与 User 类中的数据库链接 1234567891011121314151617from datetime import datetimeclass User(db.Model, UserMixin): ... # 第一个 &#39;Post&#39; 对于 class Post ; backref 返回的信息;&#39;author&#39; 数据库中存储 Post 进入数据的名称; lazy&#x3D;True 如果不用就不连接 posts &#x3D; db.relationship(&#39;Post&#39;, backref&#x3D;db.backref(&#39;author&#39;, lazy&#x3D;True)) ...class Post(db.Model): id &#x3D; db.Column(db.Integer, primary_key&#x3D;True) body &#x3D; db.Column(db.String(140), nullable&#x3D;False) # 显示发布时间 timestamp &#x3D; db.Column(db.DateTime, default&#x3D;datetime.utcnow) # 连接数据库中得到 user.id user_id &#x3D; db.Column(db.Integer, db.ForeignKey(&#39;user.id&#39;), nullable&#x3D;False) def __repr__(self): return &#39;&lt;Post &#123;&#125;&gt;&#39;.format(self.body) 在 route.py 内 对 index 页面进行构造 1234567891011121314from app.models import User, Post@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) # 指定路由# 需要登录@login_requireddef index(): form &#x3D; PortTweetForm() if form.validate_on_submit(): body &#x3D; form.text.data # 将 post 发送到数据库 post &#x3D; Post(body&#x3D;body) current_user.posts.append(post) db.session.commit() flash(&#39;You have post a new tweet.&#39;, category&#x3D;&#39;success&#39;) return render_template(&#39;index.html&#39;, form&#x3D;form) 数据库的多对多关系 (用户关注与取关) 先定义 数据库中的 关注/取关 与 User 联系 (models.py) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 简单的示范性的 关注关系 (只包含关注者与被关注着)，复杂的需要建立 classfollowers &#x3D; db.Table(&quot;followers&quot;, db.Column(&quot;follower_id&quot;, db.Integer, db.ForeignKey(&#39;user.id&#39;)), db.Column(&quot;followed_id&quot;, db.Integer, db.ForeignKey(&#39;user.id&#39;)) )class User(db.Model, UserMixin): # nullable 非空 ; unique 不能重复 id &#x3D; db.Column(db.Integer, primary_key&#x3D;True) username &#x3D; db.Column(db.String(20), unique&#x3D;True, nullable&#x3D;False) password &#x3D; db.Column(db.String(20), nullable&#x3D;False) email &#x3D; db.Column(db.String(120), unique&#x3D;True, nullable&#x3D;False) # 第一个 &#39;Post&#39; 对于 class Post ; backref 返回的信息;&#39;author&#39; 数据库中存储 Post 进入数据的名称; lazy&#x3D;True 如果不用就不连接 posts &#x3D; db.relationship(&#39;Post&#39;, backref&#x3D;db.backref(&#39;author&#39;, lazy&#x3D;True)) # &#39;User&#39;: 关注者与被关注着链接是用户之间的连接; primaryjoin&#x3D;(followers.c.follower_id&#x3D;&#x3D;id) 左边的关注着与右边的关注者通过 id 相互连接 # 先正向连接，然后 backref 反向链接 followed &#x3D; db.relationship( &#39;User&#39;, secondary&#x3D;followers, primaryjoin&#x3D;(followers.c.follower_id &#x3D;&#x3D; id), secondaryjoin&#x3D;(followers.c.followed_id &#x3D;&#x3D; id), backref&#x3D;db.backref(&#39;followers&#39;, lazy&#x3D;True), lazy&#x3D;True ) def __repr__(self): return &#39;&lt;User %r&gt;&#39; % self.username def generate_reset_password_token(self): # 将 token 与用户名 作为验证信息加密 传输 return jwt.encode(&#123;&#39;id&#39;: self.id&#125;, current_app.config[&#39;SECRET_KEY&#39;], algorithm&#x3D;&quot;HS256&quot;) @staticmethod def check_reset_password_token(token): # 验证是加密的 验证信息 是否正确，是否遭到篡改 try: data &#x3D; jwt.decode(token, current_app.config[&#39;SECRET_KEY&#39;], algorithm&#x3D;[&quot;HS256&quot;]) return User.query.filter_by(id&#x3D;data[&#39;id&#39;]).first() except: return # 定义关注 def follow(self, user): if not self.is_following(user): self.followed.append(user) # 定义取关 def unfollow(self, user): if self.is_following(user): self.followed.remove(user) # 判断是否关注 def is_following(self, user): # 从 followed 找到当前已经关注的，如果 &gt;0 则已经关注 return self.followed.count(user) &gt; 0 对主页 index.html 进行修改 12345678910111213 &lt;div class=\"align-right\"&gt; &lt;div class=\"thumbnail text-center\"&gt; &lt;br&gt; &lt;img src=\"&#123;&#123; current_user.avatar_img &#125;&#125;\" alt=\"avatar\" width=\"100px\" &gt; &lt;div class=\"caption\"&gt; &lt;h3&gt;&#123;&#123; current_user.username &#125;&#125;&lt;/h3&gt; &lt;p&gt; &lt;a href=\"#\" class=\"btn btn-primary\" role=\"button\"&gt;&#123;&#123; n_followers &#125;&#125; followers&lt;/a&gt; &lt;a href=\"#\" class=\"btn btn-default\" role=\"button\"&gt;&#123;&#123; n_followed &#125;&#125; followed&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在 models.py User 数据库中加入默认头像 1234class User(db.Model, UserMixin): ... avatar_img &#x3D; db.Column(db.String(120), default&#x3D;&#39;.&#x2F;static&#x2F;asset&#x2F;test.jpg&#39;, nullable&#x3D;False) ... 在 route.py 中定义 index.html 中的 followers 与 followed 12345678@app.route(&#39;&#x2F;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) # 指定路由# 需要登录@login_requireddef index(): ... n_followers &#x3D; len(current_user.followers) n_followed &#x3D; len(current_user.followed) return render_template(&#39;index.html&#39;, form&#x3D;form, n_followers&#x3D;n_followers, n_followed&#x3D;n_followed) 在主页显示用户的发帖 (使用 bootstrap 的 Media heading) 在 index.html 中设置 Media heading 模块 123456789101112131415&#123;% for post in posts %&#125; &lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;a href=\"#\"&gt; # 头像 &lt;img src=\"&#123;&#123; post.author,avatar_img &#125;&#125;\" alt=\"avatar\" width=\"64px\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&#123;&#123; post.author.username &#125;&#125;&lt;/h4&gt; &lt;small class=\"text-muted\"&gt;&#123;&#123; post.timestamp &#125;&#125;&lt;/small&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; 在 route.py 中设置将 以倒序排列的 推文传入 index 12# 取得 发布的内容 以时间倒序来排列显示posts &#x3D; Post.query.order_by(Post.timestamp.desc()).all() 分页操作 (主要在 index.html 内进行修改判断，在 route.py 内稍微修改) route.py 定义 posts 便于 index.html 调用 12345# 取得 发布的内容 以时间倒序来排列显示 page &#x3D; request.args.get(&#39;page&#39;, 1, type&#x3D;int) # paginate(page, 2, False): 返回页数，每页两个推文，默认超出后不会报错 posts &#x3D; Post.query.order_by(Post.timestamp.desc()).paginate(page, 2, False) return render_template(&#39;index.html&#39;, form&#x3D;form, posts&#x3D;posts, n_followers&#x3D;n_followers, n_followed&#x3D;n_followed) index.html 内定义 页面页数的变换 (Flask request 库的学习) 123456789101112131415161718192021222324252627&lt;nav aria-label=\"Page navigation\"&gt; &lt;center&gt; &lt;ul class=\"pagination\"&gt; # 添加判断 &lt;li class=\"&#123;% if not posts.has_prev %&#125;disabled&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;&#123; url_for('index', page=posts.prev_num) &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo; Prev&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;# posts.iter_page() 以当前页为中心显示左右页数 #&#125; &#123;% for i in posts.iter_pages(right_current=3) %&#125; &#123;% if i %&#125; &#123;# 判断是当前页面然后颜色不同 为 active 样式 #&#125; &lt;li class=\"&#123;% if i == posts.page %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;&#123; url_for(\"index\", page=i) &#125;&#125;\"&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;...&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li class=\"&#123;% if not posts.has_next %&#125;disabled&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;&#123; url_for('index', page=posts.next_num) &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo; Next&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/center&gt;&lt;/nav&gt; 编辑用户个人界面和关注取关操作 由于考虑到用户界面可能与主界面有 图片等部分重叠，从 index.html 内截取 Post 部分放入新建的 post_content.html 内，在 index.html 内引用 123456789101112131415161718192021222324252627282930313233343536373839404142&#123;# 运用函数后返回的不是列表，需要 .Item 转换为列表 #&#125;&#123;% for post in posts.items %&#125; &lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;a href=\"&#123;&#123; url_for('user_page', username=post.author.username) &#125;&#125;\"&gt; &lt;img src=\"&#123;&#123; post.author.avatar_img &#125;&#125;\" alt=\"avatar\" width=\"64px\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&#123;&#123; post.author.username &#125;&#125;&lt;/h4&gt; &lt;small class=\"text-muted\"&gt;&#123;&#123; post.timestamp &#125;&#125;&lt;/small&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endfor %&#125;&#123;# 页面跳转#&#125;&lt;nav aria-label=\"Page navigation\"&gt; &lt;center&gt; &lt;ul class=\"pagination\"&gt; &lt;li class=\"&#123;% if not posts.has_prev %&#125;disabled&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;&#123; url_for('index', page=posts.prev_num) &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo; Prev&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;# posts.iter_page() 以当前页为中心显示左右页数 #&#125; &#123;% for i in posts.iter_pages(right_current=3) %&#125; &#123;% if i %&#125; &#123;# 判断是当前页面然后颜色不同 为 active 样式 #&#125; &lt;li class=\"&#123;% if i == posts.page %&#125;active&#123;% endif %&#125;\"&gt;&lt;a href=\"&#123;&#123; url_for(\"index\", page=i) &#125;&#125;\"&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;...&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li class=\"&#123;% if not posts.has_next %&#125;disabled&#123;% endif %&#125;\"&gt; &lt;a href=\"&#123;&#123; url_for('index', page=posts.next_num) &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo; Next&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/center&gt;&lt;/nav&gt; 在 route.py 内建立 个人信息，关注与取关 页面，并赋予功能 123456789101112131415161718192021222324252627282930313233343536@app.route(&#39;&#x2F;user_page&#x2F;&lt;username&gt;&#39;) @login_required def user_page(username): user &#x3D; User.query.filter_by(username&#x3D;username).first() if user: page &#x3D; request.args.get(&#39;page&#39;, 1, type&#x3D;int) posts &#x3D; Post.query.filter_by(user_id&#x3D;user.id).order_by(Post.timestamp.desc()).paginate(page, 2, False) return render_template(&#39;user_page.html&#39;, user&#x3D;user, posts&#x3D;posts) else: return &#39;404&#39; @app.route(&#39;&#x2F;follow&#x2F;&lt;username&gt;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) @login_required def follow(username): user &#x3D; User.query.filter_by(username&#x3D;username).first() if user: current_user.follow(user) db.session.commit() page &#x3D; request.args.get(&#39;page&#39;, 1, type&#x3D;int) posts &#x3D; Post.query.filter_by(user_id&#x3D;user.id).order_by(Post.timestamp.desc()).paginate(page, 2, False) return render_template(&#39;user_page.html&#39;, user&#x3D;user, posts&#x3D;posts) else: return &#39;404&#39; @app.route(&#39;&#x2F;unfollow&#x2F;&lt;username&gt;&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;]) @login_required def unfollow(username): user &#x3D; User.query.filter_by(username&#x3D;username).first() if user: current_user.unfollow(user) db.session.commit() page &#x3D; request.args.get(&#39;page&#39;, 1, type&#x3D;int) posts &#x3D; Post.query.filter_by(user_id&#x3D;user.id).order_by(Post.timestamp.desc()).paginate(page, 2, False) return render_template(&#39;user_page.html&#39;, user&#x3D;user, posts&#x3D;posts) else: return &#39;404&#39; 建立个人信息界面 user_page.html 123456789101112131415161718192021&#123;% extends 'base.html' %&#125;&#123;% block app_content %&#125; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;h1&gt;Hello, &#123;&#123; current_user.username &#125;&#125;&lt;/h1&gt; # 如果是用户正在观看自己的 个人信息，增加 填写信息 按钮 &#123;% if current_user == user %&#125; &lt;a href=\"#\"&gt;Edit Profile&lt;/a&gt; # 如果用户正在看其他人的页面，添加 关注与取关 按钮 &#123;% else %&#125; &#123;% if current_user.is_following(user) %&#125; &lt;a href=\"&#123;&#123; url_for(\"unfollow\", username=user.username) &#125;&#125;\"&gt;Unfollow&lt;/a&gt; &#123;% else %&#125; &lt;a href=\"&#123;&#123; url_for(\"follow\", username=user.username) &#125;&#125;\"&gt;Follow&lt;/a&gt; &#123;% endif %&#125; &#123;% endif %&#125; &lt;hr&gt; &#123;% include \"post_content.html\" %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; Flask 上传文件 (用来修改头像) 编写 上传文件 页面 edit_profile.html 12345678910111213&#123;% extends 'base.html' %&#125;&#123;% block app_content %&#125; &lt;h1&gt;Upload Your Avatar Image&lt;/h1&gt; &lt;br&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 建立 上传表单 12345# 上传文件使用 库from flask_wtf.file import FileField, FileRequiredclass UploadPhotoForm(FlaskForm): photo &#x3D;FileField(validators&#x3D;[FileRequired()]) submit &#x3D; SubmitField(&#39;Upload&#39;) 在用户信息界面将 Edit Profile 链接到 上传页面 1&lt;a href&#x3D;&quot;&#123;&#123; url_for(&quot;edit_profile&quot;) &#125;&#125;&quot;&gt;Edit Profile&lt;&#x2F;a&gt; 在 route.py 完善 上传页面配置 1234567891011121314151617181920212223import osfrom werkzeug.utils import secure_filename@app.route(&#39;&#x2F;edit_profile&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])def edit_profile(): form &#x3D; UploadPhotoForm() if form.validate_on_submit(): f &#x3D; form.photo.data # secure_filename 对用户上传的 软件名 进行再次包装，防止入侵 filename &#x3D; secure_filename(f.filename) if f.filename &#x3D;&#x3D; &quot;&quot;: flash(&quot;No selected file&quot;, category&#x3D;&quot;danger&quot;) return render_template(&quot;edit_profile.html&quot;, form&#x3D;form) # 如果文件名是允许的后缀，可以进行操作 if f and allowed_file(f.filename): # secure_filename 对用户上传的 软件名 进行再次包装，防止入侵 filename &#x3D; secure_filename(f.filename) # 定义上传图片保存位置 f.save(os.path.join(&#39;app&#39;, &#39;static&#39;, &#39;asset&#39;, filename)) # 将数据库中默认的头像转变为用户自定义头像 current_user.avatar_img &#x3D; &quot;&#x2F;static&#x2F;asset&#x2F;&quot; + filename db.session.commit() return redirect(url_for(&quot;user_page&quot;, username&#x3D;current_user.username)) return render_template(&quot;edit_profile.html&quot;, form&#x3D;form)","categories":[],"tags":[{"name":"Flask_Study","slug":"Flask-Study","permalink":"http://yoursite.com/tags/Flask-Study/"}]},{"title":"Flask_note1","slug":"Flask-note1","date":"2020-08-06T12:34:12.000Z","updated":"2020-08-08T01:38:54.969Z","comments":true,"path":"2020/08/06/flask-note1/","link":"","permalink":"http://yoursite.com/2020/08/06/flask-note1/","excerpt":"","text":"根据Youtube上视频学习 Flask 框架学习通过 Pycharm 创建新的工程，创建 Falsk 项目生成的 Falsk 项目中带有一个 app.py 文件 1234567891011121314from flask import Flaskapp = Flask(__name__)@app.route('/') # 指定路由: '/' 根路由def hello_world(): return 'Hello World!'if __name__ == '__main__':# debug 默认为 False, debug=True 让开发变得友好，在修改App 文件后，刷新立即可以在本地服务上看到变化# windows 可能做不到# port 默认端口 5000 ,port=6333 更改端口# host 默认为本地 127.0.0.1, host='0.0.0.0'面向局域网都可以访问 app.run(debug=True, port=6333, host='0.0.0.0') 进行简单修改，对页面进行布局，渲染 基础：在 return 内增加 HTML 类型文件 1234567891011from flask import Flask app = Flask(__name__) @app.route('/') # 指定路由def hello_world(): # 更改 return 内为 HTML 文件 return '&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Flask&lt;/p&gt;'if __name__ == '__main__': app.run(debug=True) 优化: 在工程下建立文件夹 “templates” (现在版本已经实现自建),”templates” 中建立 “index.html” 文件在 app.py 内引进 Flask_note1 渲染 12345678910111213from flask import Flask, render_templateapp = Flask(__name__) @app.route('/') # 指定路由def hello_world(): # title=title 将 title 传入 index 作为标题 # &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; # 写在 &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt; 内，也可以调用 填入 'Flask Web test' title = 'Flask Web test' return render_template('index.html', title=title) if __name__ == '__main__': app.run(debug=True) 更高级渲染 (条件判断、循环) 条件判断：如果 title 为空则默认 标题为 ‘Falsk App’ 12345&#123;% if title %&#125; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;title&gt;&#123;% else %&#125; &lt;title&gt;Falsk App&lt;&#x2F;title&gt;&#123;% endif %&#125; 123def hello_world():return render_template('index.html', ) + 循环 建立三个 &lt;p&gt;&lt;/p&gt; ![](https://cdn.jsdelivr.net/gh/Forgotten-Forever/BlogImages/images/Flask_p.png) 123&#123;% for p in data %&#125;&lt;p&gt;&#123;&#123; p &#125;&#125;&lt;&#x2F;p&gt;&#123;% endfor %&#125; 12345678910def hello_world(): title &#x3D; &#39;Flask Web test&#39; paragraphs &#x3D; [ &quot;Selection 1&quot;, &quot;Selection 2&quot;, &quot;Selection 3&quot; ] return render_template(&#39;index.html&#39;, title&#x3D;title, data&#x3D;paragraphs) 模板继承和引用 模板的继承 在 “templates” 下建立 “base.html” 作为模板 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &#123;% if title %&#125; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &#123;% else %&#125; &lt;title&gt;Falsk App&lt;/title&gt; &#123;% endif %&#125;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;a href=\"/\"&gt;Flask App&lt;/a&gt; &lt;/h3&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt; 在 “index.html” 中继承 “base.html” 模板 1&#123;% extends 'base.html' %&#125; 在 “index.html” 继承模板后，写入属于自己的东西 在 “base.html” 文件相应位置写下 block 定义此自定义模块名称为 content 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &#123;% if title %&#125; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &#123;% else %&#125; &lt;title&gt;Falsk App&lt;/title&gt; &#123;% endif %&#125;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;a href=\"/\"&gt;Flask App&lt;/a&gt; &lt;/h3&gt;&lt;hr&gt;&#123;% block content %&#125; &lt;p&gt;Test&lt;/p&gt;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 在 “index.html” 文件中 引用并更改 123&#123;% block content%&#125; &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125; 模板的引用 (导入，对于会在很多地方用到的文件引用)模板模块中定义的会被，引用模板的模块重写掉,如果没有引用则会显示模板模块内的内容，常规情况下默认为空可以把每一个模块(导航栏，报头)新建一个 html 文件 (一个个小组件) 并引入继承到模块 “navbar.html” 自定义报头 12&lt;h3&gt;&lt;a href=\"/\"&gt;Flask App&lt;/a&gt; &lt;/h3&gt;&lt;hr&gt; “base.html” 引入 1&#123;% include 'navbar.html' %&#125; 了解 flask-bootstrap (框架中已经定义好许多 class 的命名、风格) 使界面布局更加好看，将布局封装到Flask的插件可以通过定义 class 的值定义组件位于 页面中的位置Flask—bootstrap 重点学习官网 123456pip install flask-bootstrapfrom flask import Flask, render_templatefrom flask_bootstrap import Bootstrap app &#x3D; Flask(__name__)bootstrap &#x3D; Bootstrap(app) HTML 中引用 bootstrap 从 bootstrap 的 base.html 中的库内引用 Boot-straap 官方提供的模板 123456789&#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125;This is an example page&#123;% endblock %&#125;&#123;% block navbar %&#125;&#123;# &#123;% include 'navbar.html' %&#125;#&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;Hello, Bootstrap&lt;/h1&gt;&#123;% endblock %&#125; 重写 bootstrap 里面的类，使之满足自己的需求在 “External Libraries -&gt; site-packages -&gt; flask_bootstrap -&gt; templates -&gt; bootstrap” 内修改内置的各种页面，或者，复制出来在自己的页面中引用修改 创建新的页面 (以点击形式进入新的连接) app.py1234@app.route(&#39;&#x2F;register&#39;)def register(): # 转到 regist.html 页面 return render_template(&#39;register.html&#39;) register.html引用 “base.html” 模板 12345&#123;% extends &#39;base.html&#39; %&#125;&#123;% block app_content %&#125; &lt;h1&gt;Register Now&lt;&#x2F;h1&gt;&#123;% endblock %&#125; base.html引用 navbar.html 页面12345678910&#123;% block navbar %&#125; &#123;% include &#39;navbar.html&#39; %&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;div class&#x3D;&quot;container&quot;&gt; &#123;% block app_content %&#125; &#123;% endblock %&#125; &lt;&#x2F;div&gt;&#123;% endblock %&#125; navbar.html.html设置页面共有文件1234567&lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt; &#123;# 只有当 request.endpoint 是 register 时 才是 active,否则是其他 #&#125; &lt;li class&#x3D;&quot;&#123;% if request.endpoint &#x3D;&#x3D; &#39;register&#39; %&#125;active&#123;% endif %&#125;&quot;&gt; &#123;# 当点击 Regist 时 ，转到 register() 函数 ，由 render_template(register.html) 转到 register.html #&#125; &lt;a href&#x3D;&quot;&#123;&#123; url_for(&#39;register&#39;) &#125;&#125;&quot;&gt;Register&lt;&#x2F;a&gt; &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; Flask 连接数据库、 Flask mine 找回密码、Flask 登录 (采用关系数据库，Flask提供flask-sqlalchemy连接数据库)flask_sqlalchemy 重点学习官方文档地址 123456789from flask import Flask, render_templatefrom flask_bootstrap import Bootstrapfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)# 给出的是本地的 SQLite 数据库链接地址，可以改为 MySQL 等，只需要改变app.config['SQLALCHEMY_DATABASE_URI'] 值app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'db = SQLAlchemy(app)bootstrap = Bootstrap(app) 为了方便管理，建议将 SQL 配置新建一个 config.py 用于整理配置文件123456789import os basedir = os.path.abspath(os.path.dirname(__file__)) class Config(object): # 如果找到 SQLite 路径就是用，如果没有找到就新建一个 SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \"sqlite:///\" + os.path.join(basedir, 'app.db') SQLALCHEMY_TRACK_MODIFICATIONS = False 建立 models.py 存放构建数据库的结构 123456789101112from app import db class User(db.Model): # nullable 非空 ; unique 不能重复,出现相同就报错 id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(20), unique=True, nullable=False) password = db.Column(db.String(20), nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return '&lt;User %r&gt;' % self.username 要创建初始数据库，需要在 “Python Console” (3、4、5都在 Python Console 中执行) 导入对象并运行 “SQLAlchemy.create_all” 方法 12from app.models import dbdb.create_all() 创建用户用于测试 123456from app.models import Userfrom app.models import dbuser1 = User(username=\"\", password=\"\", email=\"\")# 添加进数据库，并运行指令db.session.add(user1)db.session.commit() 访问数据库中数据 123456from app.models import Useru = User.query.all()# [&lt;User 'Jack'&gt;]U = u[0]U.password# 'pwd' FlaskWTF 创建 Flask 中的表单，基本包含所有表单123下载:1. pip install flask-WTF2. pip install wtforms FlaskWTF 重点官网主页Flask Bootstrap 与 其他组件联系内容包括 WTF 创建表单 forms.py (用于注册，规定注册页面的内容) 1234567891011121314# FlaskForm 主要负责整合 wtforms 的内容、类型 以及包装from flask_wtf import FlaskForm# 定义数据类型字符串，密码，提交按钮from wtforms import StringField, PasswordField, SubmitField# validators 验证者：需要的数据、数据范围Length(min=6, max=20)、Email、验证密码 EqualTo('password')from wtforms.validators import DataRequired, Length, Email, EqualTo class RegisterForm(FlaskForm): username = StringField('Username', validators=[DataRequired(), Length(min=6, max=20)]) email = StringField('Email', validators=[DataRequired(), Email()]) password = PasswordField('Password', validators=[DataRequired(), Length(min=8, max=20)]) confirm = PasswordField('Repeat Password', validators=[DataRequired(), EqualTo('password')]) submit = SubmitField('Register') 使用 Email类型 时需要下载支持 1pip install email_validator 使用 FlaskWTF 需要秘钥设置， CSRF token 验证 每次随机生成 在 config.py 内设置 12 # SECRET_KEY 秘钥为路径内或者 字符串 &#39;A-VERY-LONG-SECRET&#39; 可以随意设置，主要为了防止跨网站攻击SECRET_KEY &#x3D; os.environ.get(&#39;SECRET_KEY&#39;) or &#39;A-VERY-LONG-SECRET&#39; 在 app.py 主页设置 1app.secret_key &#x3D; &#39;123456&#39; 定义 app.py 内注册页面1234567891011121314151617181920212223from flask import Flask, render_template, request, url_forfrom flask_bootstrap import Bootstrapfrom flask_sqlalchemy import SQLAlchemy from config import Config# 引用 form 内的 注册表单 RegisterFormfrom app.forms import RegisterForm app = Flask(__name__)db = SQLAlchemy(app)bootstrap = Bootstrap(app) app.config.from_object(Config)# 设置 传递数据的方法为 \"GET\" 与 \"POST\"@app.route('/register', methods=['GET', 'POST'])def register(): # 调用 RegisterForm 表单定义 form = RegisterForm() # 定义如果点击后 pass if form.validate_on_submit(): pass # 将表单传入 register,html return render_template('register.html', form=form) 定义 “register.html” : 引用 bootstrap 内的 wtf.html 内容WTF 内部包含 表单提交的各种报错，验证等12345678910111213141516&#123;% extends 'base.html' %&#125;&#123;% block app_content %&#125; &lt;h1&gt;Register Now&lt;/h1&gt; &lt;br&gt; &lt;div class=\"row\"&gt; &#123;# col-md-6 表单大小 #&#125; &lt;div class=\"col-md-6\"&gt; &#123;# 引用 bootstrap 内的 wtf.html 内容 #&#125; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;# 重点 一句话获取表单 form.py 的设置,快速完成表单，而无需进行大量的微调 #&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 额外: 人机验证 RECAPTCHA PUBLIC KEY 验证秘钥，验证是否为机器 forms.py 添加验证 12from flask_wtf import FlaskForm, RecaptchaFieldrecaptcha &#x3D; RecaptchaField() config.py 注册秘钥 123 # RECAPTCHA PUBLIC KEY 验证秘钥，验证是否为机器人RECAPTCHA_PUBLIC_KEY &#x3D; os.environ.get(&#39;RECAPTCHA_PUBLIC_KEY&#39;) or &#39;A-VERY-LONG-PUBLIC-KEY&#39; RECAPTCHA_PRIVATE_KEY &#x3D; os.environ.get(&#39;RECAPTCHA_PRIVATE_KEY&#39;) or &#39;A-VERY-LONG-PRIVATE_KEY&#39; 遇到报错 “需要网站所有者处理的错误：网站密钥无效”,需要自行注册页面 Flask-Bcrypt 加密数据项 ，在服务端处理表单存入数据库1pip install flask-bcrypt 加密数据项 “flask-bcrypy” 中的 “Bcrypy” 模块, 传入数据库 为了避免与 congig.py 内的引用构成 bug 新建 名为”app” 的 package 将除了数据库、config.py移入, 将 app.py 分为 init.py 与 route.py，在外部创建与 config.py 同级的 run.py __init__.py 1234567891011121314151617from flask import Flaskfrom flask_bootstrap import Bootstrapfrom flask_sqlalchemy import SQLAlchemy# 调用模块from flask_bcrypt import Bcrypt from config import Config app = Flask(__name__)db = SQLAlchemy(app)# 定义模块bcrypt = Bcrypt(app)bootstrap = Bootstrap(app) app.config.from_object(Config)from app.route import * route.py 12345678910111213141516171819202122232425262728from flask import render_template, flash from app import app, bcrypt, dbfrom app.forms import RegisterFormfrom app.models import User @app.route('/') # 指定路由def index(): return render_template('index.html') @app.route('/register', methods=['GET', 'POST'])def register(): form = RegisterForm() # 获取提交上来的注册数据，进行处理 if form.validate_on_submit(): username = form.username.data email = form.email.data # 变种hash加密,相同密码生成值也不同 password = bcrypt.generate_password_hash(form.password.data) # 传入数据库内 user = User(username=username, email=email, password=password) db.session.add(user) db.session.commit() # 检查产生密码与hash 是否对应正确 # bcrypt.check_password_hash(hash, password) return render_template('register.html', form=form) run.py 1234from app import app if __name__ == '__main__': app.run(debug=True) 在设置 “models.py” 数据库时，设置 “unique=True 不能重复”，遇见重复的就会报错，需要写函数来辅助判断用户名和密码是否在数据库中，然后给与提示 forms.py 判断是否在数据库中重复，如果在给与报错 1234567891011from wtforms.validators import DataRequired, Length, Email, EqualTo, ValidationErrorclass RegisterForm(FlaskForm): def validate_username(self, username): user &#x3D; User.query.filter_by(username&#x3D;username.data).first() if user: raise ValidationError(&#39;Username already token, please choose another one.&#39;) def validate_email(self, email): email &#x3D; User.query.filter_by(email&#x3D;email.data).first() if email: raise ValidationError(&#39;Email already token, please choose another one.&#39;) route.py (flash提示注册成功，并跳转页面) 12345678910111213141516171819202122232425262728293031from flask import render_template, flash, redirect, url_for from app import app, bcrypt, db from app.forms import RegisterForm from app.models import User @app.route('/') # 指定路由def index(): return render_template('index.html') @app.route('/register', methods=['GET', 'POST'])def register(): form = RegisterForm() # 获取提交上来的注册数据，进行处理 if form.validate_on_submit(): username = form.username.data email = form.email.data # 变种hash加密,相同密码生成值也不同 password = bcrypt.generate_password_hash(form.password.data) user = User(username=username, email=email, password=password) db.session.add(user) db.session.commit() # flash 提示 \"用户注册成功\"，提示信息为 \"success\" 样式 flash('Congrats registration success', category='success') # 提示后转至 index.html 页面 return redirect(url_for('index')) # 检查产生密码与hash 是否对应正确 # bcrypt.check_password_hash(hash, password) return render_template('register.html', form=form) base.html (修改 base.html 页面，确保 flash 成功显示在页面上) 123456789101112131415161718192021222324&#123;% block content %&#125; &lt;div class=\"container\"&gt; &#123;# 提示框 #&#125; &lt;div class=\"row\"&gt; &#123;# 页面大小 #&#125; &lt;div class=\"col-lg-6\"&gt; &#123;# 判断与循环 #&#125; &#123;% with messages = get_flashed_messages(with_categories=True) %&#125; &#123;% if messages %&#125; &#123;% for category, message in messages %&#125; &lt;div class=\"alert alert-&#123;&#123; category &#125;&#125;\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &#123;% endwith %&#125; &lt;/div&gt; &lt;/div&gt; &#123;# 在 app_content 注册 上添加 注册成功 提示 #&#125; &#123;% block app_content %&#125; &#123;% endblock %&#125; &lt;/div&gt;&#123;% endblock %&#125; Flask-login 用户登录包，包含很多用于登录、登出的函数pip install flask-login 在 __init__.py 内引入 flask-login 包，并进行设置 1234567from flask_login import LoginManager# 登录界面的位置login.login_view &#x3D; &#39;login&#39;# 提示 &quot;You must login to access the page&quot; 提示框格式为 &quot;info&quot;login.login_message &#x3D; &quot;You must login to access the page&quot;login.login_message_category &#x3D; &quot;info&quot; 新建 login.html 登录页面，在 forms.py 下 新建 Login 函数，构造 登录需要的部件 12345678910111213&#123;% extends 'base.html' %&#125;&#123;% block app_content %&#125; &lt;h1&gt;Login In&lt;/h1&gt; &lt;br&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &#123;% import 'bootstrap/wtf.html' as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 123456from wtforms import StringField, PasswordField, SubmitField, BooleanFieldclass LoginForm(FlaskForm): username &#x3D; StringField(&#39;Username&#39;, validators&#x3D;[DataRequired(), Length(min&#x3D;6, max&#x3D;20)]) password &#x3D; PasswordField(&#39;Password&#39;, validators&#x3D;[DataRequired(), Length(min&#x3D;8, max&#x3D;20)]) remember &#x3D; BooleanField(&#39;Remember&#39;) submit &#x3D; SubmitField(&#39;Sign In&#39;) 修改 navbar.html 在主页面新增 “Login” 、”Logout” 选项框， 增加判断项，在登录后只显示 “Logout” 选项，未登录时显示 “Login” 与 “Register” 选项， 修改 主页面 (index.html) 显示为 Hello, 123456789101112131415161718&lt;ul class&#x3D;&quot;nav navbar-nav navbar-right&quot;&gt; &#123;# 判断是否处于登录状态，current_user.is_authenticated 获取登录状态 #&#125; &#123;% if not current_user.is_authenticated %&#125; &#123;# 登录界面 #&#125; &lt;li class&#x3D;&quot;&#123;% if request.endpoint &#x3D;&#x3D; &#39;login&#39; %&#125;active&#123;% endif %&#125;&quot;&gt; &lt;a href&#x3D;&quot;&#123;&#123; url_for(&#39;login&#39;) &#125;&#125;&quot;&gt;Login In&lt;&#x2F;a&gt; &lt;&#x2F;li&gt; &#123;# 只有当 request.endpoint 是 index 时 才是 active,否则是其他 #&#125; &lt;li class&#x3D;&quot;&#123;% if request.endpoint &#x3D;&#x3D; &#39;register&#39; %&#125;active&#123;% endif %&#125;&quot;&gt; &lt;a href&#x3D;&quot;&#123;&#123; url_for(&#39;register&#39;) &#125;&#125;&quot;&gt;Register&lt;&#x2F;a&gt; &lt;&#x2F;li&gt; &#123;% else %&#125; &#123;# 登出界面 #&#125; &lt;li class&#x3D;&quot;&#123;% if request.endpoint &#x3D;&#x3D; &#39;logout&#39; %&#125;active&#123;% endif %&#125;&quot;&gt; &lt;a href&#x3D;&quot;&#123;&#123; url_for(&#39;logout&#39;) &#125;&#125;&quot;&gt;Logout&lt;&#x2F;a&gt; &lt;&#x2F;li&gt; &#123;% endif %&#125; &lt;&#x2F;ul&gt; 12345&#123;% extends \"base.html\" %&#125;&#123;% block app_content %&#125;&lt;h1&gt;Hello, &#123;&#123; current_user.username &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125; 修改数据库设置 model.py，删除数据库重新构建数据库结构 12345678910111213141516171819202122# 引用 UserMinxinfrom flask_login import UserMixin# 从 app 包的 __init__.py 引用 login from app import db, login @login.user_loader# 获取登录用户的 iddef load_user(user_id): return User.query.filter_by(id=user_id).first() class User(db.Model, UserMixin): # nullable 非空 ; unique 不能重复 id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(20), unique=True, nullable=False) password = db.Column(db.String(20), nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return '&lt;User %r&gt;' % self.username 重构数据库: 在 &quot;Python Console&quot; 内重置数据库 12from app.models import dbdb.create_all() 设置 route.py 为登录方法进行实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from flask import render_template, flash, redirect, url_for, request# 从登录模块引入所需的方法from flask_login import login_user, login_required, current_user, logout_userfrom app import app, bcrypt, db# 从 form.py 内引入 注册表格与登录表格from app.forms import RegisterForm, LoginFormfrom app.models import User @app.route('/') # 指定路由# 需要登录@login_requireddef index(): return render_template('index.html') @app.route('/register', methods=['GET', 'POST'])def register(): # 判断是否是已经处于登录状态,如果是回到主界面 if current_user.is_authenticated: return redirect(url_for('index')) form = RegisterForm() # 获取提交上来的注册数据，进行处理 if form.validate_on_submit(): username = form.username.data email = form.email.data # 变种hash加密,相同密码生成值也不同 password = bcrypt.generate_password_hash(form.password.data) user = User(username=username, email=email, password=password) db.session.add(user) db.session.commit() flash('Congrats registration success', category='success') return redirect(url_for('index')) # 检查产生密码与hash 是否对应正确 # bcrypt.check_password_hash(hash, password) return render_template('register.html', form=form) # 设置登录函数、登录页面、登录方法@app.route('/login', methods=['GET', 'POST'])def login(): # 判断是否是已经处于登录状态,如果是回到主界面 if current_user.is_authenticated: return redirect(url_for('index')) # 获取 登录表格 form = LoginForm() # 如果调交上来的数据不为空 if form.validate_on_submit(): username = form.username.data # 获取密码，检查密码是否与数据库中匹配 password = form.password.data remember = form.remember.data # 根据输入用户名找到数据库中用户信息 user = User.query.filter_by(username=username).first() # 如果用户存在且密码对应正确 if user and bcrypt.check_password_hash(user.password, password): # 设置是否记住登录信息单选框 login_user(user, remember=remember) # 返回登录成功信息 flash(\"login success\", category='info') # http://127.0.0.1:5000/login?next=%2F 由 next 决定接下来进入的页面 if request.args.get('next'): next_page = request.args.get('next') return redirect(next_page) return redirect(url_for('index')) # 如果用户不岑在或者密码错误，flash 出错误 flash(\"User not exists or password not match\", category='danger') return render_template('login.html', form=form) # 设置登出函数、页面@app.route('/logout')def logout(): # 直接引用 flask_login 模块中的 logout_user() logout_user() # 登出后返回登录页面 return redirect(url_for('login'))","categories":[],"tags":[{"name":"Flask_Study","slug":"Flask-Study","permalink":"http://yoursite.com/tags/Flask-Study/"}]},{"title":"Windows下 Git 因移动文件夹导致的问题及解决","slug":"Save-git-problem","date":"2020-08-05T11:37:31.000Z","updated":"2020-08-05T12:33:26.921Z","comments":true,"path":"2020/08/05/save-git-problem/","link":"","permalink":"http://yoursite.com/2020/08/05/save-git-problem/","excerpt":"","text":"Git 因移动文件夹导致更新后不是覆盖原版本而是在重新创建在原路径下，以及鼠标右键快捷菜单中的Git Bash Here 与 Git GUI Here无法使用的问题解决方法 某年某月某日为了方便管理计算机下的软件，我对大部分软件进行了”搬家”，在对软件”搬家”的过程中 Git 产生了一些问题，我花费了半天时间对出现的比较重要的问题进行一点总结。 必须做的事 : 在直接移动文件夹后一定要记得在环境变量中更改所有与 Git 有关的环境变量至现在路径。 问题 1 : 鼠标右键快捷菜单中的Git Bash Here 与 Git GUI Here失去图标，以及无法使用 解决 : Windows 系统下鼠标右键快捷菜单的图标以及功能都与注册表有关。 打开注册表编辑器，在 \\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\git_gui\\command 与\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\git_shell\\command 下修改Icon 数据为 目前 git_gui.exe 的路径 (&quot;E:\\GitHup\\Git\\cmd\\git-gui.exe&quot; &quot;--working-dir&quot; &quot;%v.&quot;) 与 git_shell.exe 路径 (&quot;E:\\GitHup\\Git\\git-bash.exe&quot; &quot;--cd=%v.&quot;) ,之后 鼠标右键快捷菜单的图标已经恢复，但功能仍未恢复 继续在注册表编辑器中\\HKEY_CLASSES_ROOT\\Directory\\shell\\git_gui\\command与\\HKEY_CLASSES_ROOT\\Directory\\shell\\git_gui\\command下修改 数据为目前 git_gui.exe 的路径 (&quot;E:\\GitHup\\Git\\cmd\\git-gui.exe&quot; &quot;--working-dir&quot; &quot;%1&quot;) 与 git_shell.exe 路径 (&quot;E:\\GitHup\\Git\\git-bash.exe&quot; &quot;--cd=%1&quot;)，然后鼠标右键快捷菜单中图标也可以恢复 部分没有立刻恢复可能需要重启计算机 问题 2 : Git 因移动文件夹导致更新后不是覆盖原版本而是在重新创建在原路径下 解决 : 这个我的办法比较笨，我在注册表 Ctrl + F 查找所有Git 的数据以及注册文件, 然后进行修改为现在文件路径 (对于路径后的东西可以不管) 对于移动后可能出现的其他问题，查看 Git 的全局变量寻找没改过的路径进行修改 123路径： Git -&gt; etc -&gt; gitconfig 以记事本打开Git -&gt; mingw64 -&gt; etc -&gt; gitconfig 以记事本打开 分别修改内部 git 路径。 纯属在百度上搜不到类似问题的解决，又由于自身 git 之前使用不善导致 git 内部许多东西都不想删掉，然后需要更新 git 才摸索出来这种办法","categories":[],"tags":[{"name":"Windows problem","slug":"Windows-problem","permalink":"http://yoursite.com/tags/Windows-problem/"}]},{"title":"pyecharts-Map","slug":"pyecharts-Map","date":"2020-08-03T00:45:27.000Z","updated":"2020-08-03T01:03:53.758Z","comments":true,"path":"2020/08/03/pyecharts-map/","link":"","permalink":"http://yoursite.com/2020/08/03/pyecharts-map/","excerpt":"","text":"pyecharts_Map全部来自于官方文档，主要用于方便自己查找 Map：地图 1234567891011121314from pyecharts.charts import Mapfrom pyecharts.faker import Fakerimport pyecharts.options as optsdata = [list[z] for z in zip(False.guangdong_city, Faker.values())]c = ( Map() .add(series_name=\"\", data_pair=data, maptype=\"广东\") .set_global_opts( title_opts=opts.TitleOpts(title=\"主标题\"), visualmap_opts=opts.VisualMapOpts(max_=200, is_piecewise=True) ) .render('xxx.html')) .add() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 数据项 (坐标点名称，坐标点值) data_pair: types.Sequence[types.Union[types.Sequence, opts.MapItem, dict]], # 地图类型，具体参考 pyecharts.datasets.map_filenames.json 文件 maptype: str &#x3D; &quot;china&quot;, # 是否选中图例 is_selected: bool &#x3D; True, # 是否开启鼠标缩放和平移漫游。 is_roam: bool &#x3D; True, # 当前视角的中心点，用经纬度表示 center: Optional[Sequence] &#x3D; None, # 当前视角的缩放比例。 zoom: Optional[Numeric] &#x3D; 1, # 自定义地区的名称映射 name_map: Optional[dict] &#x3D; None, # 标记图形形状 symbol: Optional[str] &#x3D; None, # 是否显示标记图形 is_map_symbol_show: bool &#x3D; True, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(), # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None, # 高亮标签配置项，参考 &#96;series_options.LabelOpts&#96; emphasis_label_opts: Union[opts.LabelOpts, dict, None] &#x3D; None, # 高亮图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; emphasis_itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None,) MapItem: 地图数据项 12345678910111213141516171819class MapItem( # 数据所对应的地图区域的名称，例如 &#39;广东&#39;，&#39;浙江&#39;。 name: Optional[str] &#x3D; None, # 该区域的数据值。 value: Optional[Numeric] &#x3D; None, # 该区域是否选中。 is_selected: bool &#x3D; False, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[LabelOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[TooltipOpts, dict, None] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pyecharts-WordCloud","slug":"pyecharts-WordCloud","date":"2020-08-02T08:07:23.000Z","updated":"2020-08-02T08:19:00.920Z","comments":true,"path":"2020/08/02/pyecharts-wordcloud/","link":"","permalink":"http://yoursite.com/2020/08/02/pyecharts-wordcloud/","excerpt":"","text":"pyecharts_WordCloud全部来自于官方文档，主要用于方便自己查找 WordCloud：词云图12345678910111213141516from pyecharts.charts import WordCloudimport pyecharts.options as optsword = [ (\"花鸟市场\", 1446), (\"汽车\", 928), ...] c = (WordCloud() .add(series_name='', data_pair=word, word_size_range=[], mask_image='', textstyle_opts = opts.TextStyleOpts(font_family='cursive') ) .set_global_opts(title_opts=opts.TitleOpts(title='主标题')) .render('xxx.html')) .add()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据项，[(word1, count1), (word2, count2)] data_pair: Sequence, # 词云图轮廓，有 &#39;circle&#39;, &#39;cardioid&#39;, &#39;diamond&#39;, &#39;triangle-forward&#39;, &#39;triangle&#39;, &#39;pentagon&#39;, &#39;star&#39; 可选 shape: str &#x3D; &quot;circle&quot;, # 自定义的图片（目前支持 jpg, jpeg, png, ico 的格式，其他的图片格式待测试） # 该参数支持： # 1、 base64 （需要补充 data 头）； # 2、本地文件路径（相对或者绝对路径都可以） # 注：如果使用了 mask_image 之后第一次渲染会出现空白的情况，再刷新一次就可以了（Echarts 的问题） # Echarts Issue: https:&#x2F;&#x2F;github.com&#x2F;ecomfe&#x2F;echarts-wordcloud&#x2F;issues&#x2F;74 mask_image: types.Optional[str] &#x3D; None, # 单词间隔 word_gap: Numeric &#x3D; 20, # 单词字体大小范围 word_size_range&#x3D;None, # 旋转单词角度 rotate_step: Numeric &#x3D; 45, # 距离左侧的距离 pos_left: types.Optional[str] &#x3D; None, # 距离顶部的距离 pos_top: types.Optional[str] &#x3D; None, # 距离右侧的距离 pos_right: types.Optional[str] &#x3D; None, # 距离底部的距离 pos_bottom: types.Optional[str] &#x3D; None, # 词云图的宽度 width: types.Optional[str] &#x3D; None, # 词云图的高度 height: types.Optional[str] &#x3D; None, # 允许词云图的数据展示在画布范围之外 is_draw_out_of_bound: bool &#x3D; False, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 词云图文字的配置 textstyle_opts: types.TextStyle &#x3D; None, # 词云图文字阴影的范围 emphasis_shadow_blur: types.Optional[types.Numeric] &#x3D; None, # 词云图文字阴影的颜色 emphasis_shadow_color: types.Optional[str] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pyecharts-Pie","slug":"pyecharts-Pie","date":"2020-08-01T02:07:43.000Z","updated":"2020-08-01T02:13:15.003Z","comments":true,"path":"2020/08/01/pyecharts-pie/","link":"","permalink":"http://yoursite.com/2020/08/01/pyecharts-pie/","excerpt":"","text":"pyecharts_Pie全部来自于官方文档，主要用于方便自己查找 Pie：饼图123456789101112131415161718from pyecharts.charts import Pieimport pyecharts.options as opts# .fake 伪造数据生成器，具体看内部代码from pyecharts.faker import Faker# 生成多维数组 eg:[['周一', 127], ['周二', 111], ['周三', 61], ['周四', 94], ['周五', 93], ['周六', 51], ['周日', 47]]data=[list(z) for z in zip(Faker.choose(), Faker.values())]# 颜色列表，与 data 中数据一一对应 color = []c = ( Pie() .add(series_name='', data_pair=data) .set_colors(color) .set_global_opts(title_opts=opts.TitleOpts(title=\"主标题\")) # 生成 饼图外标 \"周一: 127\" .set_series_opts(label_opts=opts.LabelOpts(formatter=\"&#123;b&#125;:&#123;c&#125;\")) .render('xxx.html')) .add() 1234567891011121314151617181920212223242526272829303132333435363738def add( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据项，格式为 [(key1, value1), (key2, value2)] data_pair: types.Sequence[types.Union[types.Sequence, opts.PieItem, dict]], # 系列 label 颜色 color: Optional[str] &#x3D; None, # 饼图的半径，数组的第一项是内半径，第二项是外半径 # 默认设置成百分比，相对于容器高宽中较小的一项的一半 radius: Optional[Sequence] &#x3D; None, # 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标 # 默认设置成百分比，设置成百分比时第一项是相对于容器宽度，第二项是相对于容器高度 center: Optional[Sequence] &#x3D; None, # 是否展示成南丁格尔图，通过半径区分数据大小，有&#39;radius&#39;和&#39;area&#39;两种模式。 # radius：扇区圆心角展现数据的百分比，半径展现数据的大小 # area：所有扇区圆心角相同，仅通过半径展现数据大小 rosetype: Optional[str] &#x3D; None, # 饼图的扇区是否是顺时针排布。 is_clockwise: bool &#x3D; True, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(), # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None, # 可以定义 data 的哪个维度被编码成什么。 encode: types.Union[types.JSFunc, dict, None] &#x3D; None,) PieItem：饼图数据项 12345678910111213141516171819class PieItem( # 数据项名称。 name: Optional[str] &#x3D; None, # 数据值。 value: Optional[Numeric] &#x3D; None, # 该数据项是否被选中。 is_selected: bool &#x3D; False, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[LabelOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[TooltipOpts, dict, None] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pyecharts-Line","slug":"pyecharts-Line","date":"2020-08-01T01:42:32.000Z","updated":"2020-08-01T01:45:35.147Z","comments":true,"path":"2020/08/01/pyecharts-line/","link":"","permalink":"http://yoursite.com/2020/08/01/pyecharts-line/","excerpt":"","text":"pyecharts_Line全部来自于官方文档，主要用于方便自己查找 Line：折线/面积图12345678910111213141516171819202122232425262728293031323334from pyecharts.charts import Lineimport pyecharts.options as optsx_data = []y_data = []( Line(init_opts=opts.InitOpts()) .add_xaxis(x_data) .add_yaxis( series_name='折线名称', # 折线数据 y_axis= y_data, # 标记点为 markpoint_opts=opts.MarkPointOpts( data=[ opts.MarkPointItem(type_='max', name=\"最大值\"), opts.MarkPointItem(type_='min', name='最小值'), ] ), # 额外标记线 markline_opts=opts.MarkLineOpts( data=[opts.MarkLineItem(type_=\"average\", name=\"平均值\")] ), ) .set_series_opts( # 不透明度设置 areastyle_opts=opts.AreaStyleOpts(opacity=0.5) ) .set_global_opts( title_opts=opts.TitleOpts(title=\"主标题\", subtitle='副标题'), toolbox_opts=opts.TooltipOpts() ) .render(\"xxx.html\")) .add_yaxis() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980def add_yaxis( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据 y_axis: types.Sequence[types.Union[opts.LineItem, dict]], # 是否选中图例 is_selected: bool &#x3D; True, # 是否连接空数据，空数据使用 &#96;None&#96; 填充 is_connect_nones: bool &#x3D; False, # 使用的 x 轴的 index，在单个图表实例中存在多个 x 轴的时候有用。 xaxis_index: Optional[Numeric] &#x3D; None, # 使用的 y 轴的 index，在单个图表实例中存在多个 y 轴的时候有用。 yaxis_index: Optional[Numeric] &#x3D; None, # 系列 label 颜色 color: Optional[str] &#x3D; None, # 是否显示 symbol, 如果 false 则只有在 tooltip hover 的时候显示。 is_symbol_show: bool &#x3D; True, # 标记的图形。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 symbol: Optional[str] &#x3D; None, # 标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高， # 例如 [20, 10] 表示标记宽为 20，高为 10。 symbol_size: Union[Numeric, Sequence] &#x3D; 4, # 数据堆叠，同个类目轴上系列配置相同的 stack 值可以堆叠放置。 stack: Optional[str] &#x3D; None, # 是否平滑曲线 is_smooth: bool &#x3D; False, # 是否裁剪超出坐标系部分的图形。折线图：裁掉所有超出坐标系的折线部分，拐点图形的逻辑按照散点图处理 is_clip: bool &#x3D; True, # 是否显示成阶梯图 is_step: bool &#x3D; False, # 是否开启 hover 在拐点标志上的提示动画效果。 is_hover_animation: bool &#x3D; True, # 折线图所有图形的 zlevel 值。 # zlevel用于 Canvas 分层，不同zlevel值的图形会放置在不同的 Canvas 中，Canvas 分层是一种常见的优化手段。 # zlevel 大的 Canvas 会放在 zlevel 小的 Canvas 的上面。 z_level: types.Numeric &#x3D; 0, # 折线图组件的所有图形的z值。控制图形的前后顺序。z值小的图形会被z值大的图形覆盖。 # z 相比 zlevel 优先级更低，而且不会创建新的 Canvas。 z: types.Numeric &#x3D; 0, # 标记点配置项，参考 &#96;series_options.MarkPointOpts&#96; markpoint_opts: Union[opts.MarkPointOpts, dict, None] &#x3D; None, # 标记线配置项，参考 &#96;series_options.MarkLineOpts&#96; markline_opts: Union[opts.MarkLineOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(), # 线样式配置项，参考 &#96;series_options.LineStyleOpts&#96; linestyle_opts: Union[opts.LineStyleOpts, dict] &#x3D; opts.LineStyleOpts(), # 填充区域配置项，参考 &#96;series_options.AreaStyleOpts&#96; areastyle_opts: Union[opts.AreaStyleOpts, dict] &#x3D; opts.AreaStyleOpts(), # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None,) LineItem：折线图数据项12345678910111213141516171819202122232425262728293031class LineItem( # 数据项名称。 name: Union[str, Numeric] &#x3D; None, # 数据项的值 value: Union[str, Numeric] &#x3D; None, # 单个数据标记的图形。 symbol: Optional[str] &#x3D; None, # 单个数据标记的大小 symbol_size: Union[Sequence[Numeric], Numeric] &#x3D; None, # 单个数据标记的旋转角度（而非弧度）。 symbol_rotate: Optional[Numeric] &#x3D; None, # 如果 symbol 是 path:&#x2F;&#x2F; 的形式，是否在缩放时保持该图形的长宽比。 symbol_keep_aspect: bool &#x3D; False, # 单个数据标记相对于原本位置的偏移。 symbol_offset: Optional[Sequence] &#x3D; None, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[LabelOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[TooltipOpts, dict, None] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pixabay_爬取","slug":"pixabay-爬取","date":"2020-07-31T12:12:54.000Z","updated":"2020-07-31T13:44:23.847Z","comments":true,"path":"2020/07/31/pixabay-pa-qu/","link":"","permalink":"http://yoursite.com/2020/07/31/pixabay-pa-qu/","excerpt":"","text":"记一次简单的爬虫学习批量爬取 pixabay 图片 pixabay图片查找地址 pixabay网站提供的API 1. pixabay 是一个做的很好的免费图片获取网站，里边有很多高质量免费的图片，有一天我想能不能写一个批量获取图片的爬虫，用于收集那些漂亮图片 2. 说做就做，我先对网站进行最简单的分析(急性子，甚至源码都没细看),然后就开始急急切切的开始了爬取123456789import requestsfrom bs4 import BeautifulSouplink = 'https://pixabay.com/zh/images/search/'headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/78.0.3904.97 Safari/537.36'&#125;response = requests.get(link, headers=headers)soup = BeautifulSoup(response.text, 'lxml')print(soup) 结果当然是失败了，并且基本上没有获得什么有用的信息 3. 然后再对网页源码报头进行仔细查看后仍然一头雾水的我，想到了可能会提供的有 API 接口，然后通过 CTRL + F在源码中搜索，找到了官方提供的 API 结构(赞美官方)pixabay网站提供的API 通过阅读官方文档就能发现只需要注册官方就可以提供一个 API key，每小时下载量也够我这个个人用户使用 官方提供了非常详细的 网址的各种参量拼接方式，以及爬出样本以供分析(出乎意料的是还有影片的接口及查询方式)对链接构成简单分析后，我发现对于自己需要提供的仅仅是KEY, 图片类型(image_type)，搜索条件(q)，爬取页数(page)，每页爬取数(per_page) 于是一段简单的拼接 URL 构成了,也考虑到了翻页的情况 12345678910111213141516def get_json(page, condition, image_type): page +&#x3D; 1 key &#x3D; &#39;&#39; url &#x3D; &#39;https:&#x2F;&#x2F;pixabay.com&#x2F;api&#x2F;&#39; pa &#x3D; &#123; &#39;key&#39;: key, &#39;q&#39;: condition, &#39;image_type&#39;: image_type, &#39;lang&#39;: &#39;zh&#39;, &#39;page&#39;: page, &#39;per_page&#39;: 200, &#125; r &#x3D; requests.get(url, params&#x3D;pa, headers&#x3D;headers) decode_json &#x3D; json.loads(r.text) return decode_json 4. 根据官方提供的例子进行分析，挑出自己需要的部分1234567891011121314151617181920212223242526272829303132333435&#123;\"total\": 4692,\"totalHits\": 500,\"hits\": [ &#123; \"id\": 195893, \"pageURL\": \"https://pixabay.com/en/blossom-bloom-flower-195893/\", \"type\": \"photo\", \"tags\": \"blossom, bloom, flower\", \"previewURL\": \"https://cdn.pixabay.com/photo/2013/10/15/09/12/flower-195893_150.jpg\", \"previewWidth\": 150, \"previewHeight\": 84, \"webformatURL\": \"https://pixabay.com/get/35bbf209e13e39d2_640.jpg\", \"webformatWidth\": 640, \"webformatHeight\": 360, \"largeImageURL\": \"https://pixabay.com/get/ed6a99fd0a76647_1280.jpg\", \"fullHDURL\": \"https://pixabay.com/get/ed6a9369fd0a76647_1920.jpg\", \"imageURL\": \"https://pixabay.com/get/ed6a9364a9fd0a76647.jpg\", \"imageWidth\": 4000, \"imageHeight\": 2250, \"imageSize\": 4731420, \"views\": 7671, \"downloads\": 6439, \"favorites\": 1, \"likes\": 5, \"comments\": 2, \"user_id\": 48777, \"user\": \"Josch13\", \"userImageURL\": \"https://cdn.pixabay.com/user/2013/11/05/02-10-23-764_250x250.jpg\" &#125;, &#123; \"id\": 73424 &#125;]&#125; 在这些里面我们需要的是 图片的类型、图片的标签、图片的大图链接 ，由于最近在学习数据分析，于是我也爬取了图片的下载量、收藏量以及被标记为爱好的量1234567data &#x3D; &#123;&#39;type&#39;: picture[&#39;type&#39;], &#39;tags&#39;: picture[&#39;tags&#39;], &#39;largeImageURL&#39;: picture[&#39;largeImageURL&#39;], &#39;downloads&#39;: picture[&#39;downloads&#39;], # 下载总数 &#39;favorites&#39;: picture[&#39;favorites&#39;], # 收藏夹总数 &#39;like&#39;: picture[&#39;likes&#39;], # 点赞总数&#125; 然后就是对大体框架的编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import requestsimport jsonfrom pymongo import MongoClientimport timeimport csvimport pymysqldef get_json(page, condition, image_type): page += 1 key = '' url = 'https://pixabay.com/api/' pa = &#123; 'key': key, 'q': condition, 'image_type': image_type, 'lang': 'zh', 'page': page, 'per_page': 200, &#125; r = requests.get(url, params=pa, headers=headers) decode_json = json.loads(r.text) return decode_jsonpage = 0id = 0headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/78.0.3904.97 Safari/537.36'&#125;condition = input(\"请输入你的搜索条件(多个条件以+连接): \")image_type = input(\"请输入搜索图片类型( 'all, photo, illustration插图, vector矢量'): \")number = input('请输入想要查询的图片页数num (num*200每页200条数据): ')# 存入 Nosql 数据库client = MongoClient('localhost', 27017)db = client.pixabay_databasecollection = db.pixabayfor _ in range(1, int(number)): decode_json = get_json(page, condition, image_type) for picture in decode_json['hits']: id += 1 data = &#123;'id': id, 'type': picture['type'], 'tags': picture['tags'], 'largeImageURL': picture['largeImageURL'], 'downloads': picture['downloads'], # 下载总数 'favorites': picture['favorites'], # 收藏夹总数 'like': picture['likes'], # 点赞总数 &#125; print('开始存入数据库') collection.insert_one(data)# 存入Mysql数据库'''db = pymysql.connect(host='localhost', user=\"root\", passwd=\"root\", port=3306, db='pixabay', charset='utf8')cursor = db.cursor()for _ in range(1, int(number)): decode_json = get_json(page, condition, image_type) for picture in decode_json['hits']: id += 1 data = &#123;'id': id, 'type': picture['type'], 'tags': picture['tags'], 'largeImageURL': picture['largeImageURL'], 'downloads': picture['downloads'], # 下载总数 'favorites': picture['favorites'], # 收藏夹总数 'like': picture['likes'], # 点赞总数 &#125; print('开始存入数据库') sql = \"\"\"INSERT INTO pixabay (type, tags, largeImageURL, downloads, favorites, likes) VALUES (%s, %s, %s, %s, %s, %s) \"\"\" cursor.execute(sql, ( picture['type'], picture['tags'], picture['largeImageURL'], picture['downloads'], picture['favorites'], picture['likes'])) db.commit()# print(data)cursor.close()db.close()'''# 存为 CSV 格式'''with open('/helper_hu/analysis_pixabay/analysis_pixabay.csv', 'a+', encoding='UTF-8', newline='') as csvfile: head = ['id', 'type', 'tags', 'largeImageURL', 'downloads', 'favorites', 'like'] writer = csv.writer(csvfile) writer.writerow(head) for _ in range(1, int(number)): decode_json = get_json(page, condition, image_type) for picture in decode_json['hits']: id += 1 data = &#123;'id': id, 'type': picture['type'], 'tags': picture['tags'], 'largeImageURL': picture['largeImageURL'], 'downloads': picture['downloads'], # 下载总数 'favorites': picture['favorites'], # 收藏夹总数 'like': picture['likes'], # 点赞总数 &#125; # head = list(data.keys()) rows = list(data.values()) writer.writerow(rows) print('写入数据id=&#123;&#125;'.format(id)) time.sleep(1.0)''' 小结：分别写了3种存储方式 MySQL、MangoDB以及CSV，之后我用读取CSV 数据的方法简单分析了一类图片下用户最喜欢的图片以及下载量最多的。","categories":[],"tags":[{"name":"scrapy_study","slug":"scrapy-study","permalink":"http://yoursite.com/tags/scrapy-study/"}]},{"title":"pyecharts_series_options","slug":"pyecharts_series_options","date":"2020-07-30T12:12:54.000Z","updated":"2020-07-31T13:52:41.093Z","comments":true,"path":"2020/07/30/pyecharts-series-options/","link":"","permalink":"http://yoursite.com/2020/07/30/pyecharts-series-options/","excerpt":"","text":"pyecharts 配置项全部来自于官方文档，主要用于方便自己查找系列配置项 (按常用顺序排序) ItemStyleOpts：图元样式配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ItemStyleOpts( # 图形的颜色。 # 颜色可以使用 RGB 表示，比如 &#39;rgb(128, 128, 128)&#39;，如果想要加上 alpha 通道表示不透明度， # 可以使用 RGBA，比如 &#39;rgba(128, 128, 128, 0.5)&#39;，也可以使用十六进制格式，比如 &#39;#ccc&#39;。 # 除了纯色之外颜色也支持渐变色和纹理填充 # # 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比， # 如果 globalCoord 为 &#96;true&#96;，则该四个值是绝对的像素位置 # color: &#123; # type: &#39;linear&#39;, # x: 0, # y: 0, # x2: 0, # y2: 1, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变 # color: &#123; # type: &#39;radial&#39;, # x: 0.5, # y: 0.5, # r: 0.5, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 纹理填充 # color: &#123; # image: imageDom, &#x2F;&#x2F; 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串 # repeat: &#39;repeat&#39; &#x2F;&#x2F; 是否平铺, 可以是 &#39;repeat-x&#39;, &#39;repeat-y&#39;, &#39;no-repeat&#39; # &#125; color: Optional[str] &#x3D; None, # 阴线 图形的颜色。 color0: Optional[str] &#x3D; None, # 图形的描边颜色。支持的颜色格式同 color，不支持回调函数。 border_color: Optional[str] &#x3D; None, # 阴线 图形的描边颜色。 border_color0: Optional[str] &#x3D; None, # 描边宽度，默认不描边。 border_width: Optional[Numeric] &#x3D; None, # 支持 &#39;dashed&#39;, &#39;dotted&#39;。 border_type: Optional[str] &#x3D; None, # 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 opacity: Optional[Numeric] &#x3D; None, # 区域的颜色。 area_color: Optional[str] &#x3D; None, ) TextStyleOpts：文字样式配置项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TextStyleOpts( # 文字颜色。 color: Optional[str] &#x3D; None, # 文字字体的风格 # 可选：&#39;normal&#39;，&#39;italic&#39;，&#39;oblique&#39; font_style: Optional[str] &#x3D; None, # 主标题文字字体的粗细，可选： # &#39;normal&#39;，&#39;bold&#39;，&#39;bolder&#39;，&#39;lighter&#39; font_weight: Optional[str] &#x3D; None, # 文字的字体系列 # 还可以是 &#39;serif&#39; , &#39;monospace&#39;, &#39;Arial&#39;, &#39;Courier New&#39;, &#39;Microsoft YaHei&#39;, ... font_family: Optional[str] &#x3D; None, # 文字的字体大小 font_size: Optional[Numeric] &#x3D; None, # 文字水平对齐方式，默认自动 align: Optional[str] &#x3D; None, # 文字垂直对齐方式，默认自动 vertical_align: Optional[str] &#x3D; None, # 行高 line_height: Optional[str] &#x3D; None, # 文字块背景色。可以是直接的颜色值，例如：&#39;#123234&#39;, &#39;red&#39;, &#39;rgba(0,23,11,0.3)&#39; background_color: Optional[str] &#x3D; None, # 文字块边框颜色 border_color: Optional[str] &#x3D; None, # 文字块边框宽度 border_width: Optional[Numeric] &#x3D; None, # 文字块的圆角 border_radius: Union[Numeric, Sequence, None] &#x3D; None, # 文字块的内边距 # 例如 padding: [3, 4, 5, 6]：表示 [上, 右, 下, 左] 的边距 # 例如 padding: 4：表示 padding: [4, 4, 4, 4] # 例如 padding: [3, 4]：表示 padding: [3, 4, 3, 4] padding: Union[Numeric, Sequence, None] &#x3D; None, # 文字块的背景阴影颜色 shadow_color: Optional[str] &#x3D; None, # 文字块的背景阴影长度 shadow_blur: Optional[Numeric] &#x3D; None, # 文字块的宽度 width: Optional[str] &#x3D; None, # 文字块的高度 height: Optional[str] &#x3D; None, # 在 rich 里面，可以自定义富文本样式。利用富文本样式，可以在标签中做出非常丰富的效果 # 具体配置可以参考一下 https:&#x2F;&#x2F;www.echartsjs.com&#x2F;tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE rich: Optional[dict] &#x3D; None, ) LabelOpts：标签配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class LabelOpts( # 是否显示标签。 is_show: bool &#x3D; True, # 标签的位置。可选 # &#39;top&#39;，&#39;left&#39;，&#39;right&#39;，&#39;bottom&#39;，&#39;inside&#39;，&#39;insideLeft&#39;，&#39;insideRight&#39; # &#39;insideTop&#39;，&#39;insideBottom&#39;， &#39;insideTopLeft&#39;，&#39;insideBottomLeft&#39; # &#39;insideTopRight&#39;，&#39;insideBottomRight&#39; position: Union[str, Sequence] &#x3D; &quot;top&quot;, # 文字的颜色。 # 如果设置为 &#39;auto&#39;，则为视觉映射得到的颜色，如系列色。 color: Optional[str] &#x3D; None, # 距离图形元素的距离。当 position 为字符描述值（如 &#39;top&#39;、&#39;insideRight&#39;）时候有效。 distance: Union[Numeric, Sequence, None] &#x3D; None, # 文字的字体大小 font_size: Numeric &#x3D; 12, # 文字字体的风格，可选： # &#39;normal&#39;，&#39;italic&#39;，&#39;oblique&#39; font_style: Optional[str] &#x3D; None, # 文字字体的粗细，可选： # &#39;normal&#39;，&#39;bold&#39;，&#39;bolder&#39;，&#39;lighter&#39; font_weight: Optional[str] &#x3D; None, # 文字的字体系列 # 还可以是 &#39;serif&#39; , &#39;monospace&#39;, &#39;Arial&#39;, &#39;Courier New&#39;, &#39;Microsoft YaHei&#39;, ... font_family: Optional[str] &#x3D; None, # 标签旋转。从 -90 度到 90 度。正值是逆时针。 rotate: Optional[Numeric] &#x3D; None, # 刻度标签与轴线之间的距离。 margin: Optional[Numeric] &#x3D; 8, # 坐标轴刻度标签的显示间隔，在类目轴中有效。 # 默认会采用标签不重叠的策略间隔显示标签。 # 可以设置成 0 强制显示所有标签。 # 如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。 # 可以用数值表示间隔的数据，也可以通过回调函数控制。回调函数格式如下： # (index:number, value: string) &#x3D;&gt; boolean # 第一个参数是类目的 index，第二个值是类目名称，如果跳过则返回 false。 interval: Union[Numeric, str, None]&#x3D; None, # 文字水平对齐方式，默认自动。可选： # &#39;left&#39;，&#39;center&#39;，&#39;right&#39; horizontal_align: Optional[str] &#x3D; None, # 文字垂直对齐方式，默认自动。可选： # &#39;top&#39;，&#39;middle&#39;，&#39;bottom&#39; vertical_align: Optional[str] &#x3D; None, # 标签内容格式器，支持字符串模板和回调函数两种形式，字符串模板与回调函数返回的字符串均支持用 \\n 换行。 # 模板变量有 &#123;a&#125;, &#123;b&#125;，&#123;c&#125;，&#123;d&#125;，&#123;e&#125;，分别表示系列名，数据名，数据值等。 # 在 trigger 为 &#39;axis&#39; 的时候，会有多个系列的数据，此时可以通过 &#123;a0&#125;, &#123;a1&#125;, &#123;a2&#125; 这种后面加索引的方式表示系列的索引。 # 不同图表类型下的 &#123;a&#125;，&#123;b&#125;，&#123;c&#125;，&#123;d&#125; 含义不一样。 其中变量&#123;a&#125;, &#123;b&#125;, &#123;c&#125;, &#123;d&#125;在不同图表类型下代表数据含义为： # 折线（区域）图、柱状（条形）图、K线图 : &#123;a&#125;（系列名称），&#123;b&#125;（类目值），&#123;c&#125;（数值）, &#123;d&#125;（无） # 散点图（气泡）图 : &#123;a&#125;（系列名称），&#123;b&#125;（数据名称），&#123;c&#125;（数值数组）, &#123;d&#125;（无） # 地图 : &#123;a&#125;（系列名称），&#123;b&#125;（区域名称），&#123;c&#125;（合并数值）, &#123;d&#125;（无） # 饼图、仪表盘、漏斗图: &#123;a&#125;（系列名称），&#123;b&#125;（数据项名称），&#123;c&#125;（数值）, &#123;d&#125;（百分比） # 示例：formatter: &#39;&#123;b&#125;: &#123;@score&#125;&#39; # # 回调函数，回调函数格式： # (params: Object|Array) &#x3D;&gt; string # 参数 params 是 formatter 需要的单个数据集。格式如下： # &#123; # componentType: &#39;series&#39;, # &#x2F;&#x2F; 系列类型 # seriesType: string, # &#x2F;&#x2F; 系列在传入的 option.series 中的 index # seriesIndex: number, # &#x2F;&#x2F; 系列名称 # seriesName: string, # &#x2F;&#x2F; 数据名，类目名 # name: string, # &#x2F;&#x2F; 数据在传入的 data 数组中的 index # dataIndex: number, # &#x2F;&#x2F; 传入的原始数据项 # data: Object, # &#x2F;&#x2F; 传入的数据值 # value: number|Array, # &#x2F;&#x2F; 数据图形的颜色 # color: string, # &#125; formatter: Optional[str] &#x3D; None, # 在 rich 里面，可以自定义富文本样式。利用富文本样式，可以在标签中做出非常丰富的效果 # 具体配置可以参考一下 https:&#x2F;&#x2F;www.echartsjs.com&#x2F;tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE rich: Optional[dict] &#x3D; None,) LineStyleOpts：线样式配置项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class LineStyleOpts( # 是否显示 is_show: bool &#x3D; True, # 线宽。 width: Numeric &#x3D; 1, # 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 opacity: Numeric &#x3D; 1, # 线的弯曲度，0 表示完全不弯曲 curve: Numeric &#x3D; 0, # 线的类型。可选： # &#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39; type_: str &#x3D; &quot;solid&quot;, # 线的颜色。 # 颜色可以使用 RGB 表示，比如 &#39;rgb(128, 128, 128)&#39;，如果想要加上 alpha 通道表示不透明度， # 可以使用 RGBA，比如 &#39;rgba(128, 128, 128, 0.5)&#39;，也可以使用十六进制格式，比如 &#39;#ccc&#39;。 # 除了纯色之外颜色也支持渐变色和纹理填充 # # 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比， # 如果 globalCoord 为 &#96;true&#96;，则该四个值是绝对的像素位置 # color: &#123; # type: &#39;linear&#39;, # x: 0, # y: 0, # x2: 0, # y2: 1, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变 # color: &#123; # type: &#39;radial&#39;, # x: 0.5, # y: 0.5, # r: 0.5, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 纹理填充 # color: &#123; # image: imageDom, &#x2F;&#x2F; 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串 # repeat: &#39;repeat&#39; &#x2F;&#x2F; 是否平铺, 可以是 &#39;repeat-x&#39;, &#39;repeat-y&#39;, &#39;no-repeat&#39; # &#125; color: Union[str, Sequence, None] &#x3D; None,) Lines3DEffectOpts：3D线样式配置项 1234567891011121314151617181920212223class Line3DEffectOpts( # 是否显示尾迹特效，默认不显示。 is_show: bool &#x3D; True, # 尾迹特效的周期。 period: Numeric &#x3D; 4, # 轨迹特效的移动动画是否是固定速度，单位按三维空间的尺寸 # 设置为非 null 的值后会忽略 period 配置项。 constant_speed: Optional[Numeric] &#x3D; None, # 尾迹的宽度。 trail_width: Numeric &#x3D; 4, # 尾迹的长度，范围从 0 到 1，为线条长度的百分比。 trail_length: Numeric &#x3D; 0.1, # 尾迹的颜色，默认跟线条颜色相同。 trail_color: Optional[str] &#x3D; None, # 尾迹的不透明度，默认跟线条不透明度相同。 trail_opacity: Optional[Numeric] &#x3D; None,) SplitLineOpts：分割线配置项 1234567class SplitLineOpts( # 是否显示分割线 is_show: bool &#x3D; False, # 线风格配置项，参考 &#96;series_options.SplitLineOpts&#96; linestyle_opts: LineStyleOpts &#x3D; LineStyleOpts()) MarkPointItem：标记点数据项 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MarkPointItem( # 标注名称。 name: Optional[str] &#x3D; None, # 特殊的标注类型，用于标注最大值最小值等。可选: # &#39;min&#39; 最大值。 # &#39;max&#39; 最大值。 # &#39;average&#39; 平均值。 type_: Optional[str] &#x3D; None, # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值，可以是 # 0（xAxis, radiusAxis）， # 1（yAxis, angleAxis），默认使用第一个数值轴所在的维度。 value_index: Optional[Numeric] &#x3D; None, # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值。这可以是维度的直接名称， # 例如折线图时可以是 x、angle 等、candlestick 图时可以是 open、close 等维度名称。 value_dim: Optional[str] &#x3D; None, # 标注的坐标。坐标格式视系列的坐标系而定，可以是直角坐标系上的 x, y， # 也可以是极坐标系上的 radius, angle。例如 [121, 2323]、[&#39;aa&#39;, 998]。 coord: Optional[Sequence] &#x3D; None, # 相对容器的屏幕 x 坐标，单位像素。 x: Optional[Numeric] &#x3D; None, # 相对容器的屏幕 y 坐标，单位像素。 y: Optional[Numeric] &#x3D; None, # 标注值，可以不设。 value: Optional[Numeric] &#x3D; None, # 标记的图形。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 symbol: Optional[str] &#x3D; None, # 标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高， # 例如 [20, 10] 表示标记宽为 20，高为 10。 symbol_size: Union[Numeric, Sequence] &#x3D; None, # 标记点样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None,) MarkPointOpts：标记点配置项 1234567891011121314151617181920class MarkPointOpts( # 标记点数据，参考 &#96;series_options.MarkPointItem&#96; data: Sequence[Union[MarkPointItem, dict]] &#x3D; None, # 标记的图形。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 symbol: Optional[str] &#x3D; None, # 标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高， # 例如 [20, 10] 表示标记宽为 20，高为 10。 # 如果需要每个数据的图形大小不一样，可以设置为如下格式的回调函数： # (value: Array|number, params: Object) &#x3D;&gt; number|Array # 其中第一个参数 value 为 data 中的数据值。第二个参数 params 是其它的数据项参数。 symbol_size: Union[None, Numeric] &#x3D; None, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: LabelOpts &#x3D; LabelOpts(position&#x3D;&quot;inside&quot;, color&#x3D;&quot;#fff&quot;),) MarkLineItem：标记线数据项 123456789101112131415161718192021222324252627282930313233343536373839class MarkLineItem( # 标注名称。 name: Optional[str] &#x3D; None, # 特殊的标注类型，用于标注最大值最小值等。可选: # &#39;min&#39; 最大值。 # &#39;max&#39; 最大值。 # &#39;average&#39; 平均值。 type_: Optional[str] &#x3D; None, # 相对容器的屏幕 x 坐标，单位像素。 x: Union[str, Numeric, None] &#x3D; None, # 相对容器的屏幕 y 坐标，单位像素。 y: Union[str, Numeric, None] &#x3D; None, # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值，可以是 # 0（xAxis, radiusAxis）， # 1（yAxis, angleAxis），默认使用第一个数值轴所在的维度。 value_index: Optional[Numeric] &#x3D; None, # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值。这可以是维度的直接名称， # 例如折线图时可以是 x、angle 等、candlestick 图时可以是 open、close 等维度名称。 value_dim: Optional[str] &#x3D; None, # 起点或终点的坐标。坐标格式视系列的坐标系而定，可以是直角坐标系上的 x, y， # 也可以是极坐标系上的 radius, angle。 coord: Optional[Sequence] &#x3D; None, # 终点标记的图形。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 symbol: Optional[str] &#x3D; None, # 标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高， # 例如 [20, 10] 表示标记宽为 20，高为 10。 symbol_size: Optional[Numeric] &#x3D; None,) MarkLineOpts：标记线配置项 12345678910111213141516171819202122class MarkLineOpts( # 图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。 is_silent: bool &#x3D; False, # 标记线数据，参考 &#96;series_options.MarkLineItem&#96; data: Sequence[Union[MarkLineItem, dict]] &#x3D; None, # 标线两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定，具体格式见 data.symbol。 symbol: Optional[str] &#x3D; None, # 标线两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。 symbol_size: Union[None, Numeric] &#x3D; None, # 标线数值的精度，在显示平均值线的时候有用。 precision: int &#x3D; 2, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: LabelOpts &#x3D; LabelOpts(), # 标记线样式配置项，参考 &#96;series_options.LineStyleOpts&#96; linestyle_opts: Union[LineStyleOpts, dict, None] &#x3D; None,) MarkAreaItem：标记区域数据项 123456789101112131415161718192021222324252627282930class MarkAreaItem( # 区域名称, 仅仅就是一个名称而已 name: Optional[str] &#x3D; None, # 特殊的标注类型，用于标注最大值最小值等。 # &#39;min&#39; 最大值。 # &#39;max&#39; 最大值。 # &#39;average&#39; 平均值。 type_: Sequence[Optional[str], Optional[str]] &#x3D; (None, None), # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值，可以是 0（xAxis, radiusAxis），1（yAxis, angleAxis）。 # 默认使用第一个数值轴所在的维度。 value_index: Sequence[Optional[Numeric], Optional[Numeric]] &#x3D; (None, None), # 在使用 type 时有效，用于指定在哪个维度上指定最大值最小值。 # 这可以是维度的直接名称，例如折线图时可以是 x、angle 等、candlestick 图时可以是 open、close 等维度名称。 value_dim: Sequence[Optional[str], Optional[str]] &#x3D; (None, None), # 相对容器的屏幕 x 坐标，单位像素，支持百分比形式，例如 &#39;20%&#39;。 x: Sequence[Union[str, Numeric, None], Union[str, Numeric, None]] &#x3D; (None, None), # 相对容器的屏幕 y 坐标，单位像素，支持百分比形式，例如 &#39;20%&#39;。 y: Sequence[Union[str, Numeric, None], Union[str, Numeric, None]] &#x3D; (None, None), # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[LabelOpts, dict, None] &#x3D; None, # 该数据项区域的样式，起点和终点项的 itemStyle 会合并到一起。参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None,) MarkAreaOpts：标记区域配置项 12345678910111213class MarkAreaOpts( # 图形是否不响应和触发鼠标事件，默认为 False，即响应和触发鼠标事件。 is_silent: bool &#x3D; False, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: LabelOpts &#x3D; LabelOpts(), # 标记区域数据，参考 &#96;series_options.MarkAreaItem&#96; data: Sequence[Union[MarkAreaItem, Sequence, dict]] &#x3D; None, # 该数据项区域的样式。参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: ItemStyleOpts &#x3D; None,) EffectOpts：涟漪特效配置项 1234567891011121314151617181920212223242526272829class EffectOpts( # 是否显示特效。 is_show: bool &#x3D; True, # 波纹的绘制方式，可选 &#39;stroke&#39; 和 &#39;fill&#39;，Scatter 类型有效。 brush_type: str &#x3D; &quot;stroke&quot;, # 动画中波纹的最大缩放比例，Scatter 类型有效。 scale: Numeric &#x3D; 2.5, # 动画的周期，秒数，Scatter 类型有效。 period: Numeric &#x3D; 4, # 特效标记的颜色 color: Optional[str] &#x3D; None, # 特效图形的标记。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 symbol: Optional[str] &#x3D; None, # 特效标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示高和宽， # 例如 [20, 10] 表示标记宽为 20，高为 10。 symbol_size: Optional[Numeric] &#x3D; None, # 特效尾迹的长度。取从 0 到 1 的值，数值越大尾迹越长。Geo 图设置 Lines 类型时有效。 trail_length: Optional[Numeric] &#x3D; None,) AreaStyleOpts：区域填充样式配置项 123456789101112131415161718192021222324252627282930313233343536373839404142434445class AreaStyleOpts( # 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 opacity: Optional[Numeric] &#x3D; 0, # 填充的颜色。 # 颜色可以使用 RGB 表示，比如 &#39;rgb(128, 128, 128)&#39;，如果想要加上 alpha 通道表示不透明度， # 可以使用 RGBA，比如 &#39;rgba(128, 128, 128, 0.5)&#39;，也可以使用十六进制格式，比如 &#39;#ccc&#39;。 # 除了纯色之外颜色也支持渐变色和纹理填充 # # 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比， # 如果 globalCoord 为 &#96;true&#96;，则该四个值是绝对的像素位置 # color: &#123; # type: &#39;linear&#39;, # x: 0, # y: 0, # x2: 0, # y2: 1, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变 # color: &#123; # type: &#39;radial&#39;, # x: 0.5, # y: 0.5, # r: 0.5, # colorStops: [&#123; # offset: 0, color: &#39;red&#39; &#x2F;&#x2F; 0% 处的颜色 # &#125;, &#123; # offset: 1, color: &#39;blue&#39; &#x2F;&#x2F; 100% 处的颜色 # &#125;], # global: false &#x2F;&#x2F; 缺省为 false # &#125; # # 纹理填充 # color: &#123; # image: imageDom, &#x2F;&#x2F; 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串 # repeat: &#39;repeat&#39; &#x2F;&#x2F; 是否平铺, 可以是 &#39;repeat-x&#39;, &#39;repeat-y&#39;, &#39;no-repeat&#39; # &#125; color: Optional[str] &#x3D; None) SplitAreaOpts：分隔区域配置项 123456class SplitAreaOpts( # 是否显示分隔区域。 is_show&#x3D;True, # 分隔区域的样式配置项，参考 &#96;series_options.AreaStyleOpts&#96; areastyle_opts: AreaStyleOpts &#x3D; AreaStyleOpts()) MinorTickOpts：次级刻度配置项 12345678910111213class MinorTickOpts( # 是否显示次刻度线。 is_show: bool &#x3D; False, # 次刻度线分割数，默认会分割成 5 段 split_number: Numeric &#x3D; 5, # 次刻度线的长度。 length: Numeric &#x3D; 3, # 次刻度线的样式 linestyle_opts: Union[LineStyleOpts, dict, None] &#x3D; None,) MinorSplitLineOpts：次级分割线配置项 12345678910111213141516class MinorSplitLineOpts( # 是否显示次分隔线。默认不显示。 is_show: bool &#x3D; False, # 次分隔线线宽。 width: Numeric &#x3D; 1, # 次分隔线线的类型。可选：&#39;solid&#39;，&#39;dashed&#39;，&#39;dotted&#39; type_: str &#x3D; &quot;solid&quot;, # 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 opacity: Union[Numeric, None] &#x3D; None, # 线的样式 linestyle_opts: Union[LineStyleOpts, dict, None] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pyecharts_Bar","slug":"pyecharts_Bar","date":"2020-07-30T12:12:54.000Z","updated":"2020-07-31T13:51:46.671Z","comments":true,"path":"2020/07/30/pyecharts-bar/","link":"","permalink":"http://yoursite.com/2020/07/30/pyecharts-bar/","excerpt":"","text":"pyecharts_Bar全部来自于官方文档，主要用于方便自己查找 Bar: 柱状图/条形图123456789101112131415161718Bar(init_opts&#x3D;opts.InitOpts()).add_xaxis(x_data).add_yaxis(y_data) # 系列配置项.set_series_opts() # 全局配置项.set_global_opts( title_opts&#x3D;opts.TitleOpts(title&#x3D;&quot;标题&quot;), # 工具箱选择项 toolbox_opts&#x3D;opts.ToolboxOpts(), # 图例配置项 legend_opts&#x3D;opts.legendOpts(is_show&#x3D;False), # 坐标轴配置项 yaxis_opts&#x3D;opts.AxisOpts(type_&#x3D;&quot;value&quot;), # 原生图形元素组件 opts.GraphicGroup(graphic_item&#x3D;opts.GraphicItem()) ) .render() .add_yaxis() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104def add_yaxis( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name: str, # 系列数据 y_axis: Sequence[Numeric, opts.BarItem, dict], # 是否选中图例 is_selected: bool &#x3D; True, # 使用的 x 轴的 index，在单个图表实例中存在多个 x 轴的时候有用。 xaxis_index: Optional[Numeric] &#x3D; None, # 使用的 y 轴的 index，在单个图表实例中存在多个 y 轴的时候有用。 yaxis_index: Optional[Numeric] &#x3D; None, # 是否启用图例 hover 时的联动高亮 is_legend_hover_link: bool &#x3D; True, # 系列 label 颜色 color: Optional[str] &#x3D; None, # 是否显示柱条的背景色。通过 backgroundStyle 配置背景样式。 is_show_background: bool &#x3D; False, # 每一个柱条的背景样式。需要将 showBackground 设置为 true 时才有效。 background_style: types.Union[types.BarBackground, dict, None] &#x3D; None, # 数据堆叠，同个类目轴上系列配置相同的 stack 值可以堆叠放置。 stack: Optional[str] &#x3D; None, # 柱条的宽度，不设时自适应。 # 可以是绝对值例如 40 或者百分数例如 &#39;60%&#39;。百分数基于自动计算出的每一类目的宽度。 # 在同一坐标系上，此属性会被多个 &#39;bar&#39; 系列共享。此属性应设置于此坐标系中最后一个 &#39;bar&#39; 系列上才会生效，并且是对此坐标系中所有 &#39;bar&#39; 系列生效。 bar_width: types.Union[types.Numeric, str] &#x3D; None, # 柱条的最大宽度。比 barWidth 优先级高。 bar_max_width: types.Union[types.Numeric, str] &#x3D; None, # 柱条的最小宽度。在直角坐标系中，默认值是 1。否则默认值是 null。比 barWidth 优先级高。 bar_min_width: types.Union[types.Numeric, str] &#x3D; None, # 柱条最小高度，可用于防止某数据项的值过小而影响交互。 bar_min_height: types.Numeric &#x3D; 0, # 同一系列的柱间距离，默认为类目间距的 20%，可设固定值 category_gap: Union[Numeric, str] &#x3D; &quot;20%&quot;, # 不同系列的柱间距离，为百分比（如 &#39;30%&#39;，表示柱子宽度的 30%）。 # 如果想要两个系列的柱子重叠，可以设置 gap 为 &#39;-100%&#39;。这在用柱子做背景的时候有用。 gap: Optional[str] &#x3D; &quot;30%&quot;, # 是否开启大数据量优化，在数据图形特别多而出现卡顿时候可以开启。 # 开启后配合 largeThreshold 在数据量大于指定阈值的时候对绘制进行优化。 # 缺点：优化后不能自定义设置单个数据项的样式。 is_large: bool &#x3D; False, # 开启绘制优化的阈值。 large_threshold: types.Numeric &#x3D; 400, # 使用 dimensions 定义 series.data 或者 dataset.source 的每个维度的信息。 # 注意：如果使用了 dataset，那么可以在 dataset.source 的第一行&#x2F;列中给出 dimension 名称。 # 于是就不用在这里指定 dimension。 # 但是，如果在这里指定了 dimensions，那么 ECharts 不再会自动从 dataset.source 的第一行&#x2F;列中获取维度信息。 dimensions: types.Union[types.Sequence, None] &#x3D; None, # 当使用 dataset 时，seriesLayoutBy 指定了 dataset 中用行还是列对应到系列上，也就是说，系列“排布”到 dataset 的行还是列上。可取值： # &#39;column&#39;：默认，dataset 的列对应于系列，从而 dataset 中每一列是一个维度（dimension）。 # &#39;row&#39;：dataset 的行对应于系列，从而 dataset 中每一行是一个维度（dimension）。 series_layout_by: str &#x3D; &quot;column&quot;, # 如果 series.data 没有指定，并且 dataset 存在，那么就会使用 dataset。 # datasetIndex 指定本系列使用那个 dataset。 dataset_index: types.Numeric &#x3D; 0, # 是否裁剪超出坐标系部分的图形。柱状图：裁掉所有超出坐标系的部分，但是依然保留柱子的宽度 is_clip: bool &#x3D; True, # 柱状图所有图形的 zlevel 值。 z_level: types.Numeric &#x3D; 0, # 柱状图组件的所有图形的z值。控制图形的前后顺序。 # z值小的图形会被z值大的图形覆盖。 # z相比zlevel优先级更低，而且不会创建新的 Canvas。 z: types.Numeric &#x3D; 2, # 标签配置项，参考 &#96;series_options.LabelOpts&#96; label_opts: Union[opts.LabelOpts, dict] &#x3D; opts.LabelOpts(), # 标记点配置项，参考 &#96;series_options.MarkPointOpts&#96; markpoint_opts: Union[opts.MarkPointOpts, dict, None] &#x3D; None, # 标记线配置项，参考 &#96;series_options.MarkLineOpts&#96; markline_opts: Union[opts.MarkLineOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[opts.TooltipOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] &#x3D; None, # 可以定义 data 的哪个维度被编码成什么。 encode: types.Union[types.JSFunc, dict, None] &#x3D; None,) BarItem：柱状图数据项 12345678910111213141516class BarItem( # 数据项名称。 name: Optional[str] &#x3D; None, # 单个数据项的数值。 value: Optional[Numeric] &#x3D; None, # 单个柱条文本的样式设置，参考 &#96;series_options.LabelOpts&#96;。 label_opts: Union[LabelOpts, dict, None] &#x3D; None, # 图元样式配置项，参考 &#96;series_options.ItemStyleOpts&#96; itemstyle_opts: Union[ItemStyleOpts, dict, None] &#x3D; None, # 提示框组件配置项，参考 &#96;series_options.TooltipOpts&#96; tooltip_opts: Union[TooltipOpts, dict, None] &#x3D; None, ) BarBackgroundStyleOpts：柱状图背景样式配置 12345678910111213141516171819202122232425262728293031323334class BarBackgroundStyleOpts( # 柱条的颜色。 color: str &#x3D; &quot;rgba(180, 180, 180, 0.2)&quot;, # 柱条的描边颜色。 border_color: str &#x3D; &quot;#000&quot;, # 柱条的描边宽度，默认不描边。 border_width: Numeric &#x3D; 0, # 柱条的描边类型，默认为实线，支持 &#39;dashed&#39;, &#39;dotted&#39;。 border_type: str &#x3D; &quot;solid&quot;, # 圆角半径，单位px，支持传入数组分别指定 4 个圆角半径。 如: # barBorderRadius: 5, &#x2F;&#x2F; 统一设置四个角的圆角大小 # barBorderRadius: [5, 5, 0, 0] &#x2F;&#x2F;（顺时针左上，右上，右下，左下） bar_border_radius: Union[Numeric, Sequence] &#x3D; 0, # 图形阴影的模糊大小。 # 该属性配合 shadowColor,shadowOffsetX, shadowOffsetY 一起设置图形的阴影效果。 shadow_blur: Optional[Numeric] &#x3D; None, # 阴影颜色。支持的格式同color。 shadow_color: Optional[str] &#x3D; None, # 阴影水平方向上的偏移距离。 shadow_offset_x: Numeric &#x3D; 0, # 阴影垂直方向上的偏移距离。 shadow_offset_y: Numeric &#x3D; 0, # 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 opacity: Optional[Numeric] &#x3D; None,)","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"pyecharts_global_options","slug":"pyecharts_global_options","date":"2020-07-30T12:12:54.000Z","updated":"2020-07-31T13:52:17.657Z","comments":true,"path":"2020/07/30/pyecharts-global-options/","link":"","permalink":"http://yoursite.com/2020/07/30/pyecharts-global-options/","excerpt":"","text":"pyecharts 配置项全部来自于官方文档，主要用于方便自己查找全局配置项 (按常用顺序排序) InitOpts: 初始化配置项 (class pyecharts.options.InitOpts) 123456789101112131415161718192021222324252627282930class InitOpts( # 图表画布宽度，css 长度单位。 width: str &#x3D; &quot;900px&quot;, # 图表画布高度，css 长度单位。 height: str &#x3D; &quot;500px&quot;, # 图表 ID，图表唯一标识，用于在多图表时区分。 chart_id: Optional[str] &#x3D; None, # 渲染风格，可选 &quot;canvas&quot;, &quot;svg&quot; # # 参考 &#96;全局变量&#96; 章节 renderer: str &#x3D; RenderType.CANVAS, # 网页标题 page_title: str &#x3D; &quot;Awesome-pyecharts&quot;, # 图表主题 theme: str &#x3D; &quot;white&quot;, # 图表背景颜色 bg_color: Optional[str] &#x3D; None, # 远程 js host，如不设置默认为 https:&#x2F;&#x2F;assets.pyecharts.org&#x2F;assets&#x2F;&quot; # 参考 &#96;全局变量&#96; 章节 js_host: str &#x3D; &quot;&quot;, # 画图动画初始化配置，参考 &#96;global_options.AnimationOpts&#96; animation_opts: Union[AnimationOpts, dict] &#x3D; AnimationOpts(),) TitleOpts：标题配置项 (class pyecharts.options.TitleOpts) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TitleOpts( # 主标题文本，支持使用 \\n 换行。 title: Optional[str] &#x3D; None, # 主标题跳转 URL 链接 title_link: Optional[str] &#x3D; None, # 主标题跳转链接方式,默认值是: blank # 可选参数: &#39;self&#39;, &#39;blank&#39;: &#39;self&#39; 当前窗口打开; &#39;blank&#39; 新窗口打开 title_target: Optional[str] &#x3D; None, # 副标题文本，支持使用 \\n 换行。 subtitle: Optional[str] &#x3D; None, # 副标题跳转 URL 链接 subtitle_link: Optional[str] &#x3D; None, # 副标题跳转链接方式, 默认值是: blank # 可选参数: &#39;self&#39;, &#39;blank&#39;: &#39;self&#39; 当前窗口打开; &#39;blank&#39; 新窗口打开 subtitle_target: Optional[str] &#x3D; None, # title 组件离容器左侧的距离。left 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;。 # 如果 left 的值为&#39;left&#39;, &#39;center&#39;, &#39;right&#39;，组件会根据相应的位置自动对齐。 pos_left: Optional[str] &#x3D; None, # title 组件离容器右侧的距离。 # right 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_right: Optional[str] &#x3D; None, # title 组件离容器上侧的距离。 # top 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。 # 如果 top 的值为&#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;，组件会根据相应的位置自动对齐。 pos_top: Optional[str] &#x3D; None, # title 组件离容器下侧的距离。 # bottom 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_bottom: Optional[str] &#x3D; None, # 标题内边距，单位px，默认各方向内边距为5，接受数组分别设定上右下左边距。 # &#x2F;&#x2F; 设置内边距为 5 # padding: 5 # &#x2F;&#x2F; 设置上下的内边距为 5，左右的内边距为 10 # padding: [5, 10] # &#x2F;&#x2F; 分别设置四个方向的内边距 # padding: [ # 5, &#x2F;&#x2F; 上 # 10, &#x2F;&#x2F; 右 # 5, &#x2F;&#x2F; 下 # 10, &#x2F;&#x2F; 左 # ] padding: Union[Sequence, Numeric] &#x3D; 5, # 主副标题之间的间距。 item_gap: Numeric &#x3D; 10, # 主标题字体样式配置项，参考 &#96;series_options.TextStyleOpts&#96; title_textstyle_opts: Union[TextStyleOpts, dict, None] &#x3D; None, # 副标题字体样式配置项，参考 &#96;series_options.TextStyleOpts&#96; subtitle_textstyle_opts: Union[TextStyleOpts, dict, None] &#x3D; None,) TooltipOpts：提示框配置项 (class pyecharts.options.TooltipOpts) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class TooltipOpts( # 是否显示提示框组件，包括提示框浮层和 axisPointer。 is_show: bool &#x3D; True, # 触发类型。可选： # &#39;item&#39;: 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。 # &#39;axis&#39;: 坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用。 # &#39;none&#39;: 什么都不触发 trigger: str &#x3D; &quot;item&quot;, # 提示框触发的条件，可选： # &#39;mousemove&#39;: 鼠标移动时触发。 # &#39;click&#39;: 鼠标点击时触发。 # &#39;mousemove|click&#39;: 同时鼠标移动和点击时触发。 # &#39;none&#39;: 不在 &#39;mousemove&#39; 或 &#39;click&#39; 时触发， trigger_on: str &#x3D; &quot;mousemove|click&quot;, # 指示器类型。可选 # &#39;line&#39;：直线指示器; &#39;shadow&#39;：阴影指示器; &#39;none&#39;：无指示器 # &#39;cross&#39;：十字准星指示器。其实是种简写，表示启用两个正交的轴的 axisPointer。 axis_pointer_type: str &#x3D; &quot;line&quot;, # 是否显示提示框浮层，默认显示。 # 只需 tooltip 触发事件或显示 axisPointer 而不需要显示内容时可配置该项为 false。 is_show_content: bool &#x3D; True, # 是否永远显示提示框内容， # 默认情况下在移出可触发提示框区域后一定时间后隐藏，设置为 true 可以保证一直显示提示框内容。 is_always_show_content: bool &#x3D; False, # 浮层显示的延迟，单位为 ms，默认没有延迟，也不建议设置。 show_delay: Numeric &#x3D; 0, # 浮层隐藏的延迟，单位为 ms，在 alwaysShowContent 为 true 的时候无效。 hide_delay: Numeric &#x3D; 100, # 提示框浮层的位置，默认不设置时位置会跟随鼠标的位置。 # 1、通过数组配置： # 绝对位置，相对于容器左侧 10px, 上侧 10 px &#x3D;&#x3D;&#x3D;&gt; position: [10, 10] # 相对位置，放置在容器正中间 &#x3D;&#x3D;&#x3D;&gt; position: [&#39;50%&#39;, &#39;50%&#39;] # 2、通过回调函数配置 # 3、固定参数配置：&#39;inside&#39;，&#39;top&#39;，&#39;left&#39;，&#39;right&#39;，&#39;bottom&#39; position: Union[str, Sequence, JSFunc] &#x3D; None, # 标签内容格式器，支持字符串模板和回调函数两种形式，字符串模板与回调函数返回的字符串均支持用 \\n 换行。 # 字符串模板 模板变量有： # &#123;a&#125;：系列名。 # &#123;b&#125;：数据名。 # &#123;c&#125;：数据值。 # &#123;@xxx&#125;：数据中名为 &#39;xxx&#39; 的维度的值，如 &#123;@product&#125; 表示名为 &#39;product&#39;&#96; 的维度的值。 # &#123;@[n]&#125;：数据中维度 n 的值，如&#123;@[3]&#125;&#96; 表示维度 3 的值，从 0 开始计数。 # 示例：formatter: &#39;&#123;b&#125;: &#123;@score&#125;&#39; # # 回调函数，回调函数格式： # (params: Object|Array) &#x3D;&gt; string # 参数 params 是 formatter 需要的单个数据集。格式如下： # &#123; # componentType: &#39;series&#39;, # &#x2F;&#x2F; 系列类型 # seriesType: string, # &#x2F;&#x2F; 系列在传入的 option.series 中的 index # seriesIndex: number, # &#x2F;&#x2F; 系列名称 # seriesName: string, # &#x2F;&#x2F; 数据名，类目名 # name: string, # &#x2F;&#x2F; 数据在传入的 data 数组中的 index # dataIndex: number, # &#x2F;&#x2F; 传入的原始数据项 # data: Object, # &#x2F;&#x2F; 传入的数据值 # value: number|Array, # &#x2F;&#x2F; 数据图形的颜色 # color: string, # &#125; formatter: Optional[str] &#x3D; None, # 提示框浮层的背景颜色。 background_color: Optional[str] &#x3D; None, # 提示框浮层的边框颜色。 border_color: Optional[str] &#x3D; None, # 提示框浮层的边框宽。 border_width: Numeric &#x3D; 0, # 文字样式配置项，参考 &#96;series_options.TextStyleOpts&#96; textstyle_opts: TextStyleOpts &#x3D; TextStyleOpts(font_size&#x3D;14),)&#96;&#96;&#96; AnimationOpts：Echarts 画图动画配置项 (class pyecharts.options.Animation) 12345678910111213141516171819202122232425262728293031class AnimationOpts( # 是否开启动画，默认为 True 开启。 animation: bool &#x3D; True, # 是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画。默认 2000。 animation_threshold: Numeric &#x3D; 2000, # 初始动画的时长，默认值为 1000。 # 支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果： animation_duration: Union[Numeric, JSFunc] &#x3D; 1000, # 初始动画的缓动效果。 # 不同的缓动效果可以参考，缓动示例 (https:&#x2F;&#x2F;www.echartsjs.com&#x2F;gallery&#x2F;editor.html?c&#x3D;line-easing)。 animation_easing: Union[str] &#x3D; &quot;cubicOut&quot;, # 初始动画的延迟，默认值为 0。 # 支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果。 animation_delay: Union[Numeric, JSFunc] &#x3D; 0, # 数据更新动画的时长，默认值为 300。 # 支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果： animation_duration_update: Union[Numeric, JSFunc] &#x3D; 300, # 数据更新动画的缓动效果。 # 不同的缓动效果可以参考，缓动示例 (https:&#x2F;&#x2F;www.echartsjs.com&#x2F;gallery&#x2F;editor.html?c&#x3D;line-easing)。 animation_easing_update: Union[Numeric] &#x3D; &quot;cubicOut&quot;, # 数据更新动画的延迟，默认值为 0。 # 支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果。 animation_delay_update: Union[Numeric, JSFunc] &#x3D; 0,) LegendOpts：图例配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class LegendOpts( # 图例的类型。可选值： # &#39;plain&#39;：普通图例。缺省就是普通图例。 # &#39;scroll&#39;：可滚动翻页的图例。当图例数量较多时可以使用。 type_: Optional[str] &#x3D; None, # 图例选择的模式，控制是否可以通过点击图例改变系列的显示状态。默认开启图例选择，可以设成 false 关闭 # 除此之外也可以设成 &#39;single&#39; 或者 &#39;multiple&#39; 使用单选或者多选模式。 selected_mode: Union[str, bool, None] &#x3D; None, # 是否显示图例组件 is_show: bool &#x3D; True, # 图例组件离容器左侧的距离。 # left 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;。 # 如果 left 的值为&#39;left&#39;, &#39;center&#39;, &#39;right&#39;，组件会根据相应的位置自动对齐。 pos_left: Union[str, Numeric, None] &#x3D; None, # 图例组件离容器右侧的距离。 # right 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_right: Union[str, Numeric, None] &#x3D; None, # 图例组件离容器上侧的距离。 # top 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。 # 如果 top 的值为&#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;，组件会根据相应的位置自动对齐。 pos_top: Union[str, Numeric, None] &#x3D; None, # 图例组件离容器下侧的距离。 # bottom 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_bottom: Union[str, Numeric, None] &#x3D; None, # 图例列表的布局朝向。可选：&#39;horizontal&#39;, &#39;vertical&#39; orient: Optional[str] &#x3D; None, # 图例标记和文本的对齐。默认自动（auto） # 根据组件的位置和 orient 决定 # 当组件的 left 值为 &#39;right&#39; 以及纵向布局（orient 为 &#39;vertical&#39;）的时候为右对齐，即为 &#39;right&#39;。 # 可选参数: &#96;auto&#96;, &#96;left&#96;, &#96;right&#96; align: Optional[str] &#x3D; None, # 图例内边距，单位px，默认各方向内边距为5 padding: int &#x3D; 5, # 图例每项之间的间隔。横向布局时为水平间隔，纵向布局时为纵向间隔。 # 默认间隔为 10 item_gap: int &#x3D; 10, # 图例标记的图形宽度。默认宽度为 25 item_width: int &#x3D; 25, # 图例标记的图形高度。默认高度为 14 item_height: int &#x3D; 14, # 图例关闭时的颜色。默认是 #ccc inactive_color: Optional[str] &#x3D; None, # 图例组件字体样式，参考 &#96;series_options.TextStyleOpts&#96; textstyle_opts: Union[TextStyleOpts, dict, None] &#x3D; None, # 图例项的 icon。 # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39; # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 # 可以通过 &#39;path:&#x2F;&#x2F;&#39; 将图标设置为任意的矢量路径。 legend_icon: Optional[str] &#x3D; None,) AxisLineOpts：坐标轴尺寸配置项 12345678910111213141516171819class AxisLineOpts( # 是否显示坐标轴轴线。 is_show: bool &#x3D; True, # X 轴或者 Y 轴的轴线是否在另一个轴的 0 刻度上，只有在另一个轴为数值轴且包含 0 刻度时有效。 is_on_zero: bool &#x3D; True, # 当有双轴时，可以用这个属性手动指定，在哪个轴的 0 刻度上。 on_zero_axis_index: int &#x3D; 0, # 轴线两边的箭头。可以是字符串，表示两端使用同样的箭头；或者长度为 2 的字符串数组，分别表示两端的箭头。 # 默认不显示箭头，即 &#39;none&#39;。 # 两端都显示箭头可以设置为 &#39;arrow&#39;。 # 只在末端显示箭头可以设置为 [&#39;none&#39;, &#39;arrow&#39;]。 symbol: Optional[str] &#x3D; None, # 坐标轴线风格配置项，参考 &#96;series_optionsLineStyleOpts&#96; linestyle_opts: Union[LineStyleOpts, dict, None] &#x3D; None,) AxisPointerOpts：坐标轴指示器配置项 1234567891011121314151617181920212223class AxisPointerOpts( # 默认显示坐标轴指示器 is_show: bool &#x3D; True, # 不同轴的 axisPointer 可以进行联动，在这里设置。联动表示轴能同步一起活动。 # 轴依据他们的 axisPointer 当前对应的值来联动。 # link 是一个数组，其中每一项表示一个 link group，一个 group 中的坐标轴互相联动。 # 具体使用方式可以参见：https:&#x2F;&#x2F;www.echartsjs.com&#x2F;option.html#axisPointer.link link: Sequence[dict] &#x3D; None, # 指示器类型。 # 可选参数如下，默认为 &#39;line&#39; # &#39;line&#39; 直线指示器 # &#39;shadow&#39; 阴影指示器 # &#39;none&#39; 无指示器 type_: str &#x3D; &quot;line&quot;, # 坐标轴指示器的文本标签，坐标轴标签配置项，参考 &#96;series_options.LabelOpts&#96; label: Union[LabelOpts, dict, None] &#x3D; None, # 坐标轴线风格配置项，参考 &#96;series_optionsLineStyleOpts&#96; linestyle_opts: Union[LineStyleOpts, dict, None] &#x3D; None,) AxisOpts：坐标轴配置项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class AxisOpts( # 坐标轴类型。可选： # &#39;value&#39;: 数值轴，适用于连续数据。 # &#39;category&#39;: 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。 # &#39;time&#39;: 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同， # 例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。 # &#39;log&#39; 对数轴。适用于对数数据。 type_: Optional[str] &#x3D; None, # 坐标轴名称。 name: Optional[str] &#x3D; None, # 是否显示 x 轴。 is_show: bool &#x3D; True, # 只在数值轴中（type: &#39;value&#39;）有效。 # 是否是脱离 0 值比例。设置成 true 后坐标刻度不会强制包含零刻度。在双数值轴的散点图中比较有用。 # 在设置 min 和 max 之后该配置项无效。 is_scale: bool &#x3D; False, # 是否反向坐标轴。 is_inverse: bool &#x3D; False, # 坐标轴名称显示位置。可选： # &#39;start&#39;, &#39;middle&#39; 或者 &#39;center&#39;,&#39;end&#39; name_location: str &#x3D; &quot;end&quot;, # 坐标轴名称与轴线之间的距离。 name_gap: Numeric &#x3D; 15, # 坐标轴名字旋转，角度值。 name_rotate: Optional[Numeric] &#x3D; None, # 强制设置坐标轴分割间隔。 # 因为 splitNumber 是预估的值，实际根据策略计算出来的刻度可能无法达到想要的效果， # 这时候可以使用 interval 配合 min、max 强制设定刻度划分，一般不建议使用。 # 无法在类目轴中使用。在时间轴（type: &#39;time&#39;）中需要传时间戳，在对数轴（type: &#39;log&#39;）中需要传指数值。 interval: Optional[Numeric] &#x3D; None, # x 轴所在的 grid 的索引，默认位于第一个 grid。 grid_index: Numeric &#x3D; 0, # x 轴的位置。可选： # &#39;top&#39;, &#39;bottom&#39; # 默认 grid 中的第一个 x 轴在 grid 的下方（&#39;bottom&#39;），第二个 x 轴视第一个 x 轴的位置放在另一侧。 position: Optional[str] &#x3D; None, # Y 轴相对于默认位置的偏移，在相同的 position 上有多个 Y 轴的时候有用。 offset: Numeric &#x3D; 0, # 坐标轴的分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整。 # 默认值是 5 split_number: Numeric &#x3D; 5, # 坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样。 # 类目轴中 boundaryGap 可以配置为 true 和 false。默认为 true，这时候刻度只是作为分隔线， # 标签和数据点都会在两个刻度之间的带(band)中间。 # 非类目轴，包括时间，数值，对数轴，boundaryGap是一个两个值的数组，分别表示数据最小值和最大值的延伸范围 # 可以直接设置数值或者相对的百分比，在设置 min 和 max 后无效。 示例：boundaryGap: [&#39;20%&#39;, &#39;20%&#39;] boundary_gap: Union[str, bool, None] &#x3D; None, # 坐标轴刻度最小值。 # 可以设置成特殊值 &#39;dataMin&#39;，此时取数据在该轴上的最小值作为最小刻度。 # 不设置时会自动计算最小值保证坐标轴刻度的均匀分布。 # 在类目轴中，也可以设置为类目的序数（如类目轴 data: [&#39;类A&#39;, &#39;类B&#39;, &#39;类C&#39;] 中，序数 2 表示 &#39;类C&#39;。 # 也可以设置为负数，如 -3）。 min_: Union[Numeric, str, None] &#x3D; None, # 坐标轴刻度最大值。 # 可以设置成特殊值 &#39;dataMax&#39;，此时取数据在该轴上的最大值作为最大刻度。 # 不设置时会自动计算最大值保证坐标轴刻度的均匀分布。 # 在类目轴中，也可以设置为类目的序数（如类目轴 data: [&#39;类A&#39;, &#39;类B&#39;, &#39;类C&#39;] 中，序数 2 表示 &#39;类C&#39;。 # 也可以设置为负数，如 -3）。 max_: Union[Numeric, str, None] &#x3D; None, # 自动计算的坐标轴最小间隔大小。 # 例如可以设置成1保证坐标轴分割刻度显示成整数。 # 默认值是 0 min_interval: Numeric &#x3D; 0, # 自动计算的坐标轴最大间隔大小。 # 例如，在时间轴（（type: &#39;time&#39;））可以设置成 3600 * 24 * 1000 保证坐标轴分割刻度最大为一天。 max_interval: Optional[Numeric] &#x3D; None, # 坐标轴刻度线配置项，参考 &#96;global_options.AxisLineOpts&#96; axisline_opts: Union[AxisLineOpts, dict, None] &#x3D; None, # 坐标轴刻度配置项，参考 &#96;global_options.AxisTickOpts&#96; axistick_opts: Union[AxisTickOpts, dict, None] &#x3D; None, # 坐标轴标签配置项，参考 &#96;series_options.LabelOpts&#96; axislabel_opts: Union[LabelOpts, dict, None] &#x3D; None, # 坐标轴指示器配置项，参考 &#96;global_options.AxisPointerOpts&#96; axispointer_opts: Union[AxisPointerOpts, dict, None] &#x3D; None, # 坐标轴名称的文字样式，参考 &#96;series_options.TextStyleOpts&#96; name_textstyle_opts: Union[TextStyleOpts, dict, None] &#x3D; None, # 分割区域配置项，参考 &#96;series_options.SplitAreaOpts&#96; splitarea_opts: Union[SplitAreaOpts, dict, None] &#x3D; None, # 分割线配置项，参考 &#96;series_options.SplitLineOpts&#96; splitline_opts: Union[SplitLineOpts, dict] &#x3D; SplitLineOpts(), # 坐标轴次刻度线相关设置，参考 &#96;series_options.MinorTickOpts&#96; minor_tick_opts: Union[MinorTickOpts, dict, None] &#x3D; None, # 坐标轴在 grid 区域中的次分隔线。次分割线会对齐次刻度线 minorTick，参考 &#96;series_options.MinorSplitLineOpts&#96; minor_split_line_opts: Union[MinorSplitLineOpts, dict, None] &#x3D; None,) SingleAxisOpts：单轴配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class SingleAxisOpts( # 坐标轴名称。 name: Optional[str] &#x3D; None, # 坐标轴刻度最大值。 # 可以设置成特殊值 &#39;dataMax&#39;，此时取数据在该轴上的最大值作为最大刻度。 # 不设置时会自动计算最大值保证坐标轴刻度的均匀分布。 # 在类目轴中，也可以设置为类目的序数（如类目轴 data: [&#39;类A&#39;, &#39;类B&#39;, &#39;类C&#39;] 中，序数 2 表示 &#39;类C&#39;。 # 也可以设置为负数，如 -3）。 max_: Union[str, Numeric, None] &#x3D; None, # 坐标轴刻度最小值。 # 可以设置成特殊值 &#39;dataMin&#39;，此时取数据在该轴上的最小值作为最小刻度。 # 不设置时会自动计算最小值保证坐标轴刻度的均匀分布。 # 在类目轴中，也可以设置为类目的序数（如类目轴 data: [&#39;类A&#39;, &#39;类B&#39;, &#39;类C&#39;] 中，序数 2 表示 &#39;类C&#39;。 # 也可以设置为负数，如 -3）。 min_: Union[str, Numeric, None] &#x3D; None, # single 组件离容器左侧的距离。 # left 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;。 # 如果 left 的值为&#39;left&#39;, &#39;center&#39;, &#39;right&#39;，组件会根据相应的位置自动对齐。 pos_left: Optional[str] &#x3D; None, # single组件离容器右侧的距离。 # right 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_right: Optional[str] &#x3D; None, # single组件离容器上侧的距离。 # top 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。 # 如果 top 的值为&#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;，组件会根据相应的位置自动对齐。 pos_top: Optional[str] &#x3D; None, # single组件离容器下侧的距离。 # bottom 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_bottom: Optional[str] &#x3D; None, # single 组件的宽度。默认自适应。 width: Optional[str] &#x3D; None, # single 组件的高度。默认自适应。 height: Optional[str] &#x3D; None, # 轴的朝向，默认水平朝向，可以设置成 &#39;vertical&#39; 垂直朝向。 orient: Optional[str] &#x3D; None, # 坐标轴类型。可选： # &#39;value&#39;: 数值轴，适用于连续数据。 # &#39;category&#39;: 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。 # &#39;time&#39;: 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同， # 例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。 # &#39;log&#39; 对数轴。适用于对数数据。 type_: Optional[str] &#x3D; None,) GraphicGroup：原生图形元素组件 1234567891011class GraphicGroup( # 图形的配置项 graphic_item: Union[GraphicItem, dict, None] &#x3D; None, # 根据其 children 中每个图形元素的 name 属性进行重绘 is_diff_children_by_name: bool &#x3D; False, # 子节点列表，其中项都是一个图形元素定义。 # 目前可以选择 GraphicText，GraphicImage，GraphicRect children: Optional[Sequence[BaseGraphic]] &#x3D; None,) GraphicItem：原生图形配置项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class GraphicItem( # id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 id_: Optional[str] &#x3D; None, # setOption 时指定本次对该图形元素的操作行为。可选： # &#39;merge&#39;：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。 # &#39;replace&#39;：如果已有元素，删除之，新建元素替代之。 # &#39;remove&#39;：删除元素。 action: str &#x3D; &quot;merge&quot;, # 平移（position）：默认值是 [0, 0]。表示 [横向平移的距离, 纵向平移的距离]。右和下为正值。 position: [Sequence, Numeric, None] &#x3D; None, # 旋转（rotation）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。 rotation: Union[Numeric, JSFunc, None] &#x3D; 0, # 缩放（scale）：默认值是 [1, 1]。表示 [横向缩放的倍数, 纵向缩放的倍数]。 scale: Union[Sequence, Numeric, None] &#x3D; None, # origin 指定了旋转和缩放的中心点，默认值是 [0, 0]。 origin: Union[Numeric, Sequence, None] &#x3D; None, # 描述怎么根据父元素进行定位。 # 父元素是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 # 值的类型可以是： # 数值：表示像素值。 # 百分比值：如 &#39;33%&#39;，用父元素的高和此百分比计算出最终值。 # 位置：如 &#39;center&#39;：表示自动居中。 # 注：left 和 right 只有一个可以生效。如果指定 left 或 right，则 shape 里的 x、cx 等定位属性不再生效。 left: Union[Numeric, str, None] &#x3D; None, # 同上 right: Union[Numeric, str, None] &#x3D; None, # 配置和 left 及 right 相同， 注：top 和 bottom 只有一个可以生效。 top: Union[Numeric, str, None] &#x3D; None, # 同上 bottom: Union[Numeric, str, None] &#x3D; None, # 决定此图形元素在定位时，对自身的包围盒计算方式。可选： # &#39;all&#39;：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。这种方式易于使整体都限制在父元素范围中。 # &#39;raw&#39;：表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。这种方式易于内容超出父元素范围的定位方式。 bounding: str &#x3D; &quot;all&quot;, # z 方向的高度，决定层叠关系。 z: Numeric &#x3D; 0, # 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 z_level: Numeric &#x3D; 0, # 是否不响应鼠标以及触摸事件。 is_silent: bool &#x3D; False, # 节点是否可见。 is_invisible: bool &#x3D; False, # 节点是否完全被忽略（既不渲染，也不响应事件）。 is_ignore: bool &#x3D; False, # 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 cursor: str &#x3D; &quot;pointer&quot;, # 图形元素是否可以被拖拽。 is_draggable: bool &#x3D; False, # 是否渐进式渲染。当图形元素过多时才使用。 is_progressive: bool &#x3D; False, # 用于描述此 group 的宽。这个宽只用于给子节点定位。 # 即便当宽度为零的时候，子节点也可以使用 left: &#39;center&#39; 相对于父节点水平居中。 width: Numeric &#x3D; 0, # 用于描述此 group 的高。这个高只用于给子节点定位。 # 即便当高度为零的时候，子节点也可以使用 top: &#39;middle&#39; 相对于父节点垂直居中。 height: Numeric &#x3D; 0,) GraphicBasicStyleOpts：原生图形基础配置项 12345678910111213141516171819202122class GraphicBasicStyleOpts( # 填充色。 fill: str &#x3D; &quot;#000&quot;, # 笔画颜色。 stroke: Optional[str] &#x3D; None, # 笔画宽度。 line_width: Numeric &#x3D; 0, # 阴影宽度。 shadow_blur: Optional[Numeric] &#x3D; None, # 阴影 X 方向偏移。 shadow_offset_x: Optional[Numeric] &#x3D; None, # 阴影 Y 方向偏移。 shadow_offset_y: Optional[Numeric] &#x3D; None, # 阴影颜色。 shadow_color: Optional[str] &#x3D; None,) GraphicShapeOpts：原生图形形状配置项 123456789101112131415161718192021class GraphicShapeOpts( # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 pos_x: Numeric &#x3D; 0, # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 pos_y: Numeric &#x3D; 0, # 图形元素的宽度。 width: Numeric &#x3D; 0, # 图形元素的高度。 height: Numeric &#x3D; 0, # 可以用于设置圆角矩形。r: [r1, r2, r3, r4]， 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4。 # 可以缩写，例如： # r 缩写为 1 相当于 [1, 1, 1, 1] # r 缩写为 [1] 相当于 [1, 1, 1, 1] # r 缩写为 [1, 2] 相当于 [1, 2, 1, 2] # r 缩写为 [1, 2, 3]1 相当于[1, 2, 3, 2]&#96; r: Union[Sequence, Numeric, None] &#x3D; None,) GraphicImage：原始图形图片配置项 1234567class GraphicImage( # 图形的配置项，参考 GraphicItem graphic_item: Union[GraphicItem, dict, None] &#x3D; None, # 图形图片样式的配置项 graphic_imagestyle_opts: Union[GraphicImageStyleOpts, dict, None] &#x3D; None,) GraphicImageStyleOpts：原始图形图片样式配置项 12345678910111213141516171819202122class GraphicImageStyleOpts( # 图片的内容，可以是图片的 URL。 image: Optional[str] &#x3D; None, # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 pos_x: Numeric &#x3D; 0, # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 pos_y: Numeric &#x3D; 0, # 图形元素的宽度。 width: Numeric &#x3D; 0, # 图形元素的高度。 height: Numeric &#x3D; 0, # 透明度 0 到 1。1 即完整显示 opacity: Numeric &#x3D; 1, # 图形基本配置项，参考 GraphicBasicStyleOpts graphic_basicstyle_opts: Union[GraphicBasicStyleOpts, dict, None] &#x3D; None,) GraphicText：原始图形文本配置项 1234567class GraphText( # 图形的配置项，参考 GraphicItem graphic_item: Union[GraphicItem, dict, None] &#x3D; None, # 图形文本样式的配置项 graphic_textstyle_opts: Union[GraphicTextStyleOpts, dict, None] &#x3D; None,) GraphicTextStyleOpts：原生图形文本样式配置项 123456789101112131415161718192021222324252627282930class GraphicTextStyleOpts( # 文本块文字。可以使用 \\n 来换行。 text: Optional[JSFunc] &#x3D; None, # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 pos_x: Numeric &#x3D; 0, # 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 pos_y: Numeric &#x3D; 0, # 字体大小、字体类型、粗细、字体样式。 # 例如： # &#x2F;&#x2F; size | family # font: &#39;2em &quot;STHeiti&quot;, sans-serif&#39; # &#x2F;&#x2F; style | weight | size | family # font: &#39;italic bolder 16px cursive&#39; # &#x2F;&#x2F; weight | size | family # font: &#39;bolder 2em &quot;Microsoft YaHei&quot;, sans-serif&#39; font: Optional[str] &#x3D; None, # 水平对齐方式，取值：&#39;left&#39;, &#39;center&#39;, &#39;right&#39;。默认值为：&#39;left&#39; # 如果为 &#39;left&#39;，表示文本最左端在 x 值上。如果为 &#39;right&#39;，表示文本最右端在 x 值上。 text_align: str &#x3D; &quot;left&quot;, # 垂直对齐方式，取值：&#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。默认值为：&#39;None&#39; text_vertical_align: Optional[str] &#x3D; None, # 图形基本配置项，参考 GraphicBasicStyleOpts graphic_basicstyle_opts: Union[GraphicBasicStyleOpts, dict, None] &#x3D; None,) GraphicRect：原生图形矩形配置项 12345678910class GraphicRect( # 图形的配置项，参考 GraphicItem graphic_item: Union[GraphicItem, dict, None] &#x3D; None, # 图形的形状配置项，参考 GraphicShapeOpts graphic_shape_opts: Union[GraphicShapeOpts, dict, None] &#x3D; None, # 图形基本配置项，参考 GraphicBasicStyleOpts graphic_basicstyle_opts: Union[GraphicBasicStyleOpts, dict, None] &#x3D; None,) PolarOpts：极坐标系配置 1234567891011121314class PolarOpts( # 极坐标系的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。 # 支持设置成百分比，设置成百分比时第一项是相对于容器宽度，第二项是相对于容器高度。 center: Optional[Sequence] &#x3D; None, # 极坐标系的半径。可以为如下类型： # number：直接指定外半径值。 # string：例如，&#39;20%&#39;，表示外半径为可视区尺寸（容器高宽中较小一项）的 20% 长度。 # Array.&lt;number|string&gt;：数组的第一项是内半径，第二项是外半径。每一项遵从上述 number string 的描述。 radius: Optional[Union[Sequence, str]] &#x3D; None, # 本坐标系特定的 tooltip 设定。参考 &#96;global_options.TooltipOpts&#96; tooltip_opts: TooltipOpts &#x3D; None,) TooltipOpts类,工具提示选项：提示框配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class TooltipOpts( # 是否显示提示框组件，包括提示框浮层和 axisPointer。 is_show: bool &#x3D; True, # 触发类型。可选： # &#39;item&#39;: 数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。 # &#39;axis&#39;: 坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用。 # &#39;none&#39;: 什么都不触发 trigger: str &#x3D; &quot;item&quot;, # 提示框触发的条件，可选： # &#39;mousemove&#39;: 鼠标移动时触发。 # &#39;click&#39;: 鼠标点击时触发。 # &#39;mousemove|click&#39;: 同时鼠标移动和点击时触发。 # &#39;none&#39;: 不在 &#39;mousemove&#39; 或 &#39;click&#39; 时触发， trigger_on: str &#x3D; &quot;mousemove|click&quot;, # 指示器类型。可选 # &#39;line&#39;：直线指示器 # &#39;shadow&#39;：阴影指示器 # &#39;none&#39;：无指示器 # &#39;cross&#39;：十字准星指示器。其实是种简写，表示启用两个正交的轴的 axisPointer。 axis_pointer_type: str &#x3D; &quot;line&quot;, # 是否显示提示框浮层，默认显示。 # 只需 tooltip 触发事件或显示 axisPointer 而不需要显示内容时可配置该项为 false。 is_show_content: bool &#x3D; True, # 是否永远显示提示框内容， # 默认情况下在移出可触发提示框区域后一定时间后隐藏，设置为 true 可以保证一直显示提示框内容。 is_always_show_content: bool &#x3D; False, # 浮层显示的延迟，单位为 ms，默认没有延迟，也不建议设置。 show_delay: Numeric &#x3D; 0, # 浮层隐藏的延迟，单位为 ms，在 alwaysShowContent 为 true 的时候无效。 hide_delay: Numeric &#x3D; 100, # 提示框浮层的位置，默认不设置时位置会跟随鼠标的位置。 # 1、通过数组配置： # 绝对位置，相对于容器左侧 10px, 上侧 10 px &#x3D;&#x3D;&#x3D;&gt; position: [10, 10] # 相对位置，放置在容器正中间 &#x3D;&#x3D;&#x3D;&gt; position: [&#39;50%&#39;, &#39;50%&#39;] # 2、通过回调函数配置 # 3、固定参数配置：&#39;inside&#39;，&#39;top&#39;，&#39;left&#39;，&#39;right&#39;，&#39;bottom&#39; position: Union[str, Sequence, JSFunc] &#x3D; None, # 标签内容格式器，支持字符串模板和回调函数两种形式，字符串模板与回调函数返回的字符串均支持用 \\n 换行。 # 字符串模板 模板变量有： # &#123;a&#125;：系列名。 # &#123;b&#125;：数据名。 # &#123;c&#125;：数据值。 # &#123;@xxx&#125;：数据中名为 &#39;xxx&#39; 的维度的值，如 &#123;@product&#125; 表示名为 &#39;product&#39;&#96; 的维度的值。 # &#123;@[n]&#125;：数据中维度 n 的值，如&#123;@[3]&#125;&#96; 表示维度 3 的值，从 0 开始计数。 # 示例：formatter: &#39;&#123;b&#125;: &#123;@score&#125;&#39; # # 回调函数，回调函数格式： # (params: Object|Array) &#x3D;&gt; string # 参数 params 是 formatter 需要的单个数据集。格式如下： # &#123; # componentType: &#39;series&#39;, # &#x2F;&#x2F; 系列类型 # seriesType: string, # &#x2F;&#x2F; 系列在传入的 option.series 中的 index # seriesIndex: number, # &#x2F;&#x2F; 系列名称 # seriesName: string, # &#x2F;&#x2F; 数据名，类目名 # name: string, # &#x2F;&#x2F; 数据在传入的 data 数组中的 index # dataIndex: number, # &#x2F;&#x2F; 传入的原始数据项 # data: Object, # &#x2F;&#x2F; 传入的数据值 # value: number|Array, # &#x2F;&#x2F; 数据图形的颜色 # color: string, # &#125; formatter: Optional[str] &#x3D; None, # 提示框浮层的背景颜色。 background_color: Optional[str] &#x3D; None, # 提示框浮层的边框颜色。 border_color: Optional[str] &#x3D; None, # 提示框浮层的边框宽。 border_width: Numeric &#x3D; 0, # 文字样式配置项，参考 &#96;series_options.TextStyleOpts&#96; textstyle_opts: TextStyleOpts &#x3D; TextStyleOpts(font_size&#x3D;14),) BrushOpts：区域选择组件配置项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class BrushOpts( # 使用在 toolbox 中的按钮。默认值为 [&quot;rect&quot;, &quot;polygon&quot;, &quot;keep&quot;, &quot;clear&quot;] # brush 相关的 toolbox 按钮有： # &quot;rect&quot;：开启矩形选框选择功能。 # &quot;polygon&quot;：开启任意形状选框选择功能。 # &quot;lineX&quot;：开启横向选择功能。 # &quot;lineY&quot;&#39;：开启纵向选择功能。 # &quot;keep&quot;：切换『单选』和『多选』模式。后者可支持同时画多个选框。前者支持单击清除所有选框。 # &quot;clear&quot;：清空所有选框。 tool_box: Optional[Sequence] &#x3D; None, # 不同系列间，选中的项可以联动。 # brush_link 配置项是一个列表，内容是 seriesIndex，指定了哪些 series 可以被联动。 # 例如可以是： # [3, 4, 5] 表示 seriesIndex 为 3, 4, 5 的 series 可以被联动。 # &quot;all&quot; 表示所有 series 都进行 brushLink。 # None 表示不启用 brush_link 功能。 brush_link: Union[Sequence, str] &#x3D; None, # 指定哪些 series 可以被刷选，可取值为： # &quot;all&quot;: 所有 series # series index 列表, 如 [0, 4, 2]，表示指定这些 index 所对应的坐标系。 # 某个 series index, 如 0，表示这个 index 所对应的坐标系。 series_index: Union[Sequence, Numeric, str] &#x3D; None, # 指定哪些 geo 可以被刷选。可以设置 brush 是全局的还是属于坐标系的。 # 全局 brush # 在 echarts 实例中任意地方刷选。这是默认情况。如果没有指定为坐标系 brush，就是全局 brush。 # 坐标系 brush # 在指定的坐标系中刷选。选框可以跟随坐标系的缩放和平移（ roam 和 dataZoom ）而移动。 # 坐标系 brush 实际更为常用，尤其是在 geo 中。 # 通过指定 brush.geoIndex 或 brush.xAxisIndex 或 brush.yAxisIndex 来规定可以在哪些坐标系中进行刷选。 # 指定哪些 series 可以被刷选，可取值为： # &quot;all&quot;: 表示所有 series # series index 列表, 如 [0, 4, 2]，表示指定这些 index 所对应的坐标系。 # 某个 series index, 如 0，表示这个 index 所对应的坐标系。 geo_index: Union[Sequence, Numeric, str] &#x3D; None, # 指定哪些 xAxisIndex 可以被刷选。可以设置 brush 是全局的还是属于坐标系的。 # 全局 brush # 在 echarts 实例中任意地方刷选。这是默认情况。如果没有指定为坐标系 brush，就是全局 brush。 # 坐标系 brush # 在指定的坐标系中刷选。选框可以跟随坐标系的缩放和平移（ roam 和 dataZoom ）而移动。 # 坐标系 brush 实际更为常用，尤其是在 geo 中。 # 通过指定 brush.geoIndex 或 brush.xAxisIndex 或 brush.yAxisIndex 来规定可以在哪些坐标系中进行刷选。 # 指定哪些 series 可以被刷选，可取值为： # &quot;all&quot;: 表示所有 series # series index 列表, 如 [0, 4, 2]，表示指定这些 index 所对应的坐标系。 # 某个 series index, 如 0，表示这个 index 所对应的坐标系。 x_axis_index: Union[Sequence, Numeric, str] &#x3D; None, # 指定哪些 yAxisIndex 可以被刷选。可以设置 brush 是全局的还是属于坐标系的。 # 全局 brush # 在 echarts 实例中任意地方刷选。这是默认情况。如果没有指定为坐标系 brush，就是全局 brush。 # 坐标系 brush # 在指定的坐标系中刷选。选框可以跟随坐标系的缩放和平移（ roam 和 dataZoom ）而移动。 # 坐标系 brush 实际更为常用，尤其是在 geo 中。 # 通过指定 brush.geoIndex 或 brush.xAxisIndex 或 brush.yAxisIndex 来规定可以在哪些坐标系中进行刷选。 # 指定哪些 series 可以被刷选，可取值为： # &quot;all&quot;: 表示所有 series # series index 列表, 如 [0, 4, 2]，表示指定这些 index 所对应的坐标系。 # 某个 series index, 如 0，表示这个 index 所对应的坐标系。 y_axis_index: Union[Sequence, Numeric, str] &#x3D; None, # 默认的刷子类型。默认值为 rect。 # 可选参数如下： # &quot;rect&quot;：矩形选框。 # &quot;polygon&quot;：任意形状选框。 # &quot;lineX&quot;：横向选择。 # &quot;lineY&quot;：纵向选择。 brush_type: str &#x3D; &quot;rect&quot;, # 默认的刷子的模式。可取值为： # 默认为 single # &quot;single&quot;：单选。 # &quot;multiple&quot;：多选。 brush_mode: str &#x3D; &quot;single&quot;, # 已经选好的选框是否可以被调整形状或平移。默认值为 True transformable: bool &#x3D; True, # 选框的默认样式，值为 # &#123; # &quot;borderWidth&quot;: 1, # &quot;color&quot;: &quot;rgba(120,140,180,0.3)&quot;, # &quot;borderColor&quot;: &quot;rgba(120,140,180,0.8)&quot; # &#125;, brush_style: Optional[dict] &#x3D; None, # 默认情况，刷选或者移动选区的时候，会不断得发 brushSelected 事件，从而告诉外界选中的内容。 # 但是频繁的事件可能导致性能问题，或者动画效果很差。 # 所以 brush 组件提供了 brush.throttleType，brush.throttleDelay 来解决这个问题。 # throttleType 取值可以是： # &quot;debounce&quot;：表示只有停止动作了（即一段时间没有操作了），才会触发事件。时间阈值由 brush.throttleDelay 指定。 # &quot;fixRate&quot;：表示按照一定的频率触发事件，时间间隔由 brush.throttleDelay 指定。 throttle_type: str &#x3D; &quot;fixRate&quot;, # 默认为 0 表示不开启 throttle。 throttle_delay: Numeric &#x3D; 0, # 在 brush_mode 为 &quot;single&quot; 的情况下，是否支持单击清除所有选框。 remove_on_click: bool &#x3D; True, # 定义在选中范围外的视觉元素。最终参数以字典的形式进行配置 # 可选的视觉元素有： # symbol: 图元的图形类别。 # symbolSize: 图元的大小。 # color: 图元的颜色。 # colorAlpha: 图元的颜色的透明度。 # opacity: 图元以及其附属物（如文字标签）的透明度。 # colorLightness: 颜色的明暗度，参见 https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HSL_and_HSV。 # colorSaturation: 颜色的饱和度，参见 https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HSL_and_HSV。 # colorHue: 颜色的色调，参见 https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HSL_and_HSV。 out_of_brush: dict &#x3D; None,) DataZoomOpts：区域缩放配置项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class DataZoomOpts( # 是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。 is_show: bool &#x3D; True, # 组件类型，可选 &quot;slider&quot;, &quot;inside&quot; type_: str &#x3D; &quot;slider&quot;, # 拖动时，是否实时更新系列的视图。如果设置为 false，则只在拖拽结束的时候更新。 is_realtime: bool &#x3D; True, # 数据窗口范围的起始百分比。范围是：0 ~ 100。表示 0% ~ 100%。 range_start: Union[Numeric, None] &#x3D; 20, # 数据窗口范围的结束百分比。范围是：0 ~ 100 range_end: Union[Numeric, None] &#x3D; 80, # 数据窗口范围的起始数值。如果设置了 start 则 startValue 失效。 start_value: Union[int, str, None] &#x3D; None, # 数据窗口范围的结束数值。如果设置了 end 则 endValue 失效。 end_value: Union[int, str, None] &#x3D; None, # 布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴 # 可选值为：&#39;horizontal&#39;, &#39;vertical&#39; orient: str &#x3D; &quot;horizontal&quot;, # 设置 dataZoom-inside 组件控制的 x 轴（即 xAxis，是直角坐标系中的概念，参见 grid）。 # 不指定时，当 dataZoom-inside.orient 为 &#39;horizontal&#39;时，默认控制和 dataZoom 平行的第一个 xAxis # 如果是 number 表示控制一个轴，如果是 Array 表示控制多个轴。 xaxis_index: Union[int, Sequence[int], None] &#x3D; None, # 设置 dataZoom-inside 组件控制的 y 轴（即 yAxis，是直角坐标系中的概念，参见 grid）。 # 不指定时，当 dataZoom-inside.orient 为 &#39;horizontal&#39;时，默认控制和 dataZoom 平行的第一个 yAxis # 如果是 number 表示控制一个轴，如果是 Array 表示控制多个轴。 yaxis_index: Union[int, Sequence[int], None] &#x3D; None, # 是否锁定选择区域（或叫做数据窗口）的大小。 # 如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。 is_zoom_lock: bool &#x3D; False, # dataZoom-slider 组件离容器左侧的距离。 # left 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;。 # 如果 left 的值为 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;，组件会根据相应的位置自动对齐。 pos_left: Optional[str] &#x3D; None, # dataZoom-slider 组件离容器上侧的距离。 # top 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。 # 如果 top 的值为 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;，组件会根据相应的位置自动对齐。 pos_top: Optional[str] &#x3D; None, # dataZoom-slider 组件离容器右侧的距离。 # right 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 # 默认自适应。 pos_right: Optional[str] &#x3D; None, # dataZoom-slider组件离容器下侧的距离。 # bottom 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 # 默认自适应。 pos_bottom: Optional[str] &#x3D; None, # dataZoom 的运行原理是通过数据过滤以及在内部设置轴的显示窗口来达到数据窗口缩放的效果。 # &#39;filter&#39;：当前数据窗口外的数据，被过滤掉。即会影响其他轴的数据范围。 # 每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。 # &#39;weakFilter&#39;：当前数据窗口外的数据，被过滤掉。即会影响其他轴的数据范围。 # 每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。 # &#39;empty&#39;：当前数据窗口外的数据，被设置为空。即不会影响其他轴的数据范围。 # &#39;none&#39;: 不过滤数据，只改变数轴范围。 filter_mode: str &#x3D; &quot;filter&quot;) ToolBox 工具箱 ToolBoxFeatureSaveAsImagesOpts：工具箱保存图片配置项 12345678910111213141516171819202122232425262728class ToolBoxFeatureSaveAsImageOpts( # 保存的图片格式。支持 &#39;png&#39; 和 &#39;jpeg&#39;。 type_: str &#x3D; &quot;png&quot;, # 保存的文件名称，默认使用 title.text 作为名称。 name: Optional[str] &#x3D; None, # 保存的图片背景色，默认使用 backgroundColor，如果backgroundColor不存在的话会取白色。 background_color: str &#x3D; &quot;auto&quot;, # 如果图表使用了 echarts.connect 对多个图表进行联动，则在导出图片时会导出这些联动的图表。该配置项决定了图表与图表之间间隙处的填充色。 connected_background_color: str &#x3D; &quot;#fff&quot;, # 保存为图片时忽略的组件列表，默认忽略工具栏。 exclude_components: Optional[Sequence[str]] &#x3D; None, # 是否显示该工具。 is_show: bool &#x3D; True, # 提示语 title: str &#x3D; &quot;保存为图片&quot;, # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 icon: Optional[JSFunc] &#x3D; None, # 保存图片的分辨率比例，默认跟容器相同大小，如果需要保存更高分辨率的，可以设置为大于 1 的值，例如 2。 pixel_ratio: Numeric &#x3D; 1,): ToolBoxFeatureRestoreOpts：工具箱还原配置项 12345678910class ToolBoxFeatureRestoreOpts( # 是否显示该工具。 is_show: bool &#x3D; True, # 提示语 title: str &#x3D; &quot;还原&quot;, # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 icon: Optional[JSFunc] &#x3D; None): ToolBoxFeatureDataViewOpts：工具箱数据视图工具 12345678910111213141516171819202122232425262728293031323334353637383940class ToolBoxFeatureDataViewOpts( # 是否显示该工具。 is_show: bool &#x3D; True, # 提示语 title: str &#x3D; &quot;还原&quot;, # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 icon: Optional[JSFunc] &#x3D; None # 是否不可编辑（只读）。默认为 False is_read_only: bool &#x3D; False, # 自定义 dataView 展现函数，用以取代默认的 textarea 使用更丰富的数据编辑。可以返回 dom 对象或者 html 字符串。 option_to_content: Optional[JSFunc] &#x3D; None, # 在使用 optionToContent 的情况下，如果支持数据编辑后的刷新，需要自行通过该函数实现组装 option 的逻辑。 content_to_option: Optional[JSFunc] &#x3D; None, # 数据视图上有三个话术，默认是[&#39;数据视图&#39;, &#39;关闭&#39;, &#39;刷新&#39;]。 lang: Optional[Sequence[str]] &#x3D; None, # 数据视图浮层背景色。 background_color: str &#x3D; &quot;#fff&quot;, # 数据视图浮层文本输入区背景色。 text_area_color: str &#x3D; &quot;#fff&quot;, # 数据视图浮层文本输入区边框颜色。 text_area_border_color: str &#x3D; &quot;#333&quot;, # 文本颜色。 text_color: str &#x3D; &quot;#000&quot;, # 按钮颜色。 button_color: str &#x3D; &quot;#c23531&quot;, # 按钮文本颜色。 button_text_color: str &#x3D; &quot;#fff&quot;,): ToolBoxFeatureDataZoomOpts：工具箱区域缩放配置项 1234567891011121314151617181920212223242526272829303132333435class ToolBoxFeatureDataZoomOpts( # 是否显示该工具。 is_show: bool &#x3D; True, # 提示语 zoom_title: str &#x3D; &quot;区域缩放&quot;, # 提示语 back_title: str &#x3D; &quot;区域缩放还原&quot;, # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 zoom_icon: Optional[JSFunc] &#x3D; None, # 可以通过 &#39;image:&#x2F;&#x2F;url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。 back_icon: Optional[JSFunc] &#x3D; None, # 指定哪些 xAxis 被控制。如果缺省则控制所有的 x 轴。 # 如果设置为 false 则不控制任何x轴。如果设置成 3 则控制 axisIndex 为 3 的 x 轴。 # 如果设置为 [0, 3] 则控制 axisIndex 为 0 和 3 的 x 轴。 xaxis_index: Union[Numeric, Sequence, bool] &#x3D; None, # 指定哪些 yAxis 被控制。如果缺省则控制所有的 y 轴。 # 如果设置为 false 则不控制任何y轴。如果设置成 3 则控制 axisIndex 为 3 的 y 轴。 # 如果设置为 [0, 3] 则控制 axisIndex 为 0 和 3 的 y 轴。 yaxis_index: Union[Numeric, Sequence, bool] &#x3D; None, # dataZoom 的运行原理是通过数据过滤以及在内部设置轴的显示窗口来达到数据窗口缩放的效果。 # &#39;filter&#39;：当前数据窗口外的数据，被过滤掉。即会影响其他轴的数据范围。 # 每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。 # &#39;weakFilter&#39;：当前数据窗口外的数据，被过滤掉。即会影响其他轴的数据范围。 # 每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。 # &#39;empty&#39;：当前数据窗口外的数据，被设置为空。即不会影响其他轴的数据范围。 # &#39;none&#39;: 不过滤数据，只改变数轴范围。 filter_mode: str &#x3D; &quot;filter&quot;,): ToolBoxFeatureMagicTypeOpts：工具箱动态类型切换配置项 123456789101112131415161718192021222324252627282930313233class ToolBoxFeatureMagicTypeOpts( # 是否显示该工具。 is_show: bool &#x3D; True, # 启用的动态类型 # 包括&#39;line&#39;（切换为折线图）, &#39;bar&#39;（切换为柱状图）, # &#39;stack&#39;（切换为堆叠模式）, &#39;tiled&#39;（切换为平铺模式）。 type_: Optional[Sequence] &#x3D; None, # 各个类型的标题文本，可以分别配置。 line_title: str &#x3D; &quot;切换为折线图&quot;, # 各个类型的标题文本，可以分别配置。 bar_title: str &#x3D; &quot;切换为柱状图&quot;, # 各个类型的标题文本，可以分别配置。 stack_title: str &#x3D; &quot;切换为堆叠&quot;, # 各个类型的标题文本，可以分别配置。 tiled_title: str &#x3D; &quot;切换为平铺&quot;, # 各个类型的 icon path，可以分别配置。 line_icon: Optional[JSFunc] &#x3D; None, # 各个类型的 icon path，可以分别配置。 bar_icon: Optional[JSFunc] &#x3D; None, # 各个类型的 icon path，可以分别配置。 stack_icon: Optional[JSFunc] &#x3D; None, # 各个类型的 icon path，可以分别配置。 tiled_icon: Optional[JSFunc] &#x3D; None,): ToolBoxFeatureBrushOpts：工具箱选框组件配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class ToolBoxFeatureBrushOpts( # 使用的按钮，取值： # &#39;rect&#39;：开启矩形选框选择功能。 # &#39;polygon&#39;：开启任意形状选框选择功能。 # &#39;lineX&#39;：开启横向选择功能。 # &#39;lineY&#39;：开启纵向选择功能。 # &#39;keep&#39;：切换『单选』和『多选』模式。后者可支持同时画多个选框。前者支持单击清除所有选框。 # &#39;clear&#39;：清空所有选框。 type_: Optional[str] &#x3D; None, # 每个按钮的 icon path。 rect_icon: Optional[JSFunc] &#x3D; None, # 每个按钮的 icon path。 polygon_icon: Optional[JSFunc] &#x3D; None, # 每个按钮的 icon path。 line_x_icon: Optional[JSFunc] &#x3D; None, # 每个按钮的 icon path。 line_y_icon: Optional[JSFunc] &#x3D; None, # 每个按钮的 icon path。 keep_icon: Optional[JSFunc] &#x3D; None, # 每个按钮的 icon path。 clear_icon: Optional[JSFunc] &#x3D; None, # 标题文本。 rect_title: str &#x3D; &quot;矩形选择&quot;, # 标题文本。 polygon_title: str &#x3D; &quot;圈选&quot;, # 标题文本。 line_x_title: str &#x3D; &quot;横向选择&quot;, # 标题文本。 line_y_title: str &#x3D; &quot;纵向选择&quot;, # 标题文本。 keep_title: str &#x3D; &quot;保持选择&quot;, # 标题文本。 clear_title: str &#x3D; &quot;清除选择&quot;,): ToolBoxFeatureOpts：工具箱工具配置项 12345678910111213141516171819class ToolBoxFeatureOpts( # 保存为图片 save_as_image: Union[ToolBoxFeatureSaveAsImageOpts, dict] &#x3D; ToolBoxFeatureSaveAsImageOpts(), # 配置项还原 restore: Union[ToolBoxFeatureRestoreOpts, dict] &#x3D; ToolBoxFeatureRestoreOpts(), # 数据视图工具，可以展现当前图表所用的数据，编辑后可以动态更新 data_view: Union[ToolBoxFeatureDataViewOpts, dict] &#x3D; ToolBoxFeatureDataViewOpts(), # 数据区域缩放。（目前只支持直角坐标系的缩放） data_zoom: Union[ToolBoxFeatureDataZoomOpts, dict] &#x3D; ToolBoxFeatureDataZoomOpts(), # 动态类型切换。 magic_type: Union[ToolBoxFeatureMagicTypeOpts, dict] &#x3D; ToolBoxFeatureMagicTypeOpts(), # 选框组件的控制按钮。 brush: Union[ToolBoxFeatureBrushOpts, dict] &#x3D; ToolBoxFeatureBrushOpts(),): 工具箱选择：工具箱配置项 12345678910111213141516171819202122232425262728293031class ToolboxOpts( # 是否显示工具栏组件 is_show: bool &#x3D; True, # 工具栏 icon 的布局朝向。 # 可选：&#39;horizontal&#39;, &#39;vertical&#39; orient: str &#x3D; &quot;horizontal&quot;, # 工具栏组件离容器左侧的距离。 # left 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;left&#39;, &#39;center&#39;, &#39;right&#39;。 # 如果 left 的值为&#39;left&#39;, &#39;center&#39;, &#39;right&#39;，组件会根据相应的位置自动对齐 pos_left: str &#x3D; &quot;80%&quot;, # 工具栏组件离容器右侧的距离。 # right 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_right: Optional[str] &#x3D; None, # 工具栏组件离容器上侧的距离。 # top 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比， # 也可以是 &#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;。 # 如果 top 的值为&#39;top&#39;, &#39;middle&#39;, &#39;bottom&#39;，组件会根据相应的位置自动对齐。 pos_top: Optional[str] &#x3D; None, # 工具栏组件离容器下侧的距离。 # bottom 的值可以是像 20 这样的具体像素值，可以是像 &#39;20%&#39; 这样相对于容器高宽的百分比。 pos_bottom: Optional[str] &#x3D; None, # 各工具配置项，参考 &#96;global_options.ToolBoxFeatureOpts&#96; feature: Union[ToolBoxFeatureOpts, dict] &#x3D; ToolBoxFeatureOpts(),):","categories":[],"tags":[{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"}]},{"title":"linux_vi编辑器","slug":"linux_vi编辑器","date":"2020-07-29T12:12:54.000Z","updated":"2020-07-31T13:55:07.706Z","comments":true,"path":"2020/07/29/linux-vi-bian-ji-qi/","link":"","permalink":"http://yoursite.com/2020/07/29/linux-vi-bian-ji-qi/","excerpt":"","text":"linux vi 编辑器 命令模式vi启动后默认进入的是命令模式，按一下[Esc]键可以返回命令模式。在命令模式中输入字幕“i”就可以进入vi的输入模式编辑文件。 vi 的启动和退出 启动 直接输入命令vi不指定文件名，由于这是一个没有命名的空文件，显示了vi的版本信息。使用vi打开文件，如果文件存在打开存在文件；如果不存在的话，将以我们指定的参数作为文件名。 光标移动 方向键 向上移动光标：k 向左移动光标：h 向右移动光标：l 向下移动光标：j 翻页 Ctrl+F 向前翻整页 Ctrl+U 向前翻半页 Ctrl+B 向后翻整页 Ctrl+D 向后翻半页 行内快速跳转 ^ 移动到本行行首 $ 移动到本行行尾 在命令模式下，使用以下命令可以快速的在行间跳转 1G 跳转到文件首行 G 跳转到尾行 #G 跳转到文件的#行 删除操作 (命令模式) x 删除光标处的单个字符 dd 删除光标所在行 dw 删除当前字符到单词尾包括空格的所有字符 #x 例如3x删除光标处向右的三个字符 #dd 例如3dd从当前行开始向下删除三行文本 复制操作 yy 命令复制当前整行的内容到vi缓冲区 yw 复制当前光标所在位置到单词尾字符的内容到vi缓存区，相当于复制一个单词 y$ 复制光标所在位置到行尾内容到缓存区 y^ 复制光标所在位置到行首内容到缓存区 #yy例如：5yy就是复制5行 #yw例如：2yw就是复制两个单词 恢复文件 vi在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以 .swp结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理 O 只读打开，不改变文件内容 E 继续编辑文件，不恢复.swp文件保存的内容 R 将恢复上次编辑以后未保存文件内容 Q 退出vi D 删除.swp文件+ 或者使用vi －r 文件名来恢复未保存的内容 输入模式 在这个模式中我们可以编辑、修改、输入等编辑工作，在编辑器最后一行显示一个“--INSERT--”标志着vi进入了输入模式。当需要保存文件时，先返回命令模式，再进入末行模式保存。 Home 光标到行首 End 光标到行尾 Page Up 和 Page Down 上下翻页 Delect 删除光标位置的字符 编辑操作 进入输入模式命令 i 插入命令 a 附加命令 o 打开命令 c 修改命令 r 取代命令 s 替换命令 Esc 退出命令 末行模式 在命令模式输入&quot;: &quot;即可进入该模式 查找和替换 查找 至上而下的查找 / 要查找的字符窜，其中/代表从光标所在位置起开始查找，例如：/ work 至下而上的查找 ？要查找的字符窜 例如：/ work 替换 如果替换的范围较大时，在所有的命令尾加一个c命令，强制每个替换需要用户进行确认，例如:s/old/new/c 或s/old/new/gc :s/old/new 用new替换行中首次出现的old : s/old/new/g 用new替换行中所有出现的old :#,# s/old/new/g 用new替换从第＃行到第＃行中出现的old ：% s/old/new/g 用new替换整篇中出现的old 保存文件 如果文件已经有文件名，我们在末行模式直接输入w保存，如果没有文件名，输入w 文件名进行保存或另存为。例如：w test其中test是文件名。 退出 q! : 强制退出，不保存当前文件内容 q : 正常退出，不保存需改 wq : 保存退出 wq!: 保存强制退出 显示行号和取消行号(末行模式使用) set nu 显示行号 set nonu 取消行号 撤销操作 u 命令取消最近一次的操作，可以使用多次来恢复原有的操作 U 取消所有操作 Ctrl+R 可以恢复对使用u命令的操作","categories":[],"tags":[{"name":"Linux_study","slug":"Linux-study","permalink":"http://yoursite.com/tags/Linux-study/"}]},{"title":"linux_常用命令","slug":"linux_常用命令","date":"2020-07-29T12:12:54.000Z","updated":"2020-07-31T13:54:39.759Z","comments":true,"path":"2020/07/29/linux-chang-yong-ming-ling/","link":"","permalink":"http://yoursite.com/2020/07/29/linux-chang-yong-ming-ling/","excerpt":"","text":"基础命令命令格式: 命令字 [命令选项] [命令参数] Command [option] [arguments] 文件类型 “ * “在文件名后: 可执行文件 “ @ “在文件名后: 符号链接 “ / “在文件名后: 目录名 1. ls：列出目录内容 语法 12345678910111213141516ls [-laAbBcCdDfFgGHiklLmnNopqQrRsStuUvxX] [-I &lt;范本样式&gt;] [-T &lt;跳格字数&gt;] [-w &lt;每列字符数&gt;] [--block-size&#x3D;&lt;区块大小&gt;] [--color&#x3D;&lt;使用时机&gt;] [--format&#x3D;&lt;列表格式&gt;] [-full-time] [--help] [--indicator-style&#x3D;&lt;标注样式&gt;] [--quoting-style&#x3D;&lt;引号样式&gt;] [--show-control-chars] [--sort&#x3D;&lt;排列方式&gt;] [--time&#x3D;&lt;时间戳记&gt;] [--version] [文件或目录...] 常用命令 12345678ls -a 列出所有文件，包括隐藏文件ls -l 详细列出目录下文件的权限、所有者、文件大小等详细信息 &lt;简写为: ll&gt;ls -F 列出目录下文件名及其目录类型ls -t 依照最后修改文件时间列出文件名ls -R 列出当前目录和其子目录的文件名ls -color&#x3D;never 不以颜色方式显示ls -color&#x3D;always 均以颜色方式显示ls -color&#x3D;auto 系统自动判断 2. cd切换用户当前目录 1234cd [目的目录 (绝对路径或相对路径) ]cd ~ 返回用户宿主目录cd . 用户的当前目录cd .. 返回上一级目录 3. pwd查看用户当前所在位置 4. mkdir创建目录，可在创建目录的同时设置目录的权限 语法 1mkdir [-p] [--help] [--version] [-m &lt;目录属性&gt;] [目录名称] 参数 -m&lt;目录属性&gt; 或 –mode&lt;目录属性&gt; : 建立目录同时设置目录的权限 -p 或 –parents: 若所要建立目录的上层目录目前尚未建立，一并建立 –help: 显示帮助 –verbose: 显示执行时的详细信息 –version: 显示版本信息 同时建立多个目录 1mkdir dir_name1 dir_name2 dir_name3 5. rmdir删除空目录，所删除目录必需为空 语法 1rmdir [-p] [--help] [--ignore-fail-on-non-empty] [--verbose] [--version] [目录...] 参数 -p 或 –parents: 删除指定目录后，若该目录的上层目录已变为空目录，则一并删除 –help: 在线帮助 –ignore-fail-on-non-empty: 忽略非空目录的错误信息 –verbose: 显示指令执行过程 –version: 显示版本信息 同时删除多个空目录 1rmdir dir_name1 dir_name2 dir_name3 6. cp复制文件或目录，可以同时输入多个文件或目录复制进入最后一个目录下 (如果最后一个目录存在的情况下) 语法 123456789cp [-abdfilpPrRsuvx] [-S &lt;备份字尾字符串&gt;] [-V &lt;备份方式&gt;] [--help] [--spares&#x3D;&lt;使用时机&gt;] [--version] [源文件或目录] [目标文件或目录] [目的目录] 部分参数 -b 或 –backup: 删除，覆盖目标文件之前的备份，备份文件会在字未添加备份字符串 -f 或 –force: 强制复制文件或目录，无论文件或目录是否存在 -l 或 –link: 对源文件建立硬连接而不是复制 -P 或 –preserve: 保留源文件或目录属性 -p 或 –parents: 保留源文件或目录的路径 -r 或 –recursive: 递归处理，将指定目录下文件与子目录一并处理 常用命令1cp 被复制文件或目录 复制进目录 7. rm删除文件或目录，删除目录必须加上 &quot;-r&quot; 语法 1rm [-dfirv] [--help] [--version] [文件或目录...] 参数 -d 或 –directory: 直接把欲删除的目录的硬连接数据删成0，删除该目录。 -f 或 –force: 强制删除文件或目录。 -i 或 –interactive: 删除既有文件或目录之前先询问用户。 -r 或 -R 或 –recursive: 递归处理，将指定目录下的所有文件及子目录一并处理。 -v 或 –verbose 显示指令执行过程。 –help: 在线帮助。 –version: 显示版本信息。 常用命令 rm -r: 循环删除到没有 rm -f: 强制删除 rm -rf: 强制删除文件 8. mv对文件或目录进行重命名或移动 语法 1mv [-bfiuv] [--help] [-S &lt;附加字尾&gt;] [-V &lt;方法&gt;] [源文件或目录] [目标文件或目录] 参数 -b 或 –backup: 若需覆盖文件，则覆盖前先行备份。 -f 或 –force: 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文 件或目录。 -i 或 –interactive: 覆盖前先行询问用户。 -S&lt;附加字尾&gt; 或 –suffix=&lt;附加字尾&gt;: 与-b参数一并使用，可指定备份文件的所要附加的字尾。 -u 或 –update: 在移动或更改文件名时，若目标文件已存在，且其文件日期比源文件新，则不覆盖目标文件。 -v 或 –verbose: 执行时显示详细的信息。 -V=&lt;方法&gt;或 –version-control=&lt;方法&gt;: 与-b参数一并使用，可指定备份的方法。 –help: 显示帮助。 –version: 显示版本信息。 9. cat用于最简单的文本查看，显示文件没有停顿，从第一行开始，最后只显示最后一行，不适合长文件 语法 1cat [-AbeEnstTuv] [--hellp] [--version] filename 参数 -n 或 –number: 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似: 对于空白行不编号 -s 或 –squeeze-blank: 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 常用命令 1234把 textfile1 的档案内容加上行号输入 textfile2 档案:cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里:cat -b textfile1 textfile2 &gt;&gt; textfile3 10. more/less与 cat 类似，用于大文件，分屏显示文件内容 (less最后一行显示当前阅读文件名称) 语法 12more [文件名]less [文件名] 11. find查找符合条件的文件或目录，速率低下 语法 1234567find [目录...] [-amin &lt;分钟&gt;] [-anewer &lt;参考文件或目录&gt;] [-atime &lt;24小时数&gt;] [-cmin &lt;分钟&gt;] [-user &lt;拥有者名称&gt;] ... 12. diff逐行比较文件的差异，需要指定比较目录，会比较目录中相同文件名的文件，但不会比较子目录 语法 12345678910diff [-abBcdefHilnNpPqrstTuvwy] [-&lt;行数&gt;] [-C &lt;行数&gt;] [-I &lt;字符或字符串&gt;] [-S &lt;文件&gt;] [-W &lt;宽度&gt;] [-x &lt;文件或目录&gt;] [-X &lt;文件&gt;] [文件或目录1] [文件或目录2] 参数 -&lt;行数&gt;: 指定比较行数 (必须与-c, -u一起使用) -b 或–ignore-space-change: 不检查空格字符的不同。 -B 或 –ignore-blank-lines: 不检查空白行 -c: 显示全部内文，并标出不同 -u: 以合并的方式显示文件内容不同 13. which查找文件，which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法 1which [文件...] 参数 -n&lt;文件名长度&gt;: 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p&lt;文件名长度&gt;: 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 -w: 指定输出时栏位的宽度。 -V: 显示版本信息。 14. ftp设置文件系统相关功能，文件传输协议 语法 1ftp [-dignv] [主机名称或IP地址] 参数 -d: 详细显示指令执行过程，便于排错或分析程序执行的情形。 -i: 关闭互动模式，不询问任何问题。 -g: 关闭本地主机文件名称支持特殊字符的扩充特性。 -n: 不使用自动登陆。 -v: 显示指令执行过程。 15. kill删除执行中的程序或工作 语法 1kill [-s &lt;信息名称或编号&gt;] [程序] 或 kill [-1 &lt;信息编号&gt;] 参数 -l &lt;信息编号&gt;: 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。 -s &lt;信息名称或编号&gt;: 指定要送出的信息。 【程序】: [程序]可以是程序的PID或是PGID，也可以是工作编号 16. sudo以其他身份来执行命令，预设的身份为root 语法 1sudo [-bhHpV] [-s &lt;shell&gt;] [-u &lt;用户&gt;] [指令] 或 sudo [-klv] 参数 -b: 在后台执行指令。 -h: 显示帮助 -H: 将HOME环境变量设为新身份的HOME环境变量。 -k: 结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。 -l: 列出目前用户可执行与无法执行的指令。 -p: 改变询问密码的提示符号。 -s: 执行指定的shell。 -u&lt;用户&gt;: 以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。 -v: 延长密码有效期限5分钟。 -V: 显示版本信息。 17. su临时变更用户身份，必须输入账号密码 语法 1su [-flmp] [--help] [--version] [-] [-c &lt;指令&gt;] [-s &lt;shell&gt;][用户帐号] 参数 -c&lt;指令&gt;或–command=&lt;指令&gt;: 执行完指定的指令后，即恢复原来的身份。 -f或–fast: 适用于csh与tsch，使shell不用去读取启动文件。 -.-l或–login: 改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。 -m,-p或–preserve-environment: 变更身份时，不要变更环境变量。 -s或–shell=: 指定要执行的shell。 –help: 显示帮助。 –version: 显示版本信息。 【用户帐号】: 指定要变更的用户。若不指定此参数，则预设变更为root。 18. who显示目前登录系统的用户信息，目前有那些用户登入系统，单独执行who指令会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个X显示器。 语法 1who [-Himqsw] [--help] [--version] [am i] [记录文件] 参数 -H或–heading: 显示各栏位的标题信息列。 -i或-u或–idle: 显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成&quot;.&quot;号，如果该用户已超过24小时没有任何动作，则标示出&quot;old&quot;字符串。 -m: 此参数的效果和指定&quot;am i&quot;字符串相同。显示自身用户名称 -q或–count: 只显示登入系统的帐号名称和总人数。 -s: 此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题。 -w或-T或–mesg或–message或–writable: 显示用户的信息状态栏。 –help: 在线帮助。 –version: 显示版本信息 19. tree以树状图列出指定目录下的所有文件，包括子目录里的文件。 语法 1tree [-aACdDfFgilnNpqstux] [-I &lt;范本样式&gt;] [-P &lt;范本样式&gt;] [目录...] 参数 -a: 显示所有文件和目录 -C: 在文件和目录清单加上色彩，便于区分各种类型。 -D: 列出文件或目录更改时间 -s: 列出文件或目录大小 20. gzip将文件压缩成 .gz 文件 语法 1gzip [-acdfhlLnNqrtvV] [-S &lt;压缩字尾字符串&gt;] [-&lt;压缩效率&gt;] [--best&#x2F;fast][文件...] 或 gzip [-acdfhlLnNqrtvV] [-S &lt;压缩字尾字符串&gt;] [-&lt;压缩效率&gt;] [--best&#x2F;fast] [目录] 参数 -d或–decompress或—-uncompress: 解开压缩文件。 -f或–force: 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -l或–list: 列出压缩文件的相关信息。 -n或–no-name: 压缩文件时，不保存原来的文件名称及时间戳记。 -N或–name: 压缩文件时，保存原来的文件名称及时间戳记。 -r或–recursive: 递归处理，将指定目录下的所有文件及子目录一并处理。 -&lt;压缩效率&gt;: 压缩效率是一个介于1－9的数值，预设值为&quot;6&quot;，指定愈大的数值，压缩效率就会愈高 –best: 此参数的效果和指定&quot;-9&quot;参数相同。 –fast: 此参数的效果和指定&quot;-1&quot;参数相同。 21. tar建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 语法 12345678910111213141516171819202122tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ] [-b &lt;区块数目&gt;] [-C &lt;目的目录&gt;] [-f &lt;备份文件&gt;] [-F &lt;Script文件&gt;] [-K &lt;文件&gt;] [-L &lt;媒体容量&gt;] [-N &lt;日期时间&gt;] [-T &lt;范本文件&gt;] [-V &lt;卷册名称&gt;] [-X &lt;范本文件&gt;] [-&lt;设备编号&gt;&lt;存储密度&gt;] [--after-date&#x3D;&lt;日期时间&gt;] [--atime-preserve] [--backuup&#x3D;&lt;备份方式&gt;] [--checkpoint] [--concatenate] [--confirmation] [--delete] [--exclude&#x3D;&lt;范本样式&gt;] ... [文件或目录...] 参数 -c或–create: 建立新的备份文件。 -f&lt;备份文件&gt;或–file=&lt;备份文件&gt;: 指定备份文件。 -v或–verbose: 显示指令执行过程。 22. zip压缩后产生 .zip 压缩文件 语法 12345678910zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$] [-b &lt;工作目录&gt;] [-ll] [-n &lt;字尾字符串&gt;] [-t &lt;日期时间&gt;] [-&lt;压缩效率&gt;] [压缩文件] [文件...] [-i &lt;范本样式&gt;] [-x &lt;范本样式&gt;] 参数 -A: 调整可执行的自动解压缩文件 -b&lt;工作目录&gt;: 指定暂时存放文件的目录。 -F: 尝试修复已损坏的压缩文件。 -J: 删除压缩文件前面不必要的数据。 -m: 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。 -r: 递归处理，将指定目录下的所有文件和子目录一并处理。 -z: 替压缩文件加上注释。 -&lt;压缩效率&gt;: 压缩效率是一个介于1-9的数值。 23. pstree以树状图显示程序,清楚地表达程序间的相互关系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序当作基层，然后显示该用户的所有程序。 语法 1pstree [-acGhlnpuUV] [-H &lt;程序识别码&gt;] [&lt;程序识别码&gt;&#x2F;&lt;用户名称&gt;] 参数 -a: 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。 -c: 不使用精简标示法。 -G: 使用VT100终端机的列绘图字符。 -h: 列出树状图时，特别标明现在执行的程序。 -H&lt;程序识别码&gt;: 此参数的效果和指定&quot;-h&quot;参数类似，但特别标明指定的程序。 -l: 采用长列格式显示树状图。 -n: 用程序识别码排序。预设是以程序名称来排序。 -p: 显示程序识别码。 -u: 显示用户名称。 -U: 使用UTF-8列绘图字符。 -V: 显示版本信息。 24. ps报告程序执行状况的指令，可以搭配kill指令随时中断，删除不必要的程序。 语法 1ps [-aAcdefHjlmNVwy] [acefghLnrsSTuvxX] ... 参数 -a: 显示所有终端机下执行的程序，除了阶段作业领导者之外。 a: 显示现行终端机下的所有程序，包括其他用户的程序。 -A: 显示所有程序。 c: 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 e: 列出程序时，显示每个程序所使用的环境变量。 -H: 显示树状结构，表示程序间的相互关系。","categories":[],"tags":[{"name":"Linux_study","slug":"Linux-study","permalink":"http://yoursite.com/tags/Linux-study/"}]},{"title":"css_note","slug":"css_note","date":"2020-07-27T12:12:54.000Z","updated":"2020-07-31T13:56:24.158Z","comments":true,"path":"2020/07/27/css-note/","link":"","permalink":"http://yoursite.com/2020/07/27/css-note/","excerpt":"","text":"CSS Study一、CSS 初步 添加 CSS把 styles.css 和 index.html 联结起来，可以在HTML文档中，&lt;head&gt;语句模块里面加上下面的代码： 1&lt;link rel&#x3D;&quot;styesheet&quot; href&#x3D;&quot;styles.css&gt; 二、构建 CSS 块 层叠与继承1. 冲突规则 层叠 Stylesheets cascade（样式表层叠） — 简单的说，css规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。 优先级 一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。 一个类选择器稍微具体点 — 它会选择该页面中有特定 class 属性值的元素 — 所以它的优先级就要高一点。 继承 如果设置一个元素的 color 和 font-family ，每个在里面的元素也都会有相同的属性，除非直接在元素上设置属性。2. 理解继承 控制继承 CSS 为控制继承提供了四个特殊的通用属性值。每个css属性都接收这些值。 inherit设置该属性会使子元素属性和父元素相同。实际上，就是 &quot;开启继承&quot;. initial 设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。 unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样 重设所有属性值 CSS 的 shorthand 属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个(inherit, initial, unset, or revert)。这是一种撤销对样式所做更改的简便方法，以便回到之前已知的起点。 CSS 选择器1. 选择器列表单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上,如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。 123h1, .special &#123; color: blue; &#125;2. 选择器的种类 类型、类、id选择器 123h1 &#123;&#125; &#x2F;*类型选择器*&#x2F;.box &#123;&#125; &#x2F;*类选择器*&#x2F;#unique &#123;&#125; &#x2F;*ID 选择器*&#x2F; 标签属性选择器 12a[title] &#123; &#125; &#x2F;*根据一个元素上的某个标签的属性的存在以选择元素的不同方式*&#x2F;a[href&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;] &#123; &#125; &#x2F;*根据一个有特定值的标签属性是否存在来选择*&#x2F; 伪类和伪元素 1234&#x2F;*包含了伪类，用来样式化一个元素的特定状态*&#x2F;a:hover &#123; &#125; &#x2F;*:hover伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：*&#x2F;&#x2F;*包含了伪元素，选择一个元素的某个部分而不是元素自己*&#x2F;p::first-line &#123; &#125; &#x2F;*::first-line是会选择一个元素（下面的情况中是&lt;p&gt;）中的第一行，类似&lt;span&gt;包在了第一个被格式化的行外面，然后选择这个&lt;span&gt;。*&#x2F; 运算符 12&#x2F;*将其他选择器组合起来，更复杂的选择元素*&#x2F;article &gt; p &#123; &#125; &#x2F;*用运算符（&gt;）选择了&lt;article&gt;元素的初代子元素。*&#x2F; 盒模型1. 块级盒子（Block box） 和 内联盒子（Inline box） 块级盒子（Block box）标题(&lt;h1&gt;等)和段落(&lt;p&gt;)默认情况下都是块级的盒子。 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽 每个盒子都会换行 width 和 height 属性可以发挥作用 内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开” 内联盒子（Inline box） 用做链接的 &lt;a&gt; 元素、 &lt;span&gt;、 &lt;em&gt; 以及 &lt;strong&gt; 都是默认处于 inline 状态 盒子不会产生换行。 width 和 height 属性将不起作用。 垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。2. CSS 盒模型完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content 盒模型的各个部分 Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height. Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。 Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。 Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。 标准盒模型 在标准模型 (标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box) 中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。 1234567.box &#123; width: 350px; height: 150px; margin: 25px; padding: 25px; border: 5px solid black; &#125; 替代（IE）盒模型 css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用替代模型，通过为其设置 box-sizing: border-box 来实现。 123.box &#123; box-sizing: border-box; &#125; 使用调试工具来查看盒模型 (F12)3. 外边距，内边距，边框 (详细) 外边距 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。 使用margin属性一次控制一个元素的所有边距，或者 每边单独使用等价的普通属性控制： margin margin-top margin-right margin-bottom margin-left参数 &lt;length&gt;:指定一个固定的宽度。可以为负数。 &lt;percentage&gt; 相对于该元素的包含块的宽度（相对于该块的百分比）。该值可以为负数。 margin: auto; /* 该盒子是水平居中的, 上下边距为0 */ 浏览器会自动选择一个合适的margin来应用。它可以用于将一个块居中。比如，div { width:50%; margin:0 auto; } 会把这个div容器水平居中。 只有一个 值时，这个值会被指定给全部的 四个边. 两个 值时，第一个值被匹配给 上和下, 第二个值被匹配给 左和右. 三个 值时，第一个值被匹配给 上, 第二个值被匹配给 左和右, 第三个值被匹配给 下. 四个 值时，会依次按 上、右、下、左 的顺序匹配 (即顺时针顺序). 边框 边框是在边距和填充框之间绘制的。标准的盒模型，边框的大小将添加到框的宽度和高度。替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。 border属性一次设置所有四个边框的宽度、颜色和样式。 123.box &#123; border: 1px solid black; &#125; 等价于 12345.box &#123; border-width: 1px; border-style: solid; border-color: black; &#125; 分别设置每边的宽度、颜色和样式，可以使用： border-top border-right border-bottom border-left 设置所有边的颜色、样式或宽度，请使用以下属性： border-width border-style border-color 设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一 border-top-width border-top-style border-top-color border-right-width border-right-style border-right-color border-bottom-width border-bottom-style border-bottom-color border-left-width border-left-style border-left-color 圆角 border-radius border-radius属性和与方框的每个角相关的长边来实现方框的圆角。可以使用两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，这两个值都将使用。 使一个盒子的四个角都有10px的圆角半径： 123.box &#123; border-radius: 10px; &#125; 右上角的水平半径为1em，垂直半径为10％： 123.box &#123; border-top-right-radius: 1em 10%; &#125; 由方形变为圆123.box&#123; border-radius: 50%;&#125; 内边距 内边距位于边框和内容区域之间。与外边距不同，不能有负数量的内边距，所以值必须是0或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。 使用padding简写属性控制元素所有边 每边单独使用等价的普通属性： padding-top padding-right padding-bottom padding-left4. 使用display: inline-blockdisplay有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用:不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。 一个元素使用 display: inline-block，实现我们需要的块级的部分效果： 设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。 背景与边框1. CSS 的背景样式 背景颜色 background-color background-color属性定义了CSS中任何元素的背景颜色。属性接受任何有效的&lt;color&gt;值。背景色扩展到元素的内容和内边距的下面。 背景图片 background-image background-image属性允许在元素的背景中显示图像。 控制背景平铺 background-repeat background-repeat属性用于控制图像的平铺行为。可用的值是: no-repeat — 不重复。 repeat-x —水平重复。 repeat-y —垂直重复。 repeat — 在两个方向重复。 调整背景图像的大小 background-size background-size属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。也可以使用关键字: cover —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外 contain — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。 背景图像定位 background-position background-position属性允许您选择背景图像显示在其应用到的盒子中的位置。它使用的坐标系中，框的左上角是(0,0) (默认)，框沿着水平(x)和垂直(y)轴定位。 常见的背景位置值有两个单独的值——一个水平值后面跟着一个垂直值。` 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top center; &#125; 或者使用 长度值, and 百分比： 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: 20px 10%; &#125; 混合使用关键字，长度值以及百分比 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top 20px;&#125; 4-value语法来指示到盒子的某些边的距离12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top 20px right 10px; &#125; 渐变背景 使用background-image属性设置。 多背景图像 在单个属性值中指定多个background-image值，用逗号分隔每个值，会发生图像重叠.其他 background-*属性也可以有值逗号分隔的方式休市对应的的background-image： 12background-image: url(image1.png), url(image2.png), url(image3.png), url(image1.png);background-repeat: no-repeat, repeat-x, repeat; 背景附加 指定如何滚动时，内容滚动。这是由background-attachment属性控制的，它可以接受以下值: scroll:使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。 fixed: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。 local: 这个值是后来添加的(它只在Internet Explorer 9+中受支持，而其他的在IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。 CSS 的值与单位 数字，长度和百分比 数值类型 描述 integer 整数 number 表示一个小数——它可能有小数点后面的部分，也可能没有 dimension 有一个附加的单位，例如45deg、5s或10px。是一个伞形类别，包括、、和类型。 percentage 表示一些其他值的一部分，例如50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。 绝对长度 单位 名称 cm 厘米 mm 毫米 Q 四分之一毫米 in 英寸 pc 十二点活字 pt 点 px 像素 相对长度与单位 单位 相对于 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width ex 字符“x”的高度 ch 数字“0”的宽度 rem 根元素的字体大小 lh 元素的line-height vw 视窗宽度的1% vh 视窗高度的1% vmin 视窗较小尺寸的1% vmax 视图大尺寸的1% 三、样式化 文本字体样式作用于字体的属性，会直接应用到文本中，比如使用哪种字体，字体的大小是怎样的，字体是粗体还是斜体，等等。 颜色: color 属性设置选中元素的前景内容的颜色 123p&#123; color &#x3D; red;&#125; 字体种类: font-family 属性, 允许为浏览器指定一个字体 (或者一个字体的列表)，然后浏览器可以将这种字体应用到选中的元素上。浏览器只会把在当前机器上可用的字体应用到当前正在访问的网站上；如果字体不可用，那么就会用浏览器默认的字体代替 default font. 123p&#123;font-family: arial;&#125; 网络安全字体： 可以应用到所有系统 (Arial, Courier New, Georgia, Times New Roman, Trebuchet MS, Verdana) 默认字体: serif, sans-serif, monospace, cursive,和 fantasy。 serif sans-serif monospace cursive fantasy 有衬线的字体 （衬线一词是指字体笔画尾端的小装饰，存在于某些印刷体字体中） 没有衬线的字体 每个字符具有相同宽度的字体，通常用于代码列表 用于模拟笔迹的字体，具有流动的连接笔画 用来装饰的字体 字体栈: 包含一个font-family属性，其值由几个用逗号分离的字体名称组成，便于浏览器多种选择 123p&#123; font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif;&#125; 字体大小: font-size 属性设置，可以取大多数单位，常用单位为: px, em, rem 使用 em / rem 时以 父元素/根元素的大小为基础大小 px(像素) em rem 绝对单位,任何情况下，页面上的文本所计算出来的像素值都是一样的 1em 等于我们设计的当前元素的父元素上设置的字体大小 ,em可以调整任何东西的大小，不只是文本 1rem 等于 HTML 中的根元素的字体大小 ，而不是父元素，更容易计算字体大小 字体样式，字体粗细，文本转换和文本装饰 font-style: 用来打开和关闭文本 italic (斜体)。 可能的值如下： normal: 将文本设置为普通字体 (将存在的斜体关闭) italic: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。 oblique: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。 font-weight: 设置文字的粗体大小。这里有很多值可选 (比如 -light, -normal, -bold, -extrabold, -black, 等等), 不过事实上你很少会用到 normal 和 bold以外的值： normal, bold: 普通, 加粗字体 lighter, bolder: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。100–900: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。 text-transform: 允许你设置要转换的字体。值包括： none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。 text-decoration: 设置/取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线, 可以接受多个值，同时为一段文本设置上、下、中划线) 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线. overlinre: 文本上划线 line-through: 穿过文本的线 文字阴影: text-shadow 属性。这最多需要 4 个值 (正偏移 1px向右移动，负偏移 -1px向左移动) : 阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 length and size units, 但是 px 是比较合适的。这个值必须指定。 阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。 模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为0，这意味着没有模糊。可以使用大多数的 CSS 单位 length and size units. 阴影的基础颜色，可以使用大多数的 CSS 颜色单位 CSS color unit. 如果没有指定，默认为 black.123p&#123; text-shadow: 4px 4px 5px red;&#125; 多种阴影 包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本 1234text-shadow: -1px -1px 1px #aaa, 0px 4px 1px rgba(0,0,0,0.5), 4px 4px 5px rgba(0,0,0,0.7), 0px 0px 7px rgba(0,0,0,0.4); 文本布局作用于文本的间距以及其他布局功能的属性，比如，允许操纵行与字之间的空间，以及在内容框中，文本如何对齐。 文本对齐: text-align 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下: left: 左对齐文本。 right: 右对齐文本。 center: 居中文字 justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 hyphens，打破一些更长的词语。 行高: line-height 属性设置文本每行之间的高，可以接受大多数单位，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 font-size 来获得 line-height。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的1.5倍，你可以使用这个: 1line-height: 1.5; 字母和单词间距: letter-spacing 和 word-spacing 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 12345把这个样式应用到 &lt;p&gt; 段落的第一行：p::first-line &#123; letter-spacing: 2px; word-spacing: 4px;&#125; 其他可能用到的属性 Font 样式: font-variant: 在小型大写字母和普通文本选项之间切换。 font-kerning: 开启或关闭字体间距选项。 font-feature-settings: 开启或关闭不同的 OpenType 字体特性。 font-variant-alternates: 控制给定的自定义字体的替代字形的使用。 font-variant-caps: 控制大写字母替代字形的使用。 font-variant-east-asian: 控制东亚文字替代字形的使用, 像日语和汉语。 font-variant-ligatures: 控制文本中使用的连写和上下文形式。 font-variant-numeric: 控制数字，分式和序标的替代字形的使用。 font-variant-position: 控制位于上标或下标处，字号更小的替代字形的使用。 font-size-adjust: 独立于字体的实际大小尺寸，调整其可视大小尺寸。 font-stretch: 在给定字体的可选拉伸版本中切换。 text-underline-position: 指定下划线的排版位置，通过使用 text-decoration-line 属性的underline 值。 text-rendering: 尝试执行一些文本渲染优化。 文本布局样式： text-indent: 指定文本内容的第一行前面应该留出多少的水平空间。 text-overflow: 定义如何向用户表示存在被隐藏的溢出内容。 white-space: 定义如何处理元素内部的空白和换行。 word-break: 指定是否能在单词内部换行。 direction: 定义文本的方向 (这取决于语言，并且通常最好让HTML来处理这部分，因为它是和文本内容相关联的。) hyphens: 为支持的语言开启或关闭连字符。 line-break: 对东亚语言采用更强或更弱的换行规则。 text-align-last: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。 text-orientation: 定义行内文本的方向。 word-wrap: 指定浏览器是否可以在单词内换行以避免超出范围。 writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向。样式列表列表特定样式三个属性可以在 &lt;ul&gt; 或 &lt;ol&gt; 元素上设置： list-style-type ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。 list-style-position ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。 list-style-image ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。 符号样式 list-style-type 属性允许设置列表元素的 marker（比如圆点、符号、或者自定义计数器样式） disc 实心圆点 (默认值) circle 空心圆点 square 实心方块 decimal 十进制阿拉伯数字,从1开始 cjk-decimal 中日韩十进制数, 例如: 一, 二, 三, ..., 九八, 九九, 一〇〇 decimal-leading-zero, E.g. 01, 02, 03, … 98, 99 lower-roman, E.g. i, ii, iii, iv, v… upper-roman, E.g. I, II, III, IV, V… lower-greek, E.g. α, β, γ… lower-alpha, E.g. a, b, c, … z upper-alpha, E.g. A, B, C, … Z 项目符号位置 list-style-position 设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。默认值为 outside，这使项目符号位于列表项之外。如果值设置为 inside，项目条目则位于行内。 使用自定义的项目符号图片 list-style-image 属性允许对于项目符号使用自定义图片,在控制项目符号的位置，大小等方面是有限的,可以对无序排列更改 1234567ul li &#123; padding-left: 2rem; background-image: url(star.svg); background-position: 0 0; background-size: 1.6rem 1.6rem; background-repeat: no-repeat; &#125; 管理列表计数在有序列表上进行不同的计数方式。例如： 从1以外的数字开始，或向后倒数，或者按步或多于1计数。 start start 属性允许你从1 以外的数字开始计数。 12345&lt;ol start&#x3D;&quot;4&quot;&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; reversed reversed 属性将启动列表倒计数 12345&lt;ol start&#x3D;&quot;4&quot; reversed&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; value value 属性允许设置列表项指定数值 12345&lt;ol start&#x3D;&quot;4&quot; reversed&gt; &lt;li value&#x3D;2&gt;&lt;&#x2F;li&gt; &lt;li value&#x3D;4&gt;&lt;&#x2F;li&gt; &lt;li value&#x3D;6&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 样式化链接 链接状态 链接存在时处于不同的状态，每一个状态都可以用对应的 伪类 来应用样式: Link (没有访问过的): 这是链接的默认状态，当它没有处在其他状态的时候，它可以使用:link 伪类来应用样式。 Visited: 这个链接已经被访问过了(存在于浏览器的历史纪录), 它可以使用 :visited 伪类来应用样式。 Hover: 当用户的鼠标光标刚好停留在这个链接，它可以使用 :hover 伪类来应用样式。 Focus: 一个链接当它被选中的时候 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 HTMLElement.focus()) 它可以使用 :focus 伪类来应用样式。 Active: 一个链接当它被激活的时候 (比如被点击的时候)，它可以使用 :active 伪类来应用样式。 默认样式 链接具有下划线。 未访问过的 (Unvisited) 的链接是蓝色的。 ``访问过的 (Visited) 的链接是紫色的.` 悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。` 选中 (Focus) 链接的时候，链接周围会有一个轮廓，你应该可以按 tab 来选中这个页面的链接 (在 Mac 上, 你可能需要使用Full Keyboard Access: All controls 选项，然后再按下 Ctrl + F7 ，这样就可以起作用) 激活 (Active) 链接的时候会变成红色 (当你点击链接时，请尝试按住鼠标按钮。) 将样式应用到一些链接 (必需按顺序) 123456789101112131415161718a &#123;&#125;a:link &#123;&#125;a:visited &#123;&#125;a:focus &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125; 在链接中包含图标 (属性选择器——a[href*=&quot;http&quot;] 选中 &lt;a&gt; 元素，但是这样只会选中那些拥有 href 属性，且属性的值包含 &quot;http&quot; 的 &lt;a&gt;的元素。指定位置为100%，使其出现在内容的右边，距离上方是0px, padding-right ，为背景图片留出空间，这样就不会和文本重叠。) 12345a[href*&#x3D;&quot;http&quot;] &#123; background: url(&#39;https:&#x2F;&#x2F;mdn.mozillademos.org&#x2F;files&#x2F;12982&#x2F;external-link-52.png&#39;) no-repeat 100% 0; background-size: 16px 16px; padding-right: 19px;&#125; 样式化链接为按钮 具体请看","categories":[],"tags":[{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"python_常用模块","slug":"python_常用模块","date":"2020-07-26T12:12:54.000Z","updated":"2020-08-31T12:58:59.410Z","comments":true,"path":"2020/07/26/python-chang-yong-mo-kuai/","link":"","permalink":"http://yoursite.com/2020/07/26/python-chang-yong-mo-kuai/","excerpt":"","text":"模块制作 “”” “”” / # : 顶格写的注释被称为文档 (__doc__)，在模块中的注释与帮助，可以通过 help(model_name) 查看 import model_name / from model_name import function_name 常用模块 random 随机模块 random.random 随机生成 0~1 间小数 random.randint 随机生成指定范围的整数，包含上下限 random.randrange 随机生成指定 range 范围的整数，不包含上限 randrange(self, start, stop=None, step=1, _int=int) random.choice 随机获取指定序列的一个元素 random.sample 随机获取指定序列的指定个元素 sample(self, population, k) (k:获取元素数目，population:指定序列(列表)) random.shuffle 随机打乱序列(列表)数据 pip 内置包管理工具 pip install package (-i 国内源地址 换源) pip uninstall package pip list 展示 pip update 更新 windows 安装不上部分包 安装 wheel 包 (先支持安装 .whl 包) pip install package.whl linux 压缩包安装 解压 找到 setup.py python setup.py install 安装包 os 路径 os.system(&quot;cmd命令&quot;) 调用 cmd 并执行命令 os.chdir 修改 python 工作路径 os.chdir(&quot;D:\\\\&quot;) os.mkdir 创建文件夹，在当前路径下 os.walk(pwd) 返回一个生成器(generator),遍历得到内容 每次遍历所得到的返回对象都是一个三元组(path, dirs, files) path : 指的是当前正在遍历的这个文件夹的本身路径地址 dirs : 内容是该文件夹中所有的目录的名字 (不包括子目录)，有多个以列表返回 files : 内容是指该文件夹中所有的文件 (不包括子目录)，有多个以列表返回 os.csandir() 返回文件详细信息，需要遍历读取 使用 stat() 方法 查看 st_size : 文件的体积大小 (单位 :bytes /1024 == KB) st_atime : 文件的最近访问时间 st_mtime : 文件的最近修改时间 st_ctime : Windows 下表示创建时间 st_birthtime : 只在 Mac、Linux 下可用,表示创建时间12345678import osfor file in os.scandir(&quot;..&#x2F;&quot;): print(file, file.name, file.stat())&quot;&quot;&quot;&lt;DirEntry &#39;.git&#39;&gt; .git os.stat_result(st_mode&#x3D;16895, st_ino&#x3D;0, st_dev&#x3D;0, st_nlink&#x3D;0, st_uid&#x3D;0, st_gid&#x3D;0, st_size&#x3D;0, st_atime&#x3D;1598876157, st_mtime&#x3D;1598876157, st_ctime&#x3D;1570419765)&lt;DirEntry &#39;.idea&#39;&gt; .idea os.stat_result(st_mode&#x3D;16895, st_ino&#x3D;0, st_dev&#x3D;0, st_nlink&#x3D;0, st_uid&#x3D;0, st_gid&#x3D;0, st_size&#x3D;0, st_atime&#x3D;1598876405, st_mtime&#x3D;1598876368, st_ctime&#x3D;1598661487)&quot;&quot;&quot; os.path os.path.isdir 是否是文件夹 os.path.getsize 获取文件/夹大小 os.path.join(&#39;a&#39;, &#39;b&#39;) 自动拼接成路径 ==&gt; &#39;a\\\\b&#39; os.path.dirname 返回文件目录，可以嵌套一直向上返回目录 12&gt;&gt;&gt; os.path.dirname(os.path.dirname(os.path.abspath(&#39;board&#39;))) &#39;E:\\\\python_study\\\\Django&#39; os.path.abspath 绝对路径 sys 系统 sys.argv 接收调用python脚本时传递的参数，以列表格式，第一个参数是文件本身相对路径 sys.exit() 涉及到时间以及内存分配方面释放 file : open(file, mode=&#39;r&#39;, buffering=None, encoding=None, errors=None, newline=None, closefd=True) 读取文件 WordCloud 词云模块 install wordcloud```1234567891011121314151617181920211. &#96;常用参数&#96; + &#96;width 词云图片宽度，默认400像素&#96; + &#96;height 词云图片高度 默认200像素&#96; + &#96;background_color 词云图片的背景颜色，默认为黑色&#96; + &#96;font_step 字号增大的步进间隔 默认1号&#96; + &#96;font_path 指定字体路径 默认None，对于中文可用font_path&#x3D;&#39;msyh.ttc&#39;&#96; + &#96;mini_font_size 最小字号 默认4号&#96; + &#96;max_font_size 最大字号 根据高度自动调节&#96; + &#96;max_words 最大词数 默认200&#96; + &#96;stop_words 不显示的单词 stop_words&#x3D;&#123;&quot;python&quot;,&quot;java&quot;&#125;&#96; + &#96;Scale 默认值1。值越大，图像密度越大越清晰&#96; + &#96;prefer_horizontal：默认值0.90，浮点数类型。表示在水平如果不合适，就旋转为垂直方向，水平放置的词数占0.9？&#96; + &#96;relative_scaling：默认值0.5，浮点型。设定按词频倒序排列，上一个词相对下一位词的大小倍数。有如下取值：“0”表示大小标准只参考频率排名，“1”如果词频是2倍，大小也是2倍&#96; + &#96;mask 指定词云形状图片，默认为矩形&#96; &#96;通过以下代码读入外部词云形状图片（需要先pip install imageio安装imageio）&#96; &#96;&#96;&#96;&#96;python import imageio from wordcloud import WordCloud mk &#x3D; imageio.imread(&quot;picture.png&quot;) w &#x3D; WordCloud(mask&#x3D;mk) &#96; jieba 中文分词 install jieba```1231. &#96;方法&#96; + &#96;jieba.cut: 返回的结构是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)&#96; + &#96;&#96;&#96;cut(self, sentence, cut_all&#x3D;False, HMM&#x3D;True, use_paddle&#x3D;False) + `参数` 1. `需要分词的字符串` 2. `cut_all 参数: 用来控制是否采用全模式` 3. `HMM 参数: 用来控制是否使用 HMM 模型` 4. `use_paddle 参数: 用来控制是否使用paddle模式下的分词模式，paddle模式采用延迟加载方式，通过enable_paddle接口安装paddlepaddle-tiny，并且import相关代码` + `jieba.cut_for_search: 返回的结构是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)` + ```cut_for_search(self, sentence, HMM=True)``` + `参数` 1. `需要分词的字符串` 2. `是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细` + `jieba.lcut: 返回list` 12def lcut(self, *args, **kwargs): return list(self.cut(*args, **kwargs)) + `jieba.lcut_for_search: 返回 list` 12def lcut_for_search(self, *args, **kwargs): return list(self.cut_for_search(*args, **kwargs)) turtle 绘图 turtle: 绘图包 fillcolor：填充颜色 begin_fill/end_fill 开始/结束填充 设置画布大小1234turtle.screensize(canvwidth&#x3D;None,canvheight&#x3D;None,bg&#x3D;None)， 参数分别为画布的宽(单位像素),高,背景颜色。如： turtle.screensize(800,600,&quot;green&quot;) turtle.screensize()#返回默认大小(400,300) 画笔(画笔的属性，颜色、画线的宽度等) 参数 turtle.pensize(): 设置画笔的宽度； turtle.pencolor(): 没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如&quot;green&quot;,&quot;red&quot;,也可以是RGB3元组。 turtle.speed(speed): 设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。 turtle.forward(distance): 向当前画笔方向移动distance像素长度 turtle.backward(distance): 向当前画笔相反方向移动distance像素长度 turtle.right(degree): 顺时针移动degree° turtle.left(degree): 逆时针移动degree° turtle.pendown(): 移动时绘制图形，缺省时也为绘制 turtle.goto(x,y): 将画笔移动到坐标为x,y的位置 turtle.penup(): 提起笔移动，不绘制图形，用于另起一个地方绘制 turtle.circle(): 画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆 setx( ): 将当前x轴移动到指定位置 sety( ): 将当前y轴移动到指定位置 setheading(angle): 设置当前朝向为angle角度 home(): 设置当前画笔位置为原点，朝向东。 dot(r): 绘制一个指定直径和颜色的圆点 画笔控制命令 turtle.fillcolor(colorstring): 绘制图形的填充颜色 turtle.color(color1, color2): 同时设置pencolor=color1, fillcolor=color2 turtle.filling(): 返回当前是否在填充状态 turtle.begin_fill(): 准备开始填充图形 turtle.end_fill(): 填充完成 turtle.hideturtle(): 隐藏画笔的turtle形状 turtle.showturtle(): 显示画笔的turtle形状 全局控制命令 turtle.clear(): 清空turtle窗口，但是turtle的位置和状态不会改变 turtle.reset(): 清空窗口，重置turtle状态为起始状态 turtle.undo(): 撤销上一个turtle动作 turtle.isvisible(): 返回当前turtle是否可见 stamp(): 复制当前图形 turtle.write(s [,font=(&quot;font-name&quot;,font_size,&quot;font_type&quot;)]): 写文本，s为文本内容，font是字体的参数，分别为字体名称，大小和类型；font为可选项，font参数也是可选项 turtle.delay(delay=None): 设置或返回以毫秒为单位的绘图延迟 MyQR 二维码生成器 12345678910111213from MyQR import myqrimport osmyqr.run( word &#x3D; &#39;&#39;, # 可以是字符串也可以是网址 (网址前加 http(s):&#x2F;&#x2F;) version &#x3D; 1, # 容错率等级 1 为最高 level &#x3D; &#39;H&#39;, # 控制纠错水平，范围是 L, M, Q, H，从左向右依次增高 picture &#x3D; &#39;&#39;, # 二维码和图片合成，二维码路径 colorized &#x3D; &#39;True&#39;, # 是否为彩色二维码 contrast &#x3D; 1.0, # 调节图片对比度, 1.0 表示原始图片，更小的值表示更低对比度，更大反之，1.0 为默认 brightness &#x3D; 1.0, # 调节图片亮度，越大越亮，越小越暗 save_name &#x3D; &#39;&#39;, # 生成二维码图片名称，可以是 jpg, png, bmp, gif save_dir &#x3D; os.getcwd() # 控制生成位置 ) JSON json.dumps() 将 Python 对象编码成 JSON 字符串,将json格式的字符串(str)转换为字典类型(dict)的数据 json.loads() 将已编码的 JSON 字符串解码为 Python 对象,返回来，是将字典类型(dict)的数据转换成json格式的字符串 json.load() 用于读取json格式的文件，将文件中的数据转换为字典类型(dict) json.dump() 主要用于存入json格式的文件，将字典类型转换为json形式的字符串 eg: 将 python 数据结构转换为 JSON 1234567import jsondata &#x3D; &#123; &quot;name&quot;: &#39;ACME&#39;, &quot;shares&quot;: 100, &quot;price&quot;: 524.24&#125;json_str &#x3D; json.dumps(data) 将一个 JSON 编码字符串转换回一个 Python 数据结构 1data &#x3D; json.loads(json_str) 编码解码 JSON 数据 123456# 写入一个 json 数据with open(&quot;data.json&quot;, &#39;w&#39;) as f: json.dump(data, f)with open(&#39;data.json&#39;, &#39;r&#39;) as f: data &#x3D; json.load(f) Requests import requests 请求 请求方式 GET requests.get(url) 传递 URL 参数 123payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: [&#39;value2&#39;, &#39;value3&#39;]&#125;r &#x3D; requests.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;, params&#x3D;payload)# http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;value1&amp;key2&#x3D;value2&amp;key2&#x3D;value3 POST r = requests.post(url, data={&quot;key&quot;: &quot;value&quot;} 传递 data 参数 1234567891011payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;, data&#x3D;payload)print(r.text)&#123; ... &quot;form&quot;: &#123; &quot;key2&quot;: &quot;value2&quot;, &quot;key1&quot;: &quot;value1&quot; &#125;, ...&#125; PUT r = requests.put(url, data={&quot;key&quot;: &quot;value&quot;}) DELETE r = requests.delete(url) HEAD r = requests.head(url) OPTIONS r = requests.options(url) 请求头 fake_useragent 模块随机产生请求头 1234 from fake_useragent import UserAgent headers = &#123;\"User-Agent\": str(UserAgent().random)&#125; ``` + 传递浏览器参数 headers = {‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36’}123456783. Cookie + 响应中的 Cookie &#96;&#96;&#96;python import requests r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;requests.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;user&#x2F;quickstart.html&#39;) print(r.cookies) # &lt;RequestsCookieJar[Cookie(version&#x3D;0, name&#x3D;&#39;__cfduid&#39;, value&#x3D;&#39;d22fadb1898ae38e2bc7f811090da41db1595923633&#39;, # port&#x3D;None, port_specified&#x3D;False, domain&#x3D;&#39;.readthedocs.io&#39;, domain_specified&#x3D;True, domain_initial_dot&#x3D;True, path&#x3D;&#39;&#x2F;&#39;, path_specified&#x3D;True, secure&#x3D;False, expires&#x3D;1598515633, discard&#x3D;False, comment&#x3D;None, comment_url&#x3D;None, rest&#x3D;&#123;&#39;HttpOnly&#39;: None, &#39;SameSite&#39;: &#39;Lax&#39;&#125;, rfc2109&#x3D;False)]&gt; 发送 Cookies123import requestsurl = 'https://requests.readthedocs.io/zh_CN/latest/user/quickstart.html'cookies = dict(Cookie=\"(version=0, name='__cfduid', value='d22fadb1898ae38e2bc7f811090da41db1595923633', port=None, port_specified=False, domain='.readthedocs.io', domain_specified=True, domain_initial_dot=True, path='/', path_specified=True, secure=False, expires=1598515633, discard=False, comment=None, comment_url=None, rest=&#123;'HttpOnly': None, 'SameSite': 'Lax'&#125;)\") 响应 响应状态码 r.status_code 响应头 r.headers 二进制响应内容 r.content (对于非文本请求) Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。 123456# 以请求返回的二进制数据创建一张图片import requestsfrom PIL import Imagefrom io import BytesIOr = requests.get(url='')i = Image.open(BytesIO(r.content)) JSON 响应内容 r.json 123456789101112 import requests r = requests.get(url='') r.json() ``` 3. 原始响应内容(原始套接字响应) r.raw ```python import requests r = requests.get(url='', stream=True) print(r.raw) # &lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt; print(r.raw.read(10)) # '\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03' Socket() 模块 1234socket.socket(socket_family, socket_type, protocol&#x3D;0)socket_family: socket.AF_UNIX 或 socket.AF_INETsocket_type: socket.SOCK_STREAM (TCP) 或 socket.SOCK_DGRAM (UDP)protocol: 通常省略，默认为 0 TCP/IP 套接字 tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)UDP/IP 套接字 udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM){如果使用 from socket import * 大大缩短代码 tcpSocket = socket(AF_INET, SOCK_STREAM)} 套接字内置方法 服务器套接字 s.bind() 将地址 (主机名，端口号对) 绑定到套接字 s.listen() 设置并启动 TCP 监听器 s.accept() 被动接受 TCP 客户端连接，一直等待直到连接到达 (阻塞) 客户端套接字 s.connect() 主动发起 TCP 服务器连接 s.connect_ex() 类似 connect ,但以错误码形式返回问题，不是抛出异常 普通套接字方法 s.recv() 接收 TCP 消息 s.recv_into() 接收 TCP 消息到指定缓冲区 s.send() 发送 TCP 消息 s.sendall() 完整地发送 TCP 消息 s.recvfrom() 接收 UDP 消息 s.recvfrom_into() 接收 UDP 消息到指定缓冲区 s.sendto() 发送 UDP 消息 s.getpeername() 连接到套接字 (TCP) 的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式 (仅支持 Windows) 面向阻塞的套接字方法 s.setblocking() 设置套接字的阻塞或非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 或去阻塞套接字操作的超时时间 面向文件的套接字方法 s.fileno() 套接字的文件描述符 s.makefile() 创建与套接字关联的文件对象 数据属性 s.family 套接字家族 s.type 套接字类型 s.proto 套接字协议 glob 模块 (采取类似于“正则”的方式，进行文件匹配) 模式 意义 * 匹配所有 ? 匹配任何单个字符 [seq] 匹配 seq 中的任何字符 [!seq] 匹配任何不在 seq 中的字符 123456789101112131415import globfor i in glob.glob(&quot;..&#x2F;*.txt&quot;): print(i)&quot;&quot;&quot;..\\Django_note.txt..\\Email_Token.txt..\\jQuery_note.txt&quot;&quot;&quot;for i in glob.glob(&quot;..&#x2F;*a*.txt&quot;): print(i)&quot;&quot;&quot;..\\Django_note.txt..\\Email_Token.txt&quot;&quot;&quot; shutil 模块 (复制、移动文件及文件夹) import shutil shutil.copy(&quot;要复制的文件&quot;, &quot;要复制到的位置&quot;) 复制文件 shutil.copytree(&quot;要复制的文件夹&quot;, &quot;要复制到的新文件夹的位置&quot;) 复制文件夹，相当于重命名文件夹 将某个文件夹移动到另外一个文件夹(该文件夹必须是新文件夹)，不能是已经存在了的文件夹； shutil.move(&quot;要移动的文件/文件夹&quot;, &quot;要移动到的位置&quot;) 移动文件/文件夹 文件夹或者文件被移动后，原始文件就没有了 shutil.rmtree(&quot;要删除的文件夹&quot;) 删除文件夹 创建和解压压缩包 (.zip 格式) import zipfile 1. 读取压缩包内文件 [有时候需要在 filename.encoding(&quot;cp437&quot;).decode(&quot;utf-8&quot;)] 12345678910import zipfilewith zipfile.ZipFile(&quot;..&#x2F;ziji.zip&quot;, &quot;r&quot;) as zipobj: print(zipobj.namelist())&quot;&quot;&quot;[&#39;1.gif&#39;, &#39;__pycache__&#x2F;&#39;, &#39;__pycache__&#x2F;taichi.cpython-37.pyc&#39;, &#39;build&#x2F;&#39;,]&quot;&quot;&quot;with zipfile.ZipFile(&quot;..&#x2F;ziji.zip&quot;, &quot;r&quot;) as zipobj: for filename in zipobj.namelist(): print(filename.encode(&quot;gbk&quot;).decode(&quot;gbk&quot;)) 2. 读取压缩包内的文件信息 1234567891011import zipfilewith zipfile.ZipFile(&quot;..&#x2F;ziji.zip&quot;, &quot;r&quot;) as zipobj: for filename in zipobj.namelist(): info &#x3D; zipobj.getinfo(filename) new_filename &#x3D; filename.encode(&quot;cp437&quot;).decode(&quot;utf-8&quot;) print(new_filename, info.file_size&#x2F;1024&#x2F;1024, info.compress_size&#x2F;1024&#x2F;1024)&quot;&quot;&quot;1.gif 0.3085899353027344 0.3054962158203125build&#x2F;taichi&#x2F;Analysis-00.toc 0.1259927749633789 0.011130332946777344&quot;&quot;&quot; 3. 解压压缩包 + `extract(&quot;压缩包内要解压的文件名&quot;, &quot;要解压到的位置&quot;)` : 将压缩包内单个文件解压出来 1234import zipfile with zipfile.ZipFile(&quot;..&#x2F;ziji.zip&quot;, &quot;r&quot;) as zipobj: zipobj.extract(&quot;1.gif&quot;, &quot;.&#x2F;&quot;) + `extractall(&quot;解压到的位置&quot;)` : 将压缩包内所有文件解压出来 4. 创建压缩包 + 对某些文件，创建压缩包 123456import zipfilefile_list &#x3D; [&quot;practice_16_20.py&quot;, &quot;Practice_21-24.py&quot;]with zipfile.ZipFile(r&quot;.测试用压缩包.zip&quot;, &quot;w&quot;) as zipobj: for file in file_list: zipobj.write(file) + 向已存在压缩包内添加文件 123456import zipfilefile_list &#x3D; [&quot;test1.txt&quot;, &quot;test2.py&quot;]with zipfile.ZipFile(r&quot;.测试用压缩包.zip&quot;, &quot;a&quot;) as zipobj: for file in file_list: zipobj.write(file)","categories":[],"tags":[{"name":"Python 模块","slug":"Python-模块","permalink":"http://yoursite.com/tags/Python-%E6%A8%A1%E5%9D%97/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-26T11:07:53.209Z","updated":"2020-07-26T11:07:53.210Z","comments":true,"path":"2020/07/26/hello-world/","link":"","permalink":"http://yoursite.com/2020/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"pyspider","slug":"pyspider","permalink":"http://yoursite.com/tags/pyspider/"},{"name":"Python 面试","slug":"Python-面试","permalink":"http://yoursite.com/tags/Python-%E9%9D%A2%E8%AF%95/"},{"name":"HeroKu Server","slug":"HeroKu-Server","permalink":"http://yoursite.com/tags/HeroKu-Server/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Pyecharts","slug":"Pyecharts","permalink":"http://yoursite.com/tags/Pyecharts/"},{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://yoursite.com/tags/Chrome-DevTools/"},{"name":"PEP8 编程风格规范","slug":"PEP8-编程风格规范","permalink":"http://yoursite.com/tags/PEP8-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/"},{"name":"Flask_Study","slug":"Flask-Study","permalink":"http://yoursite.com/tags/Flask-Study/"},{"name":"Windows problem","slug":"Windows-problem","permalink":"http://yoursite.com/tags/Windows-problem/"},{"name":"scrapy_study","slug":"scrapy-study","permalink":"http://yoursite.com/tags/scrapy-study/"},{"name":"Linux_study","slug":"Linux-study","permalink":"http://yoursite.com/tags/Linux-study/"},{"name":"前端学习","slug":"前端学习","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Python 模块","slug":"Python-模块","permalink":"http://yoursite.com/tags/Python-%E6%A8%A1%E5%9D%97/"}]}